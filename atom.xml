<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zane&#39;s Blog</title>
  <subtitle>爱编程，爱生活，不羁放纵爱自由</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-10-26T14:28:06.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zane Xu</name>
    <email>zanebot96@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BitmapPool的设计与实践</title>
    <link href="http://yoursite.com/2016/10/26/BitmapPool%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2016/10/26/BitmapPool的设计与实践/</id>
    <published>2016-10-26T13:46:48.000Z</published>
    <updated>2016-10-26T14:28:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>未经博主同意，不得转载该篇文章</strong></p>
<h2 id="前言">前言</h2><p>​   前一段时间在重新做自己的图片提供器的开发库<a href="https://github.com/Zane96/EasyImage" target="_blank" rel="external">EasyImage</a>, 把加载网络图片的这块的功能完成了。主要也是在练习一下Java并发的东西。在完成了基本的架构之后，我发现RecycleView加载图片的时候，快速滑动列表的时候卡顿非常的明显。和<strong>Glide</strong>比起来差太远。虽然完全不是一个量级的东西。但是还是想做点什么让卡顿降低一点。</p>
<h2 id="问题">问题</h2><p>​   如果要问卡顿出现的原理，不是本文的讨论的重点。总之来说，就是手机超过了16ms才去刷新一个帧，就会导致界面卡顿。我通过Monitor跟踪分析了RecycleView快速滑动的时候的内存占用。发现Bitmap在疯狂的产生，清除。在图像上产生了大量的强制gc的信号。嗯，虽然RecycleView的ImageView重用了，但是Bitmap的内存是不停的根据适配进来的数据生成，释放，生成，释放…。所以造成大量的虚拟机强制GC，导致界面卡顿。所以，很简单的道理，应该想到将Bitmap的内存复用起来。毕竟RecycleView中重复加载的的Bitmap的Config都是一致的。</p>
<p>​   并且<strong>Glide</strong>， <strong>Fresco</strong>都是使用了Bitmap复用技术。总的来说，解决方式找到了，但是如何解决还是遇到了很多问题。</p>
<ul>
<li>我开发的是一个图片加载库，那么我如何找到Bitmap内存回收的Point？如何找到Bitmap内存复用的Point?毕竟这个复用操作对开发者是隐藏的。我不可能去让开发者在Adapter的ViewHolder中去回调Bitmap复用／释放的操作。</li>
<li>如何判断一个Bitmap是否该回收？如果这个Bitmap被多个ImageView引用了怎么办？</li>
<li>如何将被复用的Bitmap内存和新的数据融合？</li>
<li>LruCache的时候是否该回收？DiskCache呢？如果Bitmap在LruCache存储中因为内存满了被踢出了缓存中或者因为数据源对应缓存的Bitmap数据更新而被踢出内存中的旧Bitmap，如果给它的引用计数减1？</li>
<li>如何通过ImageView的宽高来拿到相对应的Bitmap的宽高？（后面内存复用的时候需要这个）</li>
</ul>
<p>基于以上的问题，我基本上一步步的进行了解决，最终完成了BitmapPool的设计。</p>
<h2 id="设计">设计</h2><p>​   先上一张导图。</p>
<p>​   <img src="/img/bitmappool1.jpg" alt=""></p>
<p>​   可以看到，我基本上将很多功能都已经模块化了。首先一个图片加载库，会提供多种数据形式的数据加载，网络，Resource，本地文件，缓存等等。而这些不同的加载形式都可以封装成不同的加载模块或者说加载策略。然后通过策略模式去提供不同的加载模块。所以在这里我们把他们看成<strong>数据提供源</strong>。（这里的数据源最终转换成Bitmap的像素点阵）</p>
<p>​   所有的数据源提供的数据都通过BitmapDecode和Bitmap内存融合。然后拥有了全新像素点阵的Bitmap全部被封装成LeasedDrawable发布到UImageLoader中进行最终的渲染。所以很清楚的发现，<strong>UImageLoader</strong>中就是Bitmap被复用的计数点。</p>
<p>​   <strong>计数点和LeasedDrawable</strong>可以一起来解释。上述的第二个问题，实际上可以被JVM中内存是否该被回收中的引用计数算法解决。如果发布一次，那么引用计数加1，回首一次，那么引用计数减1。如果减完了之后引用计数为0，那么就可以进行内存的回收到BitmapPool中等待复用了。而谁来进行引用的计数呢？很简单的道理，使用<strong>BitmapDrawable</strong>。在RecycleView加载图片错位那里，我也是通过这个类将Bitmap进行封装，然后存储它的Task解决的。一样的道理，这里也是进行对Bitmap的二次封装，然后进行引用计数的增加或者减少。</p>
<p>​   可以看到数据源那里我写了<strong>DiskCache</strong>，但是没有<strong>LruCache</strong>。其实这个问题不难。。我也不知道为啥我会被傻x的困扰了好久（大概是因为最近太开心了吧2333，科科，严肃）。LruCache实际是一个将点对点的映射（数据源信息到拥有正确像素点阵的Bitmap）关系存储到了内存中。所以，存储进去的时候，我们不应该引用计数减1啊，，因为还在内存中啊少年。但是DiskCache直接将Bitmap打成了Stream存入了磁盘中。所以Disk和Lru需要分开对待。</p>
<p>​   还有一点，如果Bitmap在Lru中因为Lru的内存空间忙了而被踢出去了，怎么拿到被剔除的Bitmap并且进行回收操作？嗯，，我还不是不知道，但是我通过看Lru的源码发现了这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Called for entries that have been evicted or removed. This method is</span><br><span class="line">     * invoked when a value is evicted to make space, removed by a call to</span><br><span class="line">     * &#123;<span class="doctag">@link</span> #remove&#125;, or replaced by a call to &#123;<span class="doctag">@link</span> #put&#125;. The default</span><br><span class="line">     * implementation does nothing.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;The method is called without synchronization: other threads may</span><br><span class="line">     * access the cache while this method is executing.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> evicted true if the entry is being removed to make space, false</span><br><span class="line">     *     if the removal was caused by a &#123;<span class="doctag">@link</span> #put&#125; or &#123;<span class="doctag">@link</span> #remove&#125;.</span><br><span class="line">     * <span class="doctag">@param</span> newValue the new value for &#123;<span class="doctag">@code</span> key&#125;, if it exists. If non-null,</span><br><span class="line">     *     this removal was caused by a &#123;<span class="doctag">@link</span> #put&#125;. Otherwise it was caused by</span><br><span class="line">     *     an eviction or a &#123;<span class="doctag">@link</span> #remove&#125;.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">entryRemoved</span><span class="params">(<span class="keyword">boolean</span> evicted, K key, V oldValue, V newValue)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​   看到没，<strong>@param evicted true if the entry is being removed to make space</strong>。通过源码可以发现，entryRemoved方法只在<strong>trimToSize</strong>方法中才会传入True</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Remove the eldest entries until the total of remaining entries is at or</span><br><span class="line"> * below the requested size.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> maxSize the maximum size of the cache before returning. May be -1</span><br><span class="line"> *            to evict even 0-sized elements.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>​   注释写的很清楚了。所以，我们只需要继承LruCache然后实现<strong>entryRemoved</strong>方法，并且当<strong>evicted</strong>为True的时候将Bitmap的引用计数减1就可以了。</p>
<p>​   解决了以上问题之后，还剩最后一点。如何将内存复用？好像通过Bitmap的API或者文档看不出来能直接更改像素点阵的方法。好在有<strong>inBitmap</strong>这个玩意。详情请查阅文档：<a href="https://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inBitmap" target="_blank" rel="external">传送门</a>。使用BitmapFactory.Option的这个字段，可以做到通过这个Option加载新的Bitmap的时候将bitmap内存复用。但是在Android4.4之上的版本使用的时候有些小限制：</p>
<ul>
<li>被加载的Bitmap必须是jpg或者png格式的图片</li>
<li>inSampleSize字段必须是1</li>
<li>两个Bitmap的Configuration（这里是size）必须相同</li>
</ul>
<p>所以完全可以看出来，google做的这个优化完全就是为了优化RV加载网络图片的。</p>
<p>对。。还有最后一点，如何通过ImageView的size路由到上次被渲染的Bitmap的size？我反正是写了一些Ugly Code，我在BitmapDecode中做了一个“路由表”用来存储映射关系。</p>
<h2 id="实践">实践</h2><p>​   把以上的问题和思路都解决理清之后，就可以开始实践了！</p>
<p>​   先上core class <strong>BitmapPool</strong>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 16/10/19.</span><br><span class="line"> * Email: zanebot96<span class="doctag">@gmail</span>.com</span><br><span class="line"> * Blog: zane96.github.io</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Bitmap中的bitmap存储数据结构,需要在代码中进行线程安全的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Bitmap&gt; mBitmaps = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//位图池是否正在销毁</span></span><br><span class="line">    <span class="keyword">boolean</span> isRecycled;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BitmapPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isRecycled = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保持单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BitmapPool instance = <span class="keyword">new</span> BitmapPool();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BitmapPool <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * inBitmap这个字段从Android 3.0才添加,而4.4之后才要求我如下代码的要求。这里我们只要大于3.0的版本</span><br><span class="line">     * 我们都满足如下要求,因为本来这里就是为生成大量Bitmap的具有回收机制的控件而设计的(item中Bitmap的config相同)</span><br><span class="line">     * <span class="doctag">@param</span> width</span><br><span class="line">     * <span class="doctag">@param</span> height</span><br><span class="line">     * <span class="doctag">@return</span> true 在Bitmap中找到了合适的Bitmap内存空间,false 没有找到合适的Bitmap,需要自己生成</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> BitmapFactory.<span class="function">Options <span class="title">getReuseOption</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBitmaps)&#123;</span><br><span class="line">            Log.i(<span class="string">"BitmapPool"</span>, <span class="string">"Prereuse "</span> + mBitmaps.size()+ <span class="string">" size"</span>);</span><br><span class="line">            BitmapFactory.Options options = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB)&#123;</span><br><span class="line">                Bitmap reuseBitmap = getBitmapBySize(width, height);</span><br><span class="line">                <span class="keyword">if</span> (reuseBitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Log.i(<span class="string">"BitmapPool"</span>, <span class="string">"reuse"</span>);</span><br><span class="line">                    options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">                    options.inBitmap = reuseBitmap;</span><br><span class="line">                    options.inSampleSize = <span class="number">1</span>;</span><br><span class="line">                    options.inMutable = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> options;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 将Lru中</span><br><span class="line">     * <span class="doctag">@param</span> bitmap</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putReuseBitmap</span><span class="params">(Bitmap bitmap)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBitmaps)&#123;</span><br><span class="line">            Log.i(<span class="string">"BitmapPool"</span>, <span class="string">"putin"</span>);</span><br><span class="line">            mBitmaps.add(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据传入的所需要的Bitmap的宽和高来返回Bitmap池中符合要求的Bitmap.</span><br><span class="line">     * 必须是宽高一致。不然无法复用</span><br><span class="line">     * 注意不要出现ConcurrentModificationException</span><br><span class="line">     * <span class="doctag">@param</span> width</span><br><span class="line">     * <span class="doctag">@param</span> height</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Bitmap <span class="title">getBitmapBySize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">        List&lt;Bitmap&gt; removeBitmaps = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Bitmap returnBitmap = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Bitmap bitmap : mBitmaps)&#123;</span><br><span class="line">                <span class="keyword">if</span> (bitmap.isRecycled()) &#123;</span><br><span class="line">                    removeBitmaps.add(bitmap);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.i(<span class="string">"BitmapPool"</span>, <span class="string">"width height "</span> + width + <span class="string">" "</span> + height + <span class="string">" bitmap: "</span> + bitmap.getWidth() + <span class="string">" "</span> + bitmap.getHeight());</span><br><span class="line">                    <span class="keyword">if</span> (bitmap.getWidth() == width &amp;&amp; bitmap.getHeight() == height)&#123;</span><br><span class="line"></span><br><span class="line">                        removeBitmaps.add(bitmap);</span><br><span class="line">                        returnBitmap = bitmap;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mBitmaps.removeAll(removeBitmaps);</span><br><span class="line">            <span class="keyword">return</span> returnBitmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 清空BitmapPool缓存的Bitmap内存空间</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearBitmapPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBitmaps)&#123;</span><br><span class="line">            isRecycled = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!mBitmaps.isEmpty())&#123;</span><br><span class="line">                Bitmap bitmap = mBitmaps.remove(i);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (!bitmap.isRecycled())&#123;</span><br><span class="line">                    bitmap.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看和BitmapPool有着PY交易的LeasedDrawable类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**LeasedDrawable作为和BitmapPool进行交易的中间层</span><br><span class="line"> * 通过引用计数来管理Bitmap的回收/销毁 与否</span><br><span class="line"> *</span><br><span class="line"> * Created by Zane on 16/10/20.</span><br><span class="line"> * Email: zanebot96<span class="doctag">@gmail</span>.com</span><br><span class="line"> * Blog: zane96.github.io</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeasedDrawable</span> <span class="keyword">extends</span> <span class="title">BitmapDrawable</span> <span class="keyword">implements</span> <span class="title">ILeasedDrawable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger mReferenceCount;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean isRecycle = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BitmapPool bitmapPool = BitmapPool.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LeasedDrawable</span><span class="params">(Bitmap bitmap)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(bitmap);</span><br><span class="line">        mReferenceCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mReferenceCount.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRecycle.get())&#123;</span><br><span class="line">            mReferenceCount.decrementAndGet();</span><br><span class="line">            Bitmap bitmap = getBitmap();</span><br><span class="line">            Log.i(<span class="string">"LeasedDrawable"</span>, <span class="string">"reference count: "</span> + mReferenceCount);</span><br><span class="line">            <span class="keyword">if</span> (mReferenceCount.get() &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"reference to bitmap can't smaller than 0"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mReferenceCount.get() == <span class="number">0</span>)&#123;</span><br><span class="line">                isRecycle.set(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (bitmapPool.isRecycled)&#123;</span><br><span class="line">                    bitmap.recycle();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//回收内存</span></span><br><span class="line">                    Log.i(<span class="string">"LeasedDrawable"</span>, <span class="string">"recycle"</span>);</span><br><span class="line">                    bitmapPool.putReuseBitmap(bitmap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我觉得。。代码真的不复杂。并且如果实在开发中自己去做一个BitmapPool（如果你傻x的不用优秀的图片加载库）去优化性能，这一点都不难。</p>
<h2 id="总结">总结</h2><p>自己也快到了找实习的时候了。思想上跟不上，基础上跟不上我觉得会很糟糕。这个库本来就是写来练习设计模式的，基本上没有实践的用处。。不过，好在做完了，并且可以用。</p>
<p>最后一句话，朱大告诉我的：<strong>面试中，基础比深度重要</strong>。互勉。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;未经博主同意，不得转载该篇文章&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;​   前一段时间在重新做自己的图片提供器的开发库&lt;a href=&quot;https://github.com/Zane96/EasyImage&quot; target=
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>单元测试总结</title>
    <link href="http://yoursite.com/2016/09/20/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/09/20/单元测试总结/</id>
    <published>2016-09-20T05:05:15.000Z</published>
    <updated>2016-10-26T13:52:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单元测试小总结">单元测试小总结</h2><p>​ 单元测试往往在产品赶着上线的情况下被忽视。然后单元测试往往会节约大量修改bug的时间。还有一点，单元测试能够验证你的代码的结构是否具有松耦性，因为高度耦合的代码是难以做单元测试的。所以代码中经常通过Dagger来做单元测试。另一点，可以发现老外的项目基本上每个项目都做过不同程度的单元测试，不论项目是大是小，然而中国人好像比较忽视这一点，从现在AS一打开都会给你建测试包都可以看出来老外是很重视单元测试的。</p>
<h3 id="单元测试是什么">单元测试是什么</h3><p>​ 不关有单元测试，还有UI测试，集成测试等等。单元测试简单的来说就是来验证某个类里面的某个方法能不能传入一个参数然后返回一个我们预期的值，如果没有返回值就去验证函数中代码能不能正常按预期跑一遍。实际上是如何测试是个非常灵活的事情。常用的单元测试框架有：JUnit，Mockito，Robolectric，DaggerMock等等</p>
<h3 id="最简单的示例">最简单的示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Add</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 对上述代码进行单元测试只需要最基本的JUnit框架就够了，没错，就是AS给你自动引入的JUnit。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">addTest</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">      Add add = <span class="keyword">new</span> Add();</span><br><span class="line">    assertEquals(<span class="number">3</span>, add.sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 然后将直接control+sheft+R运行这个测试方法。看上面的代码当然是可以通过，所以控制台会直接通过，如果将预期值改为4，那么就会报错。</p>
<p>​ 所以单元测试大概可以看成三部分：</p>
<ul>
<li>初始化对象</li>
<li>调用</li>
<li>验证</li>
</ul>
<p>​ 也许这样的代码让你觉得单元测试毫无意义，但是在实际项目中，复杂的逻辑没有这么好写单元测试。首先MVP这样的模块化解耦构建的项目会对单元测试代码的书写轻松很多。总之：<strong>松耦合</strong></p>
<p>​ <strong>JUnit</strong>还有很有的小使用技巧：比如@Before，@After，@Beforeclass，@Afterclass，fail（），assertXXXXXX（）等等，可以在我最下面的推荐的文章里面去深入学习。这里我们只做大概的介绍和总结。</p>
<h3 id="用Mockito去做一些不可思议的事情">用Mockito去做一些不可思议的事情</h3><p>​ Mockito中有一个类很重要叫<strong>Mock</strong>。不知道听说过Mock数据没有，就是用自己模拟的数据去代替真实的数据，实际开发中，移动端和后台定义好json字段之后，移动端可以先用Mock数据代替真实数据，和后台一起进行开发。这里的Mock类一样道理，就是在单元测试中去模拟一个实例，然后代替需要被测试的代码中真实的对象。然后通过Mock出来的对象替换被测试代码中的对象，再使用Mockito进行验证对象的函数是否成功被调用。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserManager mUserManager = <span class="keyword">new</span> UserManager();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (username == <span class="keyword">null</span> || username.length() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (password == <span class="keyword">null</span> || password.length() &lt; <span class="number">6</span>) <span class="keyword">return</span>;</span><br><span class="line">        mUserManager.performLogin(username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserManager</span><span class="params">(UserManager userManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mUserManager = userManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginPresenterTest</span></span>&#123;</span><br><span class="line">  <span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    UserManager mockUserManager = Mockito.mock(UserManager.class);</span><br><span class="line">    LoginPresenter loginPresenter = <span class="keyword">new</span> LoginPresenter();</span><br><span class="line">    loginPresenter.setUserManager(mockUserManager);</span><br><span class="line"></span><br><span class="line">    loginPresenter.login(<span class="string">"xiaochuang"</span>, <span class="string">"xiaochuang password"</span>);</span><br><span class="line"></span><br><span class="line">    Mockito.verify(mockUserManager).performLogin(<span class="string">"xiaochuang"</span>, <span class="string">"xiaochuang password"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概步骤如下：</p>
<ul>
<li>Mock对象出来</li>
<li>将对象手动替换到被测试代码中</li>
<li>验证Mock对象的函数是否被成功调用</li>
</ul>
<p>也许你发现了，这样必须要给被测试类写一个setter方法，这是极度。。不优雅的。所以！所以！我们引出了Dagger来给我们将Mock对象注入到被测试类～～（激动）</p>
<p><strong>Mockito</strong>的功能大概如下：</p>
<ul>
<li>更改Mock对象的函数行为</li>
<li>验证Mock对象的函数是否被调用</li>
</ul>
<p>具体的，，使用方法当然不再多说。</p>
<h3 id="通过Robolectrie在JVM上直接加载Android类">通过Robolectrie在JVM上直接加载Android类</h3><p>​ 单元测试方便的就是不需要跑一遍项目，不需要打一堆Log，不需要balabala~，但是Android类是不能直接跑在JVM上的，只能在手机上的虚拟机上（ART）。所以如果单元测试中涉及到Android类，就通过Robolectrio来解决。我感觉他的思路就是类似动态代理一样的在代码跑的过程中用他自己的类来替换Android类。比如Activity就对应了ShadowActivity类。并且这些代理类还提供了更多的接口让开发者能够更方便的获得对象的状态。</p>
<p>Ps：Robolectrie对于as插件的版本要求比较坑，我遇到一个版本bug，弄了一下午。。。</p>
<h3 id="通过Dagger来优雅的进行依赖注入">通过Dagger来优雅的进行依赖注入</h3><p>​ <strong>Dagger</strong>的使用自然我不会在这里多说。我说说单元测试是如何使用Dagger的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginTestModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginTestModule</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">provideContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordValidator <span class="title">providePasswordValidator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PasswordValidator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">provideSharedPreferences</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PreferenceManager.getDefaultSharedPreferences(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiService <span class="title">provideApiService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UsersManager <span class="title">provideUserManager</span><span class="params">(SharedPreferences sp, ApiService service)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UsersManager(sp, service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoginPresenter <span class="title">provideLoginPresenter</span><span class="params">(UsersManager manager, PasswordValidator passwordValidator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoginPresenter(manager, passwordValidator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>(modules = &#123;LoginTestModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginTestComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Inject</span></span><br><span class="line">    LoginPresenter loginPresenter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditText mUsername;</span><br><span class="line">    <span class="keyword">private</span> EditText mPassword;</span><br><span class="line">    <span class="keyword">private</span> Button mButton;</span><br><span class="line">    <span class="keyword">private</span> LinearLayoutManager layoutManager;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过一个holder来传入mock出来的mocule</span></span><br><span class="line">        LoginComponentHolder.getComponent().inject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        mUsername = (EditText) findViewById(R.id.edit_name);</span><br><span class="line">        mPassword = (EditText) findViewById(R.id.edit_password);</span><br><span class="line">        mButton = (Button) findViewById(R.id.button);</span><br><span class="line"></span><br><span class="line">        mButton.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            String username = mUsername.getText().toString();</span><br><span class="line">            String password = mPassword.getText().toString();</span><br><span class="line">            loginPresenter.login(username, password);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginComponentHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LoginTestComponent component;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setComponent</span><span class="params">(LoginTestComponent component2)</span></span>&#123;</span><br><span class="line">        component = component2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoginTestComponent <span class="title">getComponent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> component;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中要测试的是Button点击之后presenter的login（）方法会被成功调用。loginPresenter是通过项目中使用Dagger简单注入进去的（<strong>注意是通过Field Injection inject进去的</strong>），并且我们用一个ComponentHolder来维护这个Module对应的Component。测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RunWith</span>(RobolectricGradleTestRunner.class)</span><br><span class="line"><span class="annotation">@Config</span>(constants = BuildConfig.class, sdk = <span class="number">21</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginPresenterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LoginTestModule mockModule;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//不能调用mock()因为dagger规定module的provide方法不能返回null</span></span><br><span class="line">        mockModule = Mockito.spy(<span class="keyword">new</span> LoginTestModule(RuntimeEnvironment.application));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMainActivityLogin</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        LoginPresenter loginPresenter = Mock(LoginPresenter.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始更改mockModule的方法行为,返回mock的loginPresenter到mockModule的dependency中去</span></span><br><span class="line">        Mockito.when(mockModule.provideLoginPresenter(Mockito.any(UsersManager.class),</span><br><span class="line">                Mockito.any(PasswordValidator.class))).thenReturn(loginPresenter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将这个module生成的component放到容器中去</span></span><br><span class="line">        LoginTestComponent component = DaggerLoginTestComponent.builder()</span><br><span class="line">                .loginTestModule(mockModule)</span><br><span class="line">                .build();</span><br><span class="line">        LoginComponentHolder.setComponent(component);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过Robolectric生成mock MainActivity</span></span><br><span class="line">        MainActivity mainActivity = Robolectric.setupActivity(MainActivity.class);</span><br><span class="line">        ((EditText)mainActivity.findViewById(R.id.edit_name)).setText(<span class="string">"zane"</span>);</span><br><span class="line">        ((EditText)mainActivity.findViewById(R.id.edit_password)).setText(<span class="string">"123"</span>);</span><br><span class="line">        Button mButton = (Button) mainActivity.findViewById(R.id.button);</span><br><span class="line">        mButton.performClick();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证</span></span><br><span class="line">        Mockito.verify(loginPresenter).login(<span class="string">"zane"</span>, <span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 大致的思路其实就是Mock对应的Module，然后通过Mockito来更改provide方法的行为（返回一个Mock对象，更改Module的Dependency），然后将Mock的Module（更改了Dependency行为）注入到ComponentHolder中。最终MainActivity中inject的时候，就会被注入一个Mock对象。</p>
<p>​ 首先强调一点，不应该为了使用Dagger而使用Dagger。嗯，就是如果能不用Dagger，那就尽量不用。首先上面我强调了LoginPresenter是通过Field Inject的方式注入进去的，一般通过这种方式注入进去的，很难不通过更改Dagger依赖图去改变注入的依赖对象。但是如果LoginPresenter是通过Constructor Inject注入到依赖图的话，完全可以调用构造函数new一个对象出来，构造函数的参数都可以直接传进去，所以不用费大力气去修改依赖图了。</p>
<h3 id="使用DaggerMock来简化代码">使用DaggerMock来简化代码</h3><p>​ 如果觉得上述通过Dagger来做单元测试代码还是很复杂，可以使用黑科技DaggerMock来简化你的代码。在使用这个框架之前必须学习一下JUnit的Rule。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> DaggerMockRule daggerMockRule = <span class="keyword">new</span> DaggerMockRule(LoginTestComponent.class, <span class="keyword">new</span> LoginTestModule(RuntimeEnvironment.application))</span><br><span class="line">            .set(<span class="keyword">new</span> DaggerMockRule.ComponentSetter() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setComponent</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                    LoginComponentHolder.setComponent((LoginTestComponent) o);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"> <span class="annotation">@Mock</span></span><br><span class="line"> LoginPresenter loginPresenter;</span><br></pre></td></tr></table></figure>
<p>就靠这些模版代码就可以轻松的将loginPresenter注入到被测试代码中。</p>
<ul>
<li>通过JUnit的Rule注解来修饰DaggerMockRule，然后告诉DaggerMock你想怎么build Component，使用什么Module，Component build了之后放到哪里。</li>
<li>通过Mock注解修饰你需要修改的依赖对象</li>
<li>框架会反射，再遍历Module中所有被@Provider修饰的函数，如果发现返回的对象类型是@Mock修饰的对象类型，那么就会进行Mock替换。</li>
</ul>
<h3 id="异步代码的单元测试">异步代码的单元测试</h3><p>​ 对于异步的单元测试，有两种解决办法</p>
<ul>
<li>等待异步执行完，回调之后在进行比较</li>
<li>将异步过程在测试代码中转换成同步过程</li>
</ul>
<p>异步的实现手段太多了，线程池，AsyncTask，<strong>RxJava</strong>等等….</p>
<p>第一种方式我们可以通过CountDownLatch来通知异步完成，还可以在Callback中直接测试。这种方式适用于所有拥有Callback形式的异步操作。</p>
<p>第二种方式，比如线程池，我们可以通过依赖注入一个同步的线程池来解决，Rxjava可以使用上述方式，因为Subscriber实际上是一个Callback，可以通过自定义调度插件（RxjavaScheduleHook）来覆盖默认的线程调度方式。</p>
<p><strong>Ps：Android Studio2.2正式版已经默认导入Espresso进行UI测试了</strong></p>
<hr>
<p>参考代码：<a href="https://github.com/lanshan-studio/Android-UnitTest" target="_blank" rel="external">AndroidUnitTest</a></p>
<p>参考文章：<a href="http://chriszou.com/2016/07/24/android-unit-testing-daggermock.html" target="_blank" rel="external">小创的系列教程</a>(作者是蘑菇街的Android开发工程师。敬佩，感谢写出如此优秀的单元测试教学系列文章)</p>
<p>官方文档：<a href="https://google.github.io/android-testing-support-library/" target="_blank" rel="external">官方文档</a></p>
<p>官方代码示例：<a href="https://github.com/googlesamples/android-testing" target="_blank" rel="external">android-test</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单元测试小总结&quot;&gt;单元测试小总结&lt;/h2&gt;&lt;p&gt;​ 单元测试往往在产品赶着上线的情况下被忽视。然后单元测试往往会节约大量修改bug的时间。还有一点，单元测试能够验证你的代码的结构是否具有松耦性，因为高度耦合的代码是难以做单元测试的。所以代码中经常通过Dagger来
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android系统安全学习（二）</title>
    <link href="http://yoursite.com/2016/09/16/Android%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/09/16/Android系统安全学习（二）/</id>
    <published>2016-09-16T07:31:02.000Z</published>
    <updated>2016-10-26T13:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android中系统Service的安全">Android中系统Service的安全</h2><h3 id="Binder的安全">Binder的安全</h3><ul>
<li>RPC的server端里面的bind thread里面bind会调用getCallingUID()方法来进行对调用远程服务的客户端的check，bind自然是运行在bind thread pool里面的。</li>
<li>ServiceManager是一个远程服务名字管理（注册）器，服务可以通过向ServiceManager注册来使自己晋升为系统服务。提供一个AddService和getService两种服务。他自己的binder是0，在自己这个process fork出来的时候就已经被注册了。</li>
</ul>
<h3 id="Zygote进程fork子进程的安全问题">Zygote进程fork子进程的安全问题</h3><ul>
<li>startActivity的时候，在AMS环境中处理的时候，当activity实例还未生成的时候，会先fork一个进程出来，不然通过反射弄出来的组件实例没有运行环境。在Process.start()之前，会通过PMS解析apk获得uid和gid，然后将这两个参数以及其他参数传给Process.start()方法。这个方法里面会像Zygote进程提出一个request，通过一个ConnectScoket进行连接，将request以二进制流的形式传给Zygote，然后会收到一个pid。Zygote进程里面在main()函数里面会初始化一个功能，循环的读取Peer，并且把这个Peer转换为ZygoteSocket，然后读取request信息，然后就开始fork并且获取进程pid了。</li>
</ul>
<ul>
<li>fork是在Native层做得，因为子进程的EffectiveUID和RealUID世袭父进程的RealUID。并且Zygote进程的RealUID = root，所以需要给fork出来的进程的uid改成request传进来的uid，gid，降级。这些都是在Native层做得。之后回到Java层，才会跳到ActivityThread里面进程activity实例的构建等等等等…。</li>
</ul>
<h3 id="Zygote进程Socket的安全检查">Zygote进程Socket的安全检查</h3><ul>
<li>再从Socket获得Peer的时候，会进行很多东西的检查。比如先检查远端请求进程的UID，如果是root，那么接受，如果是系统服务进程，要么必须要求他说要求让我fork的进程的uid的数字是大于1000的（即一个普通进程），不然就拒绝。当然，普通应用是没资格请求Zygote去fork进程的。</li>
</ul>
<h3 id="ContentProvider以及URI的安全理解">ContentProvider以及URI的安全理解</h3><p>ps：<strong>找到共性，进行抽象</strong></p>
<ul>
<li>ContentProvider就是对一个app的文件，数据库等等数据对外提供一个统一的数据接口，并且可以进程不同app应用之间的数据传递。ContentProvider的设计实际上也是使用了Binder进行跨进程，进而也是一种C/S的设计理念。</li>
<li>Android进程之间都有自己的工作目录，并且地址空间也是分离的，想要直接access是不可以的。</li>
<li>一个ContentProvider的访问权限在manifast里面定义，另一个应用的ContentResolver访问的时候通过URI来提供权限给数据提供者check。URI：content://权限/数据。</li>
</ul>
<h3 id="Policy模式">Policy模式</h3><p>​ 安卓中解决用户隐私，安全的策略模式</p>
<h3 id="SDCard安装应用">SDCard安装应用</h3><ul>
<li>往SD卡上装的应用必须要给手机设备绑定，因为SDccard是可以拔出的，然而数据不应该任何设备都可以访问，所以应用和私有数据会通过SystemKey加密存储在SD卡的.Android_Secure这个隐藏文件夹里面。System key存储在系统的/data/misc/systemkeys文件里。</li>
</ul>
<h3 id="SuperUser机制">SuperUser机制</h3><ul>
<li>换字体，换开机动画，删除系统应用等等都需要Root权限。</li>
<li>Root刷机，找到系统漏洞之后，就会在system文件夹里面安装su文件和superuser apk。su的Owner和Group都是Root，具有可执行权限，并且具有setUid和setGid的权限（会提升或者叫改变自己的EffectiveUID）</li>
<li>RootExplorer会运行su文件（先通过Runtime启动一个shell，然后通过shell启动SU进程），su首先EUID会继承父进程的RUID，生成完进程之后就会通过SUID将自己的EUID提升为Root。SU起来之后，会启动一个SuperuserRequestActivity来询问用户是否授权，并且用户未做决定之前会一直循环的读sqlite中的某个标志位，如果用户允许那么SU继续运行，否则return退出。</li>
<li>在得到用户的允许之后，SU会将自己的RUID设置为Root，使得SU的子进程都是Root的。并且SU自己本身不会去主动fork子进程，而是在SU的进程空间里面去load shell的代码，这样SU只提供一个ROOT的运行空间，如果SU的RUID不是Root，那么sh如果需要启动其他子进程的话，就不会是Root的进程了，那么就会出问题，所以SU的RUID必须为Root</li>
<li>RootExplorer在做了上述的启动过程之后，就可以通过IO流向 shell中写命令，然后这些命令都会在SU中去运行。所以Android中App获得Root权限不是自身的UID升级为Root，而是通过具有Root权限的sh流在执行shell命令。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Android中系统Service的安全&quot;&gt;Android中系统Service的安全&lt;/h2&gt;&lt;h3 id=&quot;Binder的安全&quot;&gt;Binder的安全&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;RPC的server端里面的bind thread里面bind会调用getCallin
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android系统安全学习（一）</title>
    <link href="http://yoursite.com/2016/08/29/Android%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/08/29/Android系统安全学习（一）/</id>
    <published>2016-08-29T11:54:14.000Z</published>
    <updated>2016-10-26T13:51:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>进程：一个可执行文件的活动表现，一次生命的历练</p>
<p>进程的地址空间界限，虚拟内存0到4g（32位）,物理内存实际就0到1g</p>
<p>3到4g是内核态，所有进程共享，0到3g是进程的私有空间</p>
<p>这种边界围栏可以防止某一个进程的Crash不会扩延到其他的进程</p>
<p>操作系统的内核Crash，那么整个系统Crash，如果是用户态的普通Crash，不会导致其他的进程Crash</p>
<p>旧时代的塞班系统，单进程多任务，一个app gg那么整个手机gg</p>
<p>一个应用是无法访问另一个应用的数据存储地址</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>多用户目录：每个用户都有自己的HOME，独立的工作目录</p>
<p>用户的访问和操作资源的权限，权限管理</p>
<p>UID GID，16进制整形值，他们才是进程的特征标志，UserId, GroupId</p>
<p>用户是静态表现，进程才是用户的动态表现</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>文件是一种资源，，在Linux里面，一切皆是资源</p>
<p>通过UID来描述文件的Target人群，UID属于GID，如果文件的Target是多个用户，那么就是通过GID来限定权限</p>
<p>root是超级用户，UID＝0，可以做任何事情</p>
<p>PID，进程运行的ID，每次可能不同，GIDs进程所属的全部GID</p>
<p>android的root UID是0，AID_SYSTEM的UID是1000，后面的系统进程只能在1000的基础上累加</p>
<p>android的AID<em>APP的UID是10000，所有的开发应用进程的userId只能在10000的基础上累加，并且UID是通过100xx减去10000，再在这个数字前面加上APP</em>，APP_XX</p>
<p>以上都是宏定义的，name和UID的连接关系是通过一个map来做的</p>
<p>应用的GIDs里面立邦会有一些系统进程的ID，其实就是表明了这些应用的权限</p>
<p>chmod是用来更改权限，r,w,x分别占用一个bit</p>
<p>chown是用来修改文件UID和GID的</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>UID分很多种，Real UID用来表明身份，Effective UID用来表示权利的标示，文件对进程的权限访问就是通过Effective UID来进行判断的</p>
<p>EffectiveUID = root，那么这个进程就是“皇权”进程</p>
<p>UID世袭遵循，身份UID世袭，权利UID不世袭</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>平民身份需要root权限</p>
<p>如果可执行文件设置了setUID标志的话，那么在执行这个文件的时候，子进程的Effective UID就不会在去和父进程的Real UID一样，而是会被提升到可执行文件的owner UID（root等）,但是这样之后，自己是否要为自己正身是很关键的问题，一旦正身，自己的子进程将都是root进程</p>
<p>setUID包含了x这个标志位，占用了x的位置，叫s</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>Capability：与UID相比，细粒度的权限管理，解决权限过剩的问题</p>
<p>UID粒度大的列子：一个进程只需要一个root的某一个权限，却获得了所有的root的权限。</p>
<p>”我们不仅需要皇帝，还需要地方官“</p>
<p>进程的：</p>
<p>Permitted Capability Sets：这个进程最大的权利范围，围栏</p>
<p>Effective Capability Sets：这个进程实际使用的权利集合</p>
<p>Inheritable Capability Sets：这个进程唯一可以直接继承的权限</p>
<p> Capability BoundSet：Init进程的这个参数默认全部为1，可以被子进程继承</p>
<p>文件的：</p>
<p>Permitted Capability Sets：该可执行文件可以为其进程带来的Per Ca Sets</p>
<p>Effective Capability Sets：该执行文件running所在的进程的Per Ca Stes是否全部添加到Effective Ca Sets，只可能会是两个值，Disable和Able</p>
<p>Inheritable Capability Sets：与可执行文件所running的进程的父进程的Inher Ca Sets进行位与运算，然后共同决定子进程Per Ca Sets</p>
<p>计算公式：</p>
<p>P’(permitted) = (p(inheritable) &amp; F(inheritable)) | (F(permotted) &amp; cap_bset)</p>
<p>P’(effective) = F(effective) ? P’(permitted) : 0</p>
<p>P’(inheritable) ＝ P(inheritable)</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>SELinux对于安全性控制的两种模式：</p>
<p>DAC：传统的安全管理模式，主体（进程）对它所属的对象和运行的程序有全部的控制权，这样一旦病毒程序获得了root，那么病毒将可以为所欲为</p>
<p>MAC：SELinux基于的安全策略，管理员来控制访问，用户无法改变，默认情况下应用程序和用户程序没有任何的权限，权限都被管理员规定好了</p>
<p>SEAndroid：将原本运行在Linux系统上的SELinux移植到Android平台，添加了对于Binder IPC, Socket, Properties的访问控制加入到了SEAndroid。目的：即使恶意应用篡夺到了root权限，但是恶意应用仍然会被控制着</p>
<p>自签名：证书的签名者和拥有者都是一个人，可以作为证书链的根证书，</p>
<p>证书链：可以回溯到根证书</p>
<p>权限只会给手机可信任的应用</p>
<p>权限的完整性保护：通过认证并获得签名再加policy权限，将所有的manifist…resource这些文件打包保护起来，所以签名之后，不可能再去偷偷的添加权限</p>
<p>权限的授权安全策略：一般的权限，一般的签名可以通过授权，但是特权的权限，只有通过系统内置的私钥签名才能通过授权，所以一般的应用是拿不到特权权限的</p>
<p>Shared Process UID：</p>
<p>android:sharedUserId=”xxxx”</p>
<p>sharedUID相同就可以共享资源，应用进程的UID相同不能共享数据，只能sharedUID相同才行，这样做的话，相当于同一个开发商或者合作的开发商才会使多个app拥有相同的shareUID，也是在manifist里面注明sharedUID</p>
<p>Android签名：</p>
<ul>
<li><p>完整性鉴别：验证apk的完整性（自签名）</p>
</li>
<li><p>自签名只能表明自己的身份，但是不能表明身份是否可信任</p>
</li>
<li><p>安卓应用的区分标志是Package Name，如果Package Name相同的话，就是进行升级操作，但是升级的要求就是必须签名相同，防止恶意软件冒充其他应用的包名，如果不一致的话，就会先卸载之前的应用，然后再安装新的应用，正常的升级不会删除旧的数据。</p>
</li>
<li><p>apk里面的META INF文件夹就是与签名有关的东西</p>
</li>
</ul>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>安卓权限类别：</p>
<ul>
<li><p>Normal，如果不定义protectionLevel的话，默认就是Normal</p>
</li>
<li><p>Dangerous</p>
</li>
<li><p>Signature：特权权限，必须被用开发厂商私钥加密的签名的apk才允许使用</p>
</li>
<li><p>SignatureOrSystem，必须被用开发厂商和系统私钥加密的签名的aok才允许使用</p>
</li>
</ul>
<p>如果是安卓层级特有的service所提供的服务，那么这样的权限申请将会在Android Framework层进行check out（一个IPC的调用），如果是非安卓特有的服务权限，比如网络请求，文件访问，这些Linux可能就提供了，那么可以通过多个入口进行访问，比如用java的api进行文件读写，而这些权限的check out都是在OS层面统一控制，因此我们需要将这些的权限 mapping到os的GID上。（所有的安卓内置的权限都在framework/base/core/res/mainfest.xml里面定义）</p>
<p>为什么你在应用的mainfest里面定义了读写文件的权限，就可以去访问了呢？：</p>
<p>安卓SD Card文件里面的文件，UID为system的权限为空，GID为Sdcard_rw的权限为rex，others的权限为r－x。所以这个应用进程要想读写scared的话，就必须将自己的GIDs里面添加一个Sdacrd_rw，而manifest里面添加的那个权限申请，最后就会将这个权限和Sdcard_rw映射在一起，并且给添加到这个应用进程的GIDs里面</p>
<p>platform.xml文件定义了一些内置的mapping关系，但是这个文件的更改权限own和group都是root，所以是不能被应用随意篡改的</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>四大组件：呈现层</p>
<p>activity：相当于是将你的ui(view)，通过一个一个的逻辑块分割开，变成一个一个的具有逻辑的页面</p>
<p>组件的Public和Private：组件如果public，那么这个组件可以和其他的进程的组件进行通信，如果组件是private的话，那么这个组件只能和自己进程的组件或者和其他应用里面sharedUID相同的组件进行通信。通过android:expored这个字段来控制组件的public和private，如果不声明的话，就是default值。</p>
<p>default值的理解：如果组件内部通过显示或者隐示的拥有IntentFilter的话，default值就是True，这样其他进程的应用的组件可以通过包名类名来（或者通过一个action等）与这个组件进行通信，如果不拥有IntentFilter的话，那么default值就是False</p>
<p>如果一个组件是public，但是控制某些人才能启动这个组件，那么就需要在manifest的组件里面声明一个permission，这个permission你自己可以在manifest里面定义，那么其他的应用必须要申请了这个permission才可能会被允许和这个组件进行通信。在service安全中，如果你希望不关关是控制是否能够boun or start这个service而是可以进一步的控制能否调用这个service中的某些功能，那么应该及时的调用checkCallingPermission()这个方法，进行细粒度的检查。在ContentProvider安全里面，一般来说他会提供read和wirte两个功能，所以说，exported可以控制你是否能连接到他，如果要进行下一步的操作，必须要申请有他声明在组件里面的readPermission和writePerrimission两个权限，根据你所需要的功能来进行申请。BroadcastReceiver也是一样的道理，可以声明一个权限</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>应用的安装要对用户可知可控，一定要呈现一个view去给用户控制</p>
<p>所以一个应用要去安装其他应用，就必要委派给系统的Install App去负责通知用户，如果用户选择了确认安装，那么会进一步调用Install Package这个系统应用去安装，，并且这个应用拥有INSTALL_PACKAGE这个signature|system等级的权限，也就是说，手机只能是通过Install Package这个应用来安装app。在安装的过程中，就会给应用的applicationinfo.uid赋值，会创建工作目录，并且这个工作目录要和uid,gid对应起来，保证私有的读写权限</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>首先，所有的调用系统远程服务都是通过Binder进行一次远程调用，而在远程的Binder线程池里面，可以调用getCallingUid()方法，这个方法将获得客户端的进程UID，这个UID将会被用于更高级别的系统服务权限识别（就是看你的应用注册权限没有，没有就蹦掉）</p>
<p>还有，服务端的服务将会通过Binder运行时的注册到ServiceManager里面，这时，ServiceManager将会检查这个系统服务的UID，来判断是否是可以被注册的服务</p>
<p> ActivityThread-&gt;ActivityManagerService-&gt;请求Zygote fork子进程-&gt;返回到ActivityThread</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程：一个可执行文件的活动表现，一次生命的历练&lt;/p&gt;
&lt;p&gt;进程的地址空间界限，虚拟内存0到4g（32位）,物理内存实际就0到1g&lt;/p&gt;
&lt;p&gt;3到4g是内核态，所有进程共享，0到3g是进程的私有空间&lt;/p&gt;
&lt;p&gt;这种边界围栏可以防止某一个进程的Crash不会扩延到其
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>利用redis构建多消费者请求队列</title>
    <link href="http://yoursite.com/2016/08/26/%E5%88%A9%E7%94%A8redis%E6%9E%84%E5%BB%BA%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2016/08/26/利用redis构建多消费者请求队列/</id>
    <published>2016-08-26T14:40:16.000Z</published>
    <updated>2016-10-26T13:53:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原文：http://peiqiang-net/2014/12/31/python-simple-queue-redis-queue-html">原文：<a href="http://peiqiang.net/2014/12/31/python-simple-queue-redis-queue.html" target="_blank" rel="external">http://peiqiang.net/2014/12/31/python-simple-queue-redis-queue.html</a></h3><h2 id="前言">前言</h2><p>​ 最近在捣腾爬虫，用python去爬取知乎的用户信息，项目地址：<a href="https://github.com/Zane96/Script_Set/tree/master/ZHIHU_Crawler" target="_blank" rel="external">ZHIHU_Crawler</a>（Mongodb+requests+xpath+redis）。由于是年轻的python司机，开始用进程池进行爬取遇到了很多无法解决的问题。后来看到了这篇文章，利用redis的数据存储结构构建一个简单的请求队列，完整地说是一个多消费者请求阻塞队列。这个思想跟Android诸多图片请求库的思想都是相同的，只不过Android多是用Java的并发Api实现（通过Future＋BlockingQueue，我的想法以后是这样去构建），本人上学期也正想自己去造个重复的轮子，但是半路看《Java并发编程》看的有点懵逼，不过下学期一定会补起来。<a href="https://github.com/Zane96/EasyImageProvider" target="_blank" rel="external">EasyImageProvider</a>。<strong>（Zane写）</strong></p>
<h2 id="文章">文章</h2><p>​ 本文展示了如何使用<a href="http://redis.io/" target="_blank" rel="external">redis</a>构建一个简单的多生产者，多消费者队列并且提供类似python标准库<a href="http://docs.python.org/library/queue.html" target="_blank" rel="external">queue</a>一样的接口。你可以使用这个队列方便的从多个进程或者耗时的计算到多个消费者进程之间共享数据。</p>
<p>​ 我们使用redis<a href="http://redis.io/topics/data-types#lists" target="_blank" rel="external">列表</a>来保存数据。redis列表按照字符串插入的顺序保存数据。</p>
<p>​ 下面的redis命令会被用到：</p>
<ul>
<li><a href="http://redis.io/commands/rpush" target="_blank" rel="external">rpush</a> 在列表的末尾插入一个元素</li>
<li><a href="http://redis.io/commands/blpop" target="_blank" rel="external">blpop</a> 从列表开头获取一个元素，如果列表是空则阻塞</li>
<li><a href="http://redis.io/commands/lpop" target="_blank" rel="external">lpop</a> 从列表开头获取一个元素，如果列表是空则返回空</li>
<li><a href="http://redis.io/commands/llen" target="_blank" rel="external">llen</a> 返回列表的长度</li>
</ul>
<p>实现过程使用了<a href="https://github.com/andymccurdy/redis-py" target="_blank" rel="external">redis-py</a>库和服务器进行交互:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisQueue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Simple Queue with Redis Backend"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, namespace=<span class="string">'queue'</span>, **redis_kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""The default connection parameters are: host='localhost', port=6379, db=0"""</span></span><br><span class="line">        self.__db= redis.Redis(**redis_kwargs)</span><br><span class="line">        self.key = <span class="string">'%s:%s'</span> %(namespace, name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qsize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the approximate size of the queue."""</span></span><br><span class="line">        <span class="keyword">return</span> self.__db.llen(self.key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return True if the queue is empty, False otherwise."""</span></span><br><span class="line">        <span class="keyword">return</span> self.qsize() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""Put item into the queue."""</span></span><br><span class="line">        self.__db.rpush(self.key, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, block=True, timeout=None)</span>:</span></span><br><span class="line">        <span class="string">"""Remove and return an item from the queue.</span><br><span class="line"></span><br><span class="line">        If optional args block is true and timeout is None (the default), block</span><br><span class="line">        if necessary until an item is available."""</span></span><br><span class="line">        <span class="keyword">if</span> block:</span><br><span class="line">            item = self.__db.blpop(self.key, timeout=timeout)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            item = self.__db.lpop(self.key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> item:</span><br><span class="line">            item = item[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_nowait</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Equivalent to get(False)."""</span></span><br><span class="line">        <span class="keyword">return</span> self.get(<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure>
<p>​ 使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#62;&#62;&#62; from RedisQueue import RedisQueue&#10;&#62;&#62;&#62; q = RedisQueue(&#39;test&#39;)&#10;&#62;&#62;&#62; q.put(&#39;hello world&#39;)</span><br></pre></td></tr></table></figure>
<p>​ 现在我们使用redis-cli客户端查看数据库，期望的结果如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&#62; keys *&#10;1) &#34;queue:test&#34;&#10;redis 127.0.0.1:6379&#62; type queue:test&#10;list&#10;redis 127.0.0.1:6379&#62; llen queue:test&#10;(integer) 1&#10;redis 127.0.0.1:6379&#62; lrange queue:test 0 1&#10;1) &#34;hello world&#34;</span><br></pre></td></tr></table></figure>
<p>​ 我们可以使用一个不同的脚本来获取数据：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#62;&#62;&#62; from RedisQueue import RedisQueue&#10;&#62;&#62;&#62; q = RedisQueue(&#39;test&#39;)&#10;&#62;&#62;&#62; q.get()&#10;&#39;hello world&#39;</span><br></pre></td></tr></table></figure>
<p>随后的q.get()调用会一直阻塞直到某人重新向队列发送一个新的数据。</p>
<p>接下来的工作将是到队列的 编码/解码（例如<a href="http://docs.python.org/library/json.html" target="_blank" rel="external">python-json</a>），这样你就可以不受限制的发送任何字符串。</p>
<p>现在已经存在漂亮而又简单的<a href="https://github.com/richardhenry/hotqueue" target="_blank" rel="external">hotqueue</a>库，它具有像上面例子中的接口别且提供编码/解码功能。</p>
<p>其他值得提到的使用redis做后端的有:</p>
<ul>
<li><a href="http://flask.pocoo.org/snippets/73/" target="_blank" rel="external">flask-redis</a> flask里使用redis做后端的一个基本的消息队列。</li>
<li><a href="http://celeryproject.org/" target="_blank" rel="external">celery</a> 一个基于分布式消息传递的异步任务队列/工作队列。比其他类库更高级点，可以配合不同的后端工作。</li>
<li><a href="http://nvie.com/rq/" target="_blank" rel="external">rq</a> 简单的python类库作用是队列化任务并且在后端使用消费者进程处理它们。</li>
<li><a href="https://github.com/defunkt/resque" target="_blank" rel="external">resque</a> 一个使用redis做后端的ruby库，主要为了创建后台工作，把他们放到多个队列，稍后处理他们。github在使用，并且有一个漂亮的web监控页面。</li>
<li><a href="https://github.com/binarydud/pyres" target="_blank" rel="external">pyres</a> python下resque的克隆版。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原文：http://peiqiang-net/2014/12/31/python-simple-queue-redis-queue-html&quot;&gt;原文：&lt;a href=&quot;http://peiqiang.net/2014/12/31/python-simple-que
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Web缓存的分析</title>
    <link href="http://yoursite.com/2016/07/09/Web%E7%BC%93%E5%AD%98%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/07/09/Web缓存的分析/</id>
    <published>2016-07-09T06:39:36.000Z</published>
    <updated>2016-10-26T13:53:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>不论是在移动端还是前端，web缓存（Http缓存）都是很重要的一部分。在移动端，对于用户流量控制的优化，web缓存就起到了决定性的作用。最开始接触这块是在使用OkHttp的拦截器修改Http请求头进行web缓存，后来仔细研究了一下这块。而Web缓存就是客户端和服务端之间通过一种约束，通过<strong>新鲜度</strong>和<strong>校验</strong>来给客户端提供缓存资源。</p>
<h3 id="Web缓存的好处">Web缓存的好处</h3><ul>
<li>缓存可以减少手机流量的消耗</li>
<li>可以更快的响应用户的操作，提升用户体验度</li>
<li>降低资源服务器的压力，减少并发量</li>
</ul>
<h3 id="Web缓存的分类">Web缓存的分类</h3><ul>
<li><p>手机文件缓存</p>
<p>由于移动端不像前端，前端开发中浏览器都默认实现了Web缓存，所以我们可以通过请求头的控制来让浏览器自动为我们进行缓存。但是移动端没有这种默认实现Web缓存的容器，所以需要我们自己手动通过文件缓存网络请求过来的报文。Okhttp或者结合Retrofit（一样）都是可以通过OkhttpClient添加一个构造好的Cache实例，其中Cache实例我们需要指定文件路径和大小。具体可以看我这个代码<a href="https://github.com/Zane96/ICY-ClaTable" target="_blank" rel="external">Demo</a>。</p>
</li>
</ul>
<ul>
<li><p>CDN缓存（内容分发网关缓存）</p>
<p>实际上是网关缓存的一种，而网关缓存又叫反向代理缓存（提前接受客户端发来的原始请求，然后进行按需请求分配）。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。通常情况下，浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，浏览器和服务器之间的缓存机制，在这种架构下同样适用。</p>
</li>
<li><p>代理服务器缓存</p>
<p>代理服务器是一种处在客户端和服务端中间的服务器，处在两者之间的网络之中。代理服务器以共享缓存的方式保存着报文副本，可以减少客户端到原始服务器的长距离请求。自然访问同一种报文副本的用户越多，代理服务器的利用率越高，缓存的命中率也越高。</p>
</li>
<li><p>数据库缓存</p>
<p>这是后台开发的时候，缓存从数据库中查找的数据，减少数据库的并发（比如NoSQL）。</p>
</li>
</ul>
<h3 id="共有缓存和私有缓存">共有缓存和私有缓存</h3><ul>
<li>共有缓存(Cache-Control: public)：这种缓存常见的就是代理缓存，意思就是一个用户群体都可以访问这个缓存服务器，这个缓存服务器缓存了所有群体的报文缓存</li>
<li>私有缓存(Cache-Control: private)：这种缓存常见的就是文件缓存（本地缓存），只允许一个用户个体去访问。</li>
</ul>
<h3 id="Web缓存的层次结构">Web缓存的层次结构</h3><p>一般来说，安卓中的图片多级缓存和这个概念不大相同，这里的多级缓存的意思是在客户端和服务端之间部署多级缓存。常见部署如下：</p>
<ul>
<li>手机文件缓存（浏览器缓存）: <strong>一级缓存</strong></li>
<li>小型的局域网内缓存：<strong>二级缓存</strong>，小型的，代价小，容量小的缓存代理</li>
<li>大型的广域网内缓存：<strong>三级缓存</strong> ，大型的，代价高，容量大的缓存代理</li>
</ul>
<h3 id="Web缓存的流程">Web缓存的流程</h3><p>先上张图：</p>
<p><img src="/img/web.png" alt="流程"></p>
<ol>
<li>在客户端发起一次请求的时候，首先一层一层的缓存会根据算法判断缓存中是否存在文档副本，如果不存在的话就会像资源服务器或者父代理缓存服务器（上一级缓存服务器）继续请求客户端需要的资源。</li>
<li>如果资源副本存在的话就会根据资源的元数据（记录资源在缓存中保存了多长时间以及它被用了多少次）来计算资源的新鲜度，如果资源新鲜的话就直接返回给客户端。</li>
<li>如果不新鲜的话，会判断资源在缓存中的副本和在资源服务器里面的文本副本是否一致，如果一致表示资源未发生改变，那么仍然还是由缓存返回。</li>
<li>如果资源发生改变，那么由资源服务器来返回资源给客户端，并且用这份资源存入缓存中。</li>
</ol>
<p>大致流程就是这样，请求－检验－在验证，下面对于过程的细节详细说说：</p>
<h4 id="文档过期的判断">文档过期的判断</h4><p>缓存数据是否过期是由数据的使用期和过期日期共同决定的。</p>
<ul>
<li><p>过期时期(新鲜生存期)</p>
<p>过期时期可以通过Cache-Control的max-age和max-stale或者Expires来设置。其中，Cache-Control中指定的是相对时间，而Expries指定的是数据过期的绝对时间。但是资源服务器的时间经常会出现与客户端不同步的情况（我就遇到过这种坑。。）所以用相对时间更加合理，并且Cache-Control的优先级要高于Expries。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Cache-Control: max-stale = <s></s></th>
<th>在指定的秒数里面缓存可以提供过期了的数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control: max-age = <s></s></td>
<td>在指定的秒数里面，缓存里面的数据不会过期</td>
</tr>
<tr>
<td>Cache-Control: min-fresh = <s></s></td>
<td>至少在未来数秒内数据要保持新鲜</td>
</tr>
<tr>
<td>Cache-Control: private or public</td>
<td>私有缓存或者共有缓存</td>
</tr>
<tr>
<td>Cache-Control: no-cache</td>
<td>提供数据之前必去要去和资源服务器的数据进行比对判断数据是否更新</td>
</tr>
<tr>
<td>Cache-Control: no-store</td>
<td>禁止一切缓存</td>
</tr>
<tr>
<td>Cache-Control: must-revalidate</td>
<td>告诉缓存，必须严格遵循服务器的规定，验证之后才能提供过期的数据</td>
</tr>
<tr>
<td>Cache-Contero: only-if-cached</td>
<td>只有当缓存中有副本的时候，客户端才能获取一份数据副本</td>
</tr>
</tbody>
</table>
<p>需要注意的是</p>
<ol>
<li><strong>no-cache</strong> 不是不使用缓存而是必须比对了之后才能提供，no-store才是完全禁止缓存</li>
<li>优先级：no-staore&gt;no-cache&gt;must-revalidate&gt;max-age&gt;Exprise</li>
</ol>
<p>在移动端的开发中，如何控制我们的数据缓存过期时间需要移动端和后台共同商量之后得出一套方案，比如像数据不停变换更新的并且数据量不大的，应该禁用缓存以保证数据的及时性，像周刊，课表这种长期不变的数据应该添加上合理的缓存时间。</p>
<ul>
<li><p>使用时间</p>
<p>所谓使用时间就是数据从资源服务器发出之后，到被客户端收到，一共经历了多久。但是使用时期并不容易计算。因为服务器，代理，客户端之间时间不同步，网络延时，网络传输耗时等等都会造成使用时期难以计算。</p>
<p>1.直接通过Date首部进行计算</p>
<p>​ 这种计算方式我就被坑过，之前直接设置max-age=3600（一分钟）发现一点缓存效果都没有。我发现响应头的Date首部与现在时间不同，慢了好几天。首先要理解Date首部，<strong>Date首部是服务器发出相应的时间，并且是服务器的绝对时间，并且Date首部只能是资源服务器设置，代理和缓存都不能修改，时间的描述格式由RFC822定义</strong>，所以如果时间不同步的话，直接用客户端时间减去Date来计算使用期是行不通的。</p>
<p>2.通过Age首部进行计算</p>
<p><strong>Age首部只适用于HTTP/1.1的设备，Age表示数据从产生到现在经过了多长时间，是个相对时间</strong></p>
<p>通过Age首部，我们可以累加资源在各个代理中存在的时间，加上数据从资源服务器到缓存的网络传输时间（一般用缓存到服务器，服务器到缓存双向的传输时间来保守估计）。</p>
<p>所以我们可以看出，完整的使用时期计算应该是如下图：</p>
<p><img src="/img/web2.png" alt=""></p>
<p>可以看出其实是忽略了客户端到缓存的网络传输时间，多算了缓存到资源服务器的网络传输时间。</p>
<h3 id="再验证">再验证</h3><p>如果第一次缓存未命中的话，就会进行服务器再验证。用来判断服务器的资源是否发生改变。</p>
<h4 id="If-Modified-Since与Last-Modified（基于Date的再验证）">If-Modified-Since与Last-Modified（基于Date的再验证）</h4><p>  If-Modified-Since是请求字段，值为一个绝对时间，用于通知服务器在这个时间之前，默认资源是未被修改的（不去进行再验证），如果超过了这个时间，就会将这个时间和资源最后修改的时间进行对比，如果小于资源最后修改的时间，那么Last-Modified响应首部会返回资源最后被修改的时间，并且返回200.如果大于最后修改的时间，那么Last-Modified响应首部会返回304表示资源未被修改。</p>
<h4 id="If-None-Match和ETag（基于实体标签的再验证）">If-None-Match和ETag（基于实体标签的再验证）</h4><p>  ETag可以看作是资源的版本号，并且在强验证器下，资源发生细微的变化都会导致ETag的变化，在弱验证器下，资源发生细微的变化都不会导致ETag的变化，这个“细微”度量标准是由后台开发人员来确定的。客户端可以根据If-Modified-Since来添加你现在所拥有的ETag版本号，发送给服务器，然后服务器进行比较。如果版本号不同，那么就会返回200，并且将最新的ETag值添加到ETag响应头里面。如果相同，返回304。<br>  两者之间并没有优先级之分，如果同时存在，那么客户端和服务端应该将两者综合起来考量。</p>
</li>
</ul>
<p><strong>未经博主同意，不得转载该篇文章</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;不论是在移动端还是前端，web缓存（Http缓存）都是很重要的一部分。在移动端，对于用户流量控制的优化，web缓存就起到了决定性的作用。最开始接触这块是在使用OkHttp的拦截器修改Http请求头进行web缓存，后来仔细研究了一下这块。
    
    </summary>
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>《深入理解jvm》读书笔记——类加载机制</title>
    <link href="http://yoursite.com/2016/05/28/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2016/05/28/《深入理解jvm》读书笔记——类加载机制/</id>
    <published>2016-05-28T13:46:26.000Z</published>
    <updated>2016-10-26T13:53:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>​ 我们的java文件在编译的过程中会从.java文件转变为.class文件，.class文件是一串二进制流。而类加载过程就是将编译好的.class文件加载到虚拟机内存中，并对数据进行效验，转换解析和初始化，最终可以形成虚拟机直接使用的java类型。</p>
<h2 id="动态性">动态性</h2><p>​ Java是一门强类型，静态类型的语言。但是Java的动态类加载机制成就了Java的动态性的特点，虽然类型的加载，连接和初始化过程都是在程序运行期间完成的，会造成一定的性能消耗，但是Java的动态性带来的灵活性却是很重要的一部分。比如面向接口编程，反射等等。</p>
<h2 id="何时开始加载">何时开始加载</h2><p> <img src="/img/classloader_1.png" alt="classloader_1"></p>
<p>​ 其中 <strong>验证，准备，解析</strong> 称为连接状态。</p>
<p>​ 开始类加载的时间点分为以下几个触发点：</p>
<ol>
<li><p>虚拟机遇到<strong>new, getstatic,putstatic,invokestatic</strong></p>
<p>以上分别对应<strong>实例化一个对象， 读取或者设置一个类的静态变量（常量除外），调用类的一个静态变量</strong></p>
</li>
<li><p>进行反射（reflect）操作</p>
</li>
<li><p>当初始化一个类的时候，如果发现她的父类还没有被初始化，会先加载它的父类（这就是为什么父类的static代码块会先执行的原因）</p>
</li>
<li><p>虚拟机会首先加载程序的入口（main），安卓中即是ActivityThread的main方法是安卓程序的入口</p>
</li>
<li><p>使用Java1.7加入的MethodHandle的时候解析获得REF_getStatic, REF_putStatic, REF_invokeStatic句柄的时候<strong>关于这个我之前没有了解过，大概是1.7引进的一种类似Reflect中的Method的类，用来方便的反射调用方法的工具</strong></p>
</li>
</ol>
<p>以上的5个条件，如果满足其中的一个条件就会触发类加载。</p>
<p>但是有几种特殊的被动引用的情况不会触发类加载</p>
<ul>
<li><strong>只有直接定义这个字段的类才会被加载，所以子类中调用父类中定义的静态字段不会触发子类的类加载</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> Value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">  staic&#123;</span><br><span class="line">    System.out.println(<span class="string">"Subclass init!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(SubClass.Value + <span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">  SuperClass init!</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>初始化以某个类的实例作为数组元素的数组，不会出发这个类的类加载</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] orgs)</span></span>&#123;</span><br><span class="line">      SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果为空。</span><br></pre></td></tr></table></figure>
<p>​ 虚拟机会加载一个数组类型的类。这个类控制了这个数组的所有操作和属性（length, clone等），这样可以保证开发者在操作的过程中的安全性。比如数组越界等等。</p>
<ul>
<li><strong>调用一个类的常量不会触发这个类的类加载</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantClass</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"ConstantClass init!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] orgs)</span></span>&#123;</span><br><span class="line">      System.out.println(ConstantClass.Value + <span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">  <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>​ 这是因为常量在编译的阶段，就会将被调用类的常量存入调用类的常量池中，所以运行时调用的常量都是自己类里面常量池的常量。</p>
<h2 id="类加载过程">类加载过程</h2><h3 id="加载">加载</h3><ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流（可以是class文件，可以是jar包等等）</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表着歌类的class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>加载阶段完成了之后，二进制字节流就按照虚拟机所需求的格式存储在方法区里面，然后初始化一个class实例，并且这个实例是放在方法区而不是java堆里面，然后这个实例是用来作为方法区里面数据的访问入口的。</p>
<h3 id="验证">验证</h3><p>​ 验证加载进来的二进制字节流中包含的信息的安全性。防止加入了对系统有害的字节流而导致系统的崩溃。</p>
<p>1.<strong>文件格式验证</strong></p>
<p>验证class文件格式，并且是否能被当前的版本的虚拟机吃力</p>
<ul>
<li>检查class文件的魔数开头是否符合正确的格式（OxCAFEBABE）</li>
<li>主次版本号是否能被虚拟机处理</li>
<li>常量池里面是否有不能被支持的常量类型</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
</ul>
<p>​ 等等。。</p>
<p>经过这一步的验证之后，字节流才能被存储到内存的方法区里面，只有这一步的验证是基于字节流的检验，而后面的操作都是对方法区存储结构的检验。</p>
<p><strong>这里需要知道的是，上图中显示的执行顺序不是固定死的，也就是说开始时间是固定了的，但是不是必须加载过程完毕了之后才能开始后续的工作，而是开始了之后，连接过程和其他操作交叉进行</strong></p>
<p>2.<strong>元数据验证</strong></p>
<p>第二阶段是对直接吗描述的信息进行语义分析，以保证描述的信息符合java的语言规范</p>
<ul>
<li>这个类是否有父类（object除外）</li>
<li>这个类是否继承了被final修饰了的类</li>
<li>如果这个类继承了接口或者抽象类，是否实现了所有的抽象方法</li>
<li>类中的字段或者方法签名是否与父类矛盾</li>
</ul>
<p>3.字节码验证</p>
<p>这个阶段是通过数据流河控制流分析程序的语义，逻辑是否安全，是否不会破坏系统。</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体的类型转换有效（比如父类实例不能赋给子类引用等）</li>
</ul>
<p>4.符号引用验证</p>
<p>这段验证发生在解析操作中（将符号引用转变为直接引用），对类自身以外的信息进行匹配性验证</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>
<li>在指定的类中是否存在符合方法的字段描述以及简单名称所描述的方法和字段</li>
<li>符号引用中的类，字段，方法的访问性是否合理（private, protected..）</li>
</ul>
<hr>
<p>不过现在的IDE已经能帮助我们避免很多上面可能会出现的问题了～</p>
<h2 id="准备">准备</h2><p>在这个阶段开始正式为类变量（只包括静态变量不包括实例变量）分配内存并设置类变量初始值（0值）</p>
<h3 id="零值">零值</h3><p>0值的意思就是一个静态变量在经过准备阶段之后会被赋给0而不是原值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">2333</span>;</span><br></pre></td></tr></table></figure>
<p>在经过准备阶段之后，value的值是0而不是2333，而2333这个值会随着putstatic指令存放到类构造器（区分构造器和类构造器，后面具体说）中，然后初始化阶段才会把2333赋值给他。如果是常量的话，会直接在准备阶段赋原值。</p>
<p>以下是集中基本类型的零值：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">零值</th>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">零值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">0</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">0L</td>
<td style="text-align:center">float</td>
<td style="text-align:center">0.0f</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">(short)0</td>
<td style="text-align:center">double</td>
<td style="text-align:center">0.0d</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">‘\u0000’</td>
<td style="text-align:center">refrence</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">(byte)o</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="解析">解析</h2><p>解析就是虚拟机将符号引用转换替换成直接引用的过程。</p>
<ul>
<li>符号引用：</li>
</ul>
<p>符号引用通过一组符号来描述所引用的目标，符号引用可以是任何形式的字面量。</p>
<ul>
<li>直接引用</li>
</ul>
<p>直接指向指定目标的“指针”，相对偏移量或者一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存分布相关，所以同一个符号引用在不同的虚拟机上面翻译出来的直接引用一般都不会相同。如果直接引用已经生成了，那么对象也已经在java堆中存在了。</p>
<blockquote>
<p>一个符号引用被解析一次之后后面可能还会被多次解析，而虚拟机不会重新再解析而是通过缓存去拿出解析的数据，但是invokedynamic指令除外，它会每次被解析都会被重新解析（动态性）</p>
</blockquote>
<p>解析主要针对类，接口，字段，类方法，接口方法，方法类型，方法句柄和调用点限定符7类符号引用进行</p>
<h2 id="初始化">初始化</h2><p>前面的几个过程中，加载是通过类加载器完成，其余都是通过虚拟机主导完成，而初始化就开始真正执行Java程序代码了。可以认为初始化过程就是执行类构造器（<clinit>()）的过程.</clinit></p>
<ul>
<li>类构造器：<ul>
<li><clinit>()是由编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而成的，收集的顺序是按语句在源文件里面出现的顺序所决定的。<strong>解释了为什么静态代码块不能访问定义在自己后面的静态变量</strong></clinit></li>
<li><clinit>()方法在执行之前必须保证自己父类的类构造器方法已经执行完了。所以Object的类构造器永远是最先执行的。<strong>解释了为什么父类的静态代码块会比子类的静态代码块先执行</strong></clinit></li>
<li>一个类或者接口不是必须要有类构造器的（但是必须要有构造器），如果一个类里面没有静态代码块或者类变量，那么不会生成类构造器方法</li>
<li>接口虽然没有静态代码块，但是仍然有成员变量的定义，并且都是常量，所以如果接口定义了成员变量，就一定会生成<clinit>()方法。<strong>但是接口初始化的时候，不会要求自己的父类的类构造器也被执行，同时接口的实现类在初始化的时候也不会先要求执行接口的类构造器方法</strong></clinit></li>
<li><clinit>()是线程同步的，在多线程的情况下，虚拟机会自动的加锁，所以多线程的情况下，如果类构造器方法做了耗时很长的操作，就会造成多线程的阻塞。</clinit></li>
</ul>
</li>
</ul>
<h2 id="类加载器ClassLoader">类加载器ClassLoader</h2><p>类加载器是一个很重要的部分，他并不是一个机器，而不是一个通过类全限定名去获取描述此类的二进制字节流的代码块。这个过程放在虚拟机之外，做到功能上的解耦。目的就是希望用户可以自定义如何将二进制字节流加载进来。<strong>这也体现虚拟机开发团队对于扩展性的看重程度</strong></p>
<h3 id="类与类加载器的关系">类与类加载器的关系</h3><blockquote>
<p>类加载器决定了类的唯一性.</p>
</blockquote>
<p>比如工程里面有一个类A，运行之后系统默认的类加载器会加载一次这个类，如果我们在代码中自定义一个类加载器去再加载一次这个类，那么相当于现在工程里面有了两个类A，后面那个类A的实例化对象instanceof系统类加载器加载的类A，结果肯定会返回false。</p>
<h3 id="双亲委派模型">双亲委派模型</h3><blockquote>
<p>先看所有类加载器的父加载器能不能加载，如果不能加载才会返回给低层的类加载器去加载</p>
</blockquote>
<p>有点类似Android中的view绘制和消息传递机制，不同的是消息机制里面viewgroup先将event传递到view视图底层，如果所有的底层视图都对event不感兴趣才会返回到viewgroup的onTouchEvent和onTouch中。</p>
<p>之前说了，一个全限定名的类如果被一个类加载器加载了之后才会称为同一个类。之所以虚拟机团队要设计这样的模式，就是因为防止这种类型错误的问题。比如Object类是默认被系统的最顶层类加载器加载的，所以所有的程序里面Object都是相同类型的，不会出现Object被其他类加载器加载然后导致Object类型错误的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;&lt;p&gt;​ 我们的java文件在编译的过程中会从.java文件转变为.class文件，.class文件是一串二进制流。而类加载过程就是将编译好的.class文件加载到虚拟机内存中，并对数据进行效验，转换解析和初始化，最终可以形成虚拟机直接使用的
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>《深入理解jvm》读书笔记——垃圾回收以及内存分配</title>
    <link href="http://yoursite.com/2016/05/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://yoursite.com/2016/05/24/《深入理解jvm》读书笔记——垃圾回收以及内存分配/</id>
    <published>2016-05-24T14:34:40.000Z</published>
    <updated>2016-10-26T13:53:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><ul>
<li>JVM的垃圾回收主要发生在java堆，因为线程的私有内存（程序计数器， 虚拟机栈， 本地方法栈）会随着线程的销毁而释放内存，并且栈的内存大小在运行之前就已经根据类结构确定了内存的大小。java堆和方法区（常量池比较特殊）和上面的就不同了，一个接口总的多个实现类需要的内存可能不同，一个方法中的多个分支需要的内存也可能不一样，我们只能在程序运行的时候才知道要去创建哪些对象。</li>
</ul>
<h2 id="对象生命">对象生命</h2><ul>
<li>引用计数算法：给每一个对象添加一个引用计数器，每当有一个引用指向它的时候，他的引用计数器就加一，引用失效就减一。但是无法解决对象相互引用的问题。</li>
<li>可达分析算法（主流）：通过一系列称为”GC Root”的对象作为起点，从这些起点往下进行搜索，搜索走的路经叫做引用链，当一个对象到GC Root没有任何引用链相连的话，就说这个对象是不可达的对象，判定为可以回收的对象</li>
</ul>
<p>​ 可以作为Gc Root对象的种类：</p>
<p>​ 1. 虚拟机栈中引用的对象</p>
<p>​ 2. 方法区中类静态变量引用的对象</p>
<p>​ 3. 方法区中常量引用的对象</p>
<p>​ 4. 本地方法栈中JNI引用的对象</p>
<h2 id="方法区的垃圾回收">方法区的垃圾回收</h2><p>​ 方法区属于jvm中的永久代，也是存在一定的垃圾回收的，但是完全是可以不要求拥有垃圾回收的。</p>
<ul>
<li><p>回收内容：废弃常量和无用的类</p>
<p>无用类的条件：</p>
<ol>
<li>该类所有的实例都已经被回收，也就是java堆中不存在该对象的实例</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的class对象没有在任何地方被引用，没有在其他地方通过反射访问该类的信息</li>
</ol>
</li>
</ul>
<h2 id="垃圾回收算法">垃圾回收算法</h2><ol>
<li>标记清除算法：先根据对象是否已死来标记可以清楚的对象，然后清除。分为两个步骤，但是会产生大量的空间碎片（如果后面的对象需要的连续空间特别大无法满足，就会发生一次Minor gc），效率不高</li>
<li>复制算法：将java堆内存平分为二。当一个部分的对象清除了之后，将剩余的对象按顺序移动到另一块空间里面去，空间将会缩减一半，代价很高，但是不会造成空间碎片。但是现在也一半不是对半分空间，而是8.：1分为（一个Eden, 两个Survivor），Eden和一个Survivor用来收纳新的对象，剩下的一个Survivor用来收纳清除了一遍之后的对象，如果内存空间不够了会去找老年代借空间。</li>
<li>标记整理算法：先是标记，然后移动可以存活的对象顺序排列，这样再清楚可以减少空间碎片的产生。</li>
<li>分代收集算法（主流）：根据对象存活的周期分为年轻代和老年代，然后再年轻代和老年代分别采用不同的垃圾回收算法（比如年轻代用复制算法，老年代用标记整理活着标记清除算法）</li>
</ol>
<h2 id="GC的入口选择">GC的入口选择</h2><p>​ 什么时候开始gc?</p>
<ul>
<li>OopMap：jvm通过OopMap这个数据结构在gc进行时快速得到对象的内存地址</li>
<li>SafePoint：程序到了安全点才会进入垃圾回收，安全点太多，运行的负荷会更大，太少会让gc等待时间太长。所以安全点的选择都是以程序“是否具有让程序长时间执行的特征”为标准进行选定的（比如方法调用，循环跳转，异常跳转等会产生安全点）</li>
</ul>
<p>​ 有时候程序到了安全点，但是线程还在运行，并且没到安全点，一半采用主动中断的方法：给所有的安全点设置一个标志，然后线程运行的时候去不停的询问这个安全点，一旦为真线程就把自己中断。</p>
<ul>
<li>SafeRegion：如果现在有线程在程序到达安全点的时候正在sleep或者blocked状态，那么如何保证线程不会在gc结束之前不运行起来？如果线程执行到安全区域那么就不用管gc是否进行，只需要在离开安全区域的时候询问gc是否结束就可以了，如果还没有结束那么就阻塞自己一直到gc结束。</li>
</ul>
<h2 id="内存分配与回收策略">内存分配与回收策略</h2><p>​ 策略不唯一，会根据参数设置和采用的垃圾回收器组合来动态的确定。</p>
<p>​ 基本的策略：</p>
<ul>
<li><p>对象优先在Eden分配</p>
<p>大多数情况下，对象都会在新生代中分配内存，当Eden中没有足够的内存的时候jvm会发生一次Minor GC</p>
</li>
<li><p>大对象直接进入老年代</p>
<p>大对象指的是需要大量连续空间的Java对象，比如长度很长的字符串和数组。所以我们应该避免写大量“朝生夕灭”的大对象。</p>
</li>
<li><p>长期存活的对象将进入老年代</p>
</li>
</ul>
<p>​ 虚拟机给每一个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活就会被放倒Survivor里面，并且对象年龄增加1，并且每熬过一次就增加1，默认到了15之后就会被移动到老年代里面去</p>
<ul>
<li>动态对象年龄判定</li>
</ul>
<p>​ 虚拟机不会永远要求对象年龄到了最大年龄阀值才会让你进入老年代。如果在Survivor空间中相同的年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代了，这是为了节省Survivor的空间。</p>
<ul>
<li>空间分配担保</li>
</ul>
<p>​ 在年轻代发生Minor GC之前，虚拟机会先检查老年代最大的连续空间是否大于新生代里面所有对象的总和，如果成立那么刻意确保Minor GC是安全的。如果不成立就看能否允许担保失败的参数设置，如果是允许的话，就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就进行Minor GC，如果在这里担保失败的话，就会在老年代进行一次Full GC，如果小于或者不允许担保失败，那么就在老年代进行一次Full GC</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JVM的垃圾回收主要发生在java堆，因为线程的私有内存（程序计数器， 虚拟机栈， 本地方法栈）会随着线程的销毁而释放内存，并且栈的内存大小在运行之前就已经根据类结构确定了内存的大小。java堆和方法区（常量池比较特殊）和上
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>关于Activity的工作原理</title>
    <link href="http://yoursite.com/2016/04/23/%E5%85%B3%E4%BA%8EActivity%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2016/04/23/关于Activity的工作原理/</id>
    <published>2016-04-22T16:13:16.000Z</published>
    <updated>2016-10-26T13:53:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>​ 我还记得上个学期意外看到一篇文章，是凯子哥的一篇博客，讲的是app第一个activity启动的底层过程(java)，我当时几乎没接触过这块的源码，好像看了一半就放弃。还有一次刷知乎，看到一个人回答为什么ActivityThread里面Loop不会造成ANR，但是也是一脸萌比。这个学期开始刷艺术探索，已经看完了第十章，每一章都对着源码自己又看了一遍，再加上之前对Binder,IPC的浅显的研究。今天重新再来看这篇文章[<a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287" target="_blank" rel="external">【凯子哥带你学Framework】Activity启动过程全解析</a>]，发现基本上是看小说一样的轻松看完了。。这是一种进步！！感觉挺好的。感谢大神的知识分享，下面我用自己的方式来总结一下Activity启动的过程，但是我跟凯子哥不同，他讲的那个其实就多了一点Launcher和applicaiton创建的知识。</p>
<p>​ 说一点自己的学习感受。首先：</p>
<ul>
<li>源码海洋里面不要太追求了解每一个细节，不然分分钟迷失自我。</li>
</ul>
<ul>
<li>有些知识是需要有其他知识储备才能理解的。所以看不懂的时候放一放，过一段时间再来看。比如binder设计原理那块我就留了一半。。因为后半部分有点看不太懂了，涉及到了C草。</li>
</ul>
<ul>
<li>看书上的源码远远不够，一定一定要自己去独立的看一遍，自己去把整个流程过一遍。</li>
</ul>
<ul>
<li>画草图，流程图。因为过程异常的复杂，在不同的类里面调来调用，又臭又长的调用链。</li>
</ul>
<ul>
<li>永远不要放弃，静下心来研究，一切都不是问题。</li>
</ul>
<h3 id="知识储备">知识储备</h3><ol>
<li><p><strong>Binder</strong>, <strong>IPC机制</strong>。可以看看我之前的两篇文章<a href="http://zane96.github.io/2016/03/19/Android-IPC%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">Android-IPC系列（一）</a><a href="http://zane96.github.io/2016/04/06/Android-IPC%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="external">Android-IPC系列（二）</a> 。还有几篇我觉得写的非常好的文章<a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Android Binder设计与实现 - 设计篇</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="external">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a> 。（这两篇讲的都比较深）看到艺术探索后面我终于知道为什么binder要在第二章就讲解了。因为Binder在后面几乎是无处不在！</p>
</li>
<li><p><strong>ActivityManagerService</strong>。本质就是一个Binder，并且实体在服务端。AMS在远端操作着activity的生命周期。这个进程由SystemServer进程fork出来。</p>
</li>
<li><p><strong>ActivityThread</strong>。大家都知道ActivityThread就是应用的UI线程，main方法就是整个应用的入口。ActivityThread本质并不是一个线程，他只是依附着主线程存在。ActivityThread通过和AMS进行IPC通信来共同管理Activity的生命周期。在后面我准备写一篇关于Handle的续篇，里面还会提到他，因为主线程里面的Looper就是在这里init的。</p>
</li>
<li><p><strong>ApplicationThread</strong>.。它是ActivityThread的内部类，本质上ActivityThread是通过它来进行和AMS的IPC通信的。它的本质也是一个Binder！只不过这次他的实体放在客户端，AMS通过他的代理类<strong>ApplicationThreadProxy</strong>来和ApplicationThread通信。</p>
</li>
</ol>
<ol>
<li><p><strong>Instrumentation</strong>.。这个类我在看完第一遍书的时候感觉操作调用链里面的最外层。因为最后一步Activity实例对象的生成和onCreat()方法的调用最终是来自这个类的。其实这个类是ActivityThread想要进行的操作的具体操作类。这个类是全局的，并且每个acitivity里面都拥有一个它的引用。</p>
</li>
<li><p><strong>ActivityStack（AMS中）</strong>。很好懂，一个activity栈。但是这个ActivityStack是有两种类型的，一种叫系统ActivityStack(HomeTask),这一类的ActivityStack包含着Launcher（或者有其他我不知道的），还有一种是普通应用的ActivityStack（安卓中Task这个概念的具体实现形式），其实就是一个Task（任务栈）。这个类是由AMS来管理，AMS通过这个数据结构来得知activity的状态。</p>
</li>
<li><p><strong>ActivityStackSuperisor（AMS中）</strong>。加了一个单词，就是activity栈的管理者。这个类的作用就是管理栈，并且通过ActivityStack来获得要启动的activity的信息。</p>
</li>
<li><p><strong>ActivityRecord</strong>。这个就是上面说的服务端的actiivty信息的载体类。并且也是服务端的类～这个类相当的重要，自始至终都贯穿在调用链里面，在安卓ActivityStack里面存储的并不是activity实例，其实就是这个ActivityRecord的实例。</p>
</li>
<li><p><strong>ActivityClientRecord</strong>。这个和上面区别就是这个类是客户端activity信息的载体类。</p>
</li>
<li><p><strong>TaskRecord</strong>。同样，这个类就是ActivityTask的信息记录类而已。</p>
<p>​好了，我觉得需要好好了解的几个最核心的类就是这几个了，大家若不清楚，可以自己去源码里面看，如果我有说错的也请原谅。。。其实还有很多概念我在binder那篇文章里面讲的不少了！这里算是又一次的补充吧。</p>
</li>
</ol>
<hr>
<h3 id="Activity启动的流程">Activity启动的流程</h3><p>​ 源码之旅开始。科科.</p>
<p>1.<strong>Activity.startActivity(Intent intent)</strong>这个我们天天都在写，好，去看源码！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Note we want to go through this call for compatibility with</span></span><br><span class="line">            <span class="comment">// applications that may have overridden the method.</span></span><br><span class="line">            startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>嗯，继续看startActivityForResult()；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">            ...省略代码</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>直接调用了Instrumentation去调用execStartActivity()方法。后面的调用先不管，直接去看execStartActivity()方法。<strong>需要注意的是mMainThread.getApplicationThread()就是通过ActivityThread去获得了一个ApplicaitonThread实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span><br><span class="line">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">            Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">        IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">        ...省略代码</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            intent.migrateExtraStreamToClipData();</span><br><span class="line">            intent.prepareToLeaveProcess();</span><br><span class="line">          <span class="comment">//通过AMS启动了</span></span><br><span class="line">            <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                        requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">          <span class="comment">//用来检测这个activity启动的结果，具体可以去查看源码</span></span><br><span class="line">            checkStartActivityResult(result, intent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看到这里发现它又用了个什么玩意调用了startActivity()方法，这是什么呢？这里的<strong>ActivityManagerNative.getDefault()</strong>就是我们期待了很久的ActivityManagerService的代理类！如果你很清楚Binder的实现，这个应该难不倒你吧！AMS和代理类本质上都是IActivityManager的实现类。（IAcitivtyManager,其实就是一个AIDL接口，不信自己去看源码）。我给你看看getDefault()方法的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service binder = "</span> + b);</span><br><span class="line">            &#125;</span><br><span class="line">            IActivityManager am = asInterface(b);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service = "</span> + am);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> am;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>就是这么简单！如果看到这里你看不懂了，建议你再回去看看Binder。接下来我们就可以继续看AMS中startActivity()方法的实现了：<strong>注意，从这里开始，调用链会变得很复杂</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span><br><span class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span><br><span class="line">            <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//调用了startActivityAsUser,caller是我们的ApplicaitonThread</span></span><br><span class="line">        <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, options,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续看这个startActivityAsUser()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span><br><span class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span><br><span class="line">            <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line">        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</span><br><span class="line">                <span class="keyword">false</span>, ALLOW_FULL_ONLY, <span class="string">"startActivity"</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.转换app里面的activity栈,caller是我们的ApplicaitonThread</span></span><br><span class="line">        <span class="keyword">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent,</span><br><span class="line">                resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">                profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, options, userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​ 发现调用了之前提到的ActivityStackSupervisor的startActivityMayWait()方法。这里的目的就是想去通过栈的管理者来通过传进来的数据去改变栈，并且拿到被启动activity的ActivityRecord实例。</p>
<p>​ 在<strong>startActivityMayWait()</strong>里面，主要做了ActivityStack， ActivityInfo, LaunchMode等等各种信息的初始化工作，然后就又调用了<strong>startActivityLocked()方法</strong>， 这个方法里面又做了一系列的变量初始化，初始启动的错误判断, uid检查之后，又调用了<strong>startActivityUncheckedLocked()</strong>方法。这个方法里面根据前面一系列的工作，确定了最终的LanuchMode，这个LaunchMode会在后面的函数被拿来进行判断,构建了一个新的intent，ActivityInfo,ActivityTask。反正过程都TM又臭又长，细看下去一天就耗完了。接下来我们可以看到最终调用<strong>targetStack.resumeTopActivityLocked()方法</strong>。这个targetStack就是新的activity所要放入的Task的位置。也就是说，现在又要转到ActivityTask中去看源码了，科科！</p>
<p>​ 注意的是，LaunchMode和ActivityStack的选择是个很复杂的过程。我推荐一篇文章以及安卓的官方文档链接。<a href="http://developer.android.com/intl/zh-cn/guide/components/tasks-and-back-stack.html" target="_blank" rel="external">官方文档</a>,<a href="www.dunwen.com">顿文的博客</a></p>
<hr>
<p>​ <strong>需要非常注意的是，这个函数执行的时候，被启动的activity里面被添加到栈里面去了，top，next就是指代这个要被启动的activity。pre,current就是指代当前resumed的activity。你别弄混了，虽然这个问题我TM看了一整天的源码。注意，被启动的activity虽然还没有被实例，但是它的ActivityRecord实例已经被构建出来了，并且已经被添加到stack里面去了。具体的调用过程是：</strong></p>
<p>​ Supervisor.setActivityUnchekedLocked-&gt;resumeTopActivityLocked（这里是ActivityStackSuperbisor里面的方法）-&gt;ActivityStack.startActivityLocked在这里将activity添加到stack里面。并且在之后才会调用ActivityStack的resumeTopActivityLocked方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Ensure that the top activity in the stack is resumed.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> prev The previously resumed activity, for when in the process</span><br><span class="line">     * of pausing; can be null to call from elsewhere.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> Returns true if something is being resumed, or false if</span><br><span class="line">     * nothing happened.</span><br><span class="line">     */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityLocked</span><span class="params">(ActivityRecord prev, Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inResumeTopActivity) &#123;</span><br><span class="line">            <span class="comment">// Don't even start recursing.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Protect against recursion.</span></span><br><span class="line">            inResumeTopActivity = <span class="keyword">true</span>;</span><br><span class="line">            result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            inResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>​ 不要有情绪，继续看<strong>resumeTopActivityInnerLocked(prev, options);</strong>这个方法太长了，我分析了一整天，终于所有体会吧。这个方法最终的作用是将启动者activity的生命周期变成paused，这样之后被启动的activity的实例创建了之后才能顺利的resumed。我们来看部分代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the first activity that is not finishing.</span></span><br><span class="line">        <span class="comment">//找出栈顶中第一个没有在被finish的activity,既我们要启动的actiivty</span></span><br><span class="line">        ActivityRecord next = topRunningActivityLocked(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remember how we'll process this pause/resume situation, and ensure</span></span><br><span class="line">        <span class="comment">// that the state is reset however we wind up proceeding.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> userLeaving = mStackSupervisor.mUserLeaving;</span><br><span class="line">        mStackSupervisor.mUserLeaving = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TaskRecord prevTask = prev != <span class="keyword">null</span> ? prev.task : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果整个stack里面是空的，那么直接启动launcher</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// There are no more activities!  Let's just start up the</span></span><br><span class="line">            <span class="comment">// Launcher...</span></span><br><span class="line">            ActivityOptions.abort(options);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG, <span class="string">"resumeTopActivityLocked: No more activities go home"</span>);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">            <span class="comment">// Only resume home if on home display</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> returnTaskType = prevTask == <span class="keyword">null</span> || !prevTask.isOverHomeStack() ?</span><br><span class="line">                    HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo();</span><br><span class="line">            <span class="comment">//直接resume系统ActivityStack里面的根activity(Launcher)</span></span><br><span class="line">            <span class="keyword">return</span> isOnHomeDisplay() &amp;&amp;</span><br><span class="line">                    mStackSupervisor.resumeHomeStackTask(returnTaskType, prev);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​ 在这里，next这个变量很关键。它的注释说的是第一个没有正在被销毁的activity，显然我们要被启动的activity符合这个条件。并且如果这个应用级别的stack是空的，也就是说现在应该跳转到系统级别的stack去，也就是显示系统桌面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the top activity is the resumed one, nothing to do.</span></span><br><span class="line">        <span class="comment">//如果被启动的activity就是当前处理Resumed状态的activity的话，就什么不做。（一个activity启动自己就是这种情况）</span></span><br><span class="line">        <span class="keyword">if</span> (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class="line">                    mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class="line">            <span class="comment">// Make sure we have executed any pending transitions, since there</span></span><br><span class="line">            <span class="comment">// should be nothing left to do at this point.</span></span><br><span class="line">            mWindowManager.executeAppTransition();</span><br><span class="line">            mNoAnimActivities.clear();</span><br><span class="line">            ActivityOptions.abort(options);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG, <span class="string">"resumeTopActivityLocked: Top activity resumed "</span> + next);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure to notify Keyguard as well if it is waiting for an activity to be drawn.</span></span><br><span class="line">            mStackSupervisor.notifyActivityDrawnForKeyguard();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>​ 我注释说的很清楚了，如果要启动的activity已经是resumed了，就什么都不做。因为这就是一个当前resumed的activity启动它自己。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we are sleeping, and there is no resumed activity, and the top</span></span><br><span class="line">        <span class="comment">// activity is paused, well that is the state we want.</span></span><br><span class="line">        <span class="comment">//如果系统正在休眠，并且当前最上层的activity都已经是paused状态了（top activity就是我们要启动的activity）。那就是完美的状态。</span></span><br><span class="line">        <span class="keyword">if</span> (mService.isSleepingOrShuttingDown()</span><br><span class="line">                &amp;&amp; mLastPausedActivity == next</span><br><span class="line">                &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class="line">            <span class="comment">// Make sure we have executed any pending transitions, since there</span></span><br><span class="line">            <span class="comment">// should be nothing left to do at this point.</span></span><br><span class="line">            mWindowManager.executeAppTransition();</span><br><span class="line">            mNoAnimActivities.clear();</span><br><span class="line">            ActivityOptions.abort(options);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG, <span class="string">"resumeTopActivityLocked: Going to sleep and all paused"</span>);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​ 如果系统正在休眠，并且当前最上层的activity都已经是paused状态了（top activity就是我们要启动的activity）。那就是完美的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we are currently pausing an activity, then don't do anything</span></span><br><span class="line">        <span class="comment">// until that is done.</span></span><br><span class="line">        <span class="keyword">if</span> (!mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_PAUSE || DEBUG_STATES) Slog.v(TAG,</span><br><span class="line">                                                                     /  <span class="string">"resumeTopActivityLocked: Skip resume: some activity pausing."</span>);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​ 如果我们的app里面正在暂停某个activity，那么我们什么都不要做等这个做完，因为暂停activity的过程是串行的，必须要一个一个按顺序的来。不能同时来，我认为原因就是因为客户端调用远程服务的过程的时候本地的客户端所在线程会被挂起</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/ We need to start pausing the current activity so the top one</span><br><span class="line">        <span class="comment">// can be resumed...</span></span><br><span class="line">        <span class="comment">//先把现在的当前还是resumed的activity pause了，这样新加进来的activity才能resume。基础知识</span></span><br><span class="line">        <span class="keyword">boolean</span> dontWaitForPause = (next.info.flags&amp;ActivityInfo.FLAG_RESUME_WHILE_PAUSING) != <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//开始暂定现在stack里面所有的activity</span></span><br><span class="line">        <span class="keyword">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, <span class="keyword">true</span>, dontWaitForPause);</span><br><span class="line">        <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//开始pausing当前的所有activity，并且返回一个是否暂定成功的结果回来</span></span><br><span class="line">            pausing |= startPausingLocked(userLeaving, <span class="keyword">false</span>, <span class="keyword">true</span>, dontWaitForPause);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG, <span class="string">"resumeTopActivityLocked: Pausing "</span> + mResumedActivity);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​ 这里就是在做把当前启动者activity给pause掉，即至于为什么要这么做。。不用我多说了吧。</p>
<p>​ startPausingLocked(userLeaving, false, true, dontWaitForPause);这个函数跟着看下去就是通过AMS来暂停activity的过程。这个就不多说了，大同小异。</p>
<p>最终在函数的末尾会又调用ActivityStackSupervisor的<strong>startSpecificActivityLocked(next, true, true);</strong>方法。这个方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span><br><span class="line">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">      <span class="comment">//注意了，这里的app之后会用到，因为app.thread就是获得了applicationthread实例！</span></span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        r.task.stack.setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class="number">0</span></span><br><span class="line">                        || !<span class="string">"android"</span>.equals(r.info.packageName)) &#123;</span><br><span class="line">                    <span class="comment">// Don't add this if it is a platform component that is marked</span></span><br><span class="line">                    <span class="comment">// to run in multiple processes, because this is actually</span></span><br><span class="line">                    <span class="comment">// part of the framework so doesn't make sense to track as a</span></span><br><span class="line">                    <span class="comment">// separate apk in the process.</span></span><br><span class="line">                    app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class="line">                            mService.mProcessStats);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//将app，信息完整的要启动的ActivityRecord类的实例传到另一个方法里面去</span></span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when starting activity "</span></span><br><span class="line">                        + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">            <span class="comment">// restart the application.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续跟进这个<strong>realStartActivityLocked()</strong>（真正启动activity的过程在这里）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r,</span><br><span class="line">            ProcessRecord app, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span></span><br><span class="line">            <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">        r.startFreezingScreenLocked(app, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) Slog.d(TAG, <span class="string">"realStartActivity: setting app visibility true"</span>);</span><br><span class="line">        mWindowManager.setAppVisibility(r.appToken, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// schedule launch ticks to collect information about slow apps.</span></span><br><span class="line">        r.startLaunchTickingLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Have the window manager re-evaluate the orientation of</span></span><br><span class="line">        <span class="comment">// the screen based on the new activity order.  Note that</span></span><br><span class="line">        <span class="comment">// as a result of this, it can call back into the activity</span></span><br><span class="line">        <span class="comment">// manager with a new orientation.  We don't care about that,</span></span><br><span class="line">        <span class="comment">// because the activity is not currently running so we are</span></span><br><span class="line">        <span class="comment">// just restarting it anyway.</span></span><br><span class="line">        <span class="keyword">if</span> (checkConfig) &#123;</span><br><span class="line">            Configuration config = mWindowManager.updateOrientationFromAppTokens(</span><br><span class="line">                    mService.mConfiguration,</span><br><span class="line">                    r.mayFreezeScreenLocked(app) ? r.appToken : <span class="keyword">null</span>);</span><br><span class="line">            mService.updateConfigurationLocked(config, r, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.app = app;</span><br><span class="line">        app.waitingToKill = <span class="keyword">null</span>;</span><br><span class="line">        r.launchCount++;</span><br><span class="line">        r.lastLaunchTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Launching: "</span> + r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx = app.activities.indexOf(r);</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            app.activities.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        mService.updateLruProcessLocked(app, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        mService.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ActivityStack stack = r.task.stack;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;ResultInfo&gt; results = <span class="keyword">null</span>;</span><br><span class="line">            List&lt;Intent&gt; newIntents = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                results = r.results;</span><br><span class="line">                newIntents = r.newIntents;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">...省略代码</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过applicaitonthread调用客户端binder实体的方法。</span></span><br><span class="line">            app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</span><br><span class="line">                    System.identityHashCode(r), r.info, <span class="keyword">new</span> Configuration(mService.mConfiguration),</span><br><span class="line">                    r.compat, r.task.voiceInteractor, app.repProcState, r.icicle, r.persistentState,</span><br><span class="line">                    results, newIntents, !andResume, mService.isNextTransitionForward(),</span><br><span class="line">                    profilerInfo);</span><br><span class="line"></span><br><span class="line">      ...省略代码</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​ 这里面两个很重要的参数，一个是ActivityRecord，一个是app。前者就是在ActivityStack里面转了一圈之后得出来的最终要启动的Activity的信息记录类。后者就是用来获得ApplicationThread来通知客户端拿这个ActivityRecord去管理你的activity的生命周期吧！相当于AMS给了ActivityThread一个任务，让后者去执行。同样，这也是一个IPC的过程。最终调用链绕了好大一圈终于又回到了ApplicaitonThread。</p>
<p>​ 值得一提的是，凡是schedule开头的函数都是通过handler来做线程调度的，不服来辩。我们点进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">int</span> processState,</span><br><span class="line">                <span class="keyword">boolean</span> isForward, Bundle resumeArgs)</span> </span>&#123;</span><br><span class="line">            updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">            sendMessage(H.RESUME_ACTIVITY, token, isForward ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​ 果然用handler发送了一个message。我们来看handler的处理会最终调用handlerLaunchActivity方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">            Bundle oldState = r.state;</span><br><span class="line">            handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</span><br></pre></td></tr></table></figure>
<p>​ 可以看到activity的实例是由performLaunchActivity方法生成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println("##### [" + System.currentTimeMillis() + "] ActivityThread.performLaunchActivity(" + r + ")");</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//获得一些基本信息</span></span><br><span class="line">        ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">        <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                    Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ComponentName component = r.intent.getComponent();</span><br><span class="line">        <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">            component = r.intent.resolveActivity(</span><br><span class="line">                mInitialApplication.getPackageManager());</span><br><span class="line">            r.intent.setComponent(component);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                    r.activityInfo.targetActivity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//通过Instrumentation利用类加载器来生成一个activity实例</span></span><br><span class="line">        Activity activity = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Unable to instantiate activity "</span> + component</span><br><span class="line">                    + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//尝试生成application</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">//创建contextImpl对象，并且调用activity的attach()方法来进行一些activity初始化</span></span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">                Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//设置activity的theme</span></span><br><span class="line">                <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">                <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                    activity.setTheme(theme);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">            mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> activity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​ 做了这些事情</p>
<ul>
<li>从ActivityClientRecord中获取获取组件信息</li>
<li>通过Instrumentation创建Activity对象</li>
<li>通过LoadApk的makeApplication创建application，这个方法有兴趣自己去看，就是一个单例而已。</li>
<li>创建contextImpl对象，并且调用activity的attach()方法来进行一些activity初始化</li>
<li>调用activity的onCreat()方法</li>
</ul>
<p><strong>完成整个过程调用</strong> ！！！！</p>
<h1 id="结束语">结束语</h1><p>​ 系统源码看起来确实感觉自己置身茫茫大海一样，特别是要去找一些不理解的问题的时候。比如到底是被启动的activity的ActivityRecord实例先添加进去还是在实例创建了之后才添加进去，这个问题我看源码着了一天才还没有什么结果，后来在别人的帮助和查阅老罗的资料才找到问题所在。挺不错的一次过程，确实细节不必死扣，但是有些基本问题不懂的话还是应该去探究一下。</p>
<p><strong>版权声明：本文为博主原创文章，未经博主允许不得转载。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;p&gt;​ 我还记得上个学期意外看到一篇文章，是凯子哥的一篇博客，讲的是app第一个activity启动的底层过程(java)，我当时几乎没接触过这块的源码，好像看了一半就放弃。还有一次刷知乎，看到一个人回答为什么ActivityThread里
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android-IPC系列（二）</title>
    <link href="http://yoursite.com/2016/04/06/Android-IPC%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/04/06/Android-IPC系列（二）/</id>
    <published>2016-04-06T05:48:51.000Z</published>
    <updated>2016-10-26T13:53:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>  写完IPC的第一篇我就有点后悔了。。因为binder的水太深了，老罗写binder写了十几万字。如果深入学习会大量涉及到系统层的知识，甚至SM,Binder驱动都是用c语言写的。。最近也是看了很多大牛关于binder的文章，可以说对binder的认识又提升了一步。<strong>虽然我学的很浅，但是我尽量保证自己写的都是对的！</strong> 来一波binder的最新认识总结吧！～</p>
<p><a href="http://zane96.github.io/2016/03/19/Android-IPC%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">Android_IPC系列(一)</a></p>
<p>上一篇文章主要是介绍一些简单的linux知识，通过AIDL中的生成代码来理解binder实现跨进程的原理。</p>
<p>任务：</p>
<ol>
<li>补充一些Linux知识。</li>
<li>binder实现跨进程通信的实现流程是怎样的</li>
<li>简单介绍binder机制</li>
</ol>
<hr>
<h2 id="一些补充知识">一些补充知识</h2><p>1.<strong>UserSpace, KernelSpace ,用户态，内核态</strong></p>
<p>  用户空间和内核空间。内核空间是linux系统的核心，可以访问受保护资源和所有的硬件设备的权限。内核独立于应用程序，看起来是系统内部的一个应用。kernel有自己的保护措施，告知其他应用程序他拥有什么权限。所以在逻辑上，将kernal和应用程序抽离成两块空间。</p>
<p>  当某个应用程序需要访问内核资源的时候，可以通过系统调用来接入内核。然后内核会来控制这个应用程序对资源的访问，防止这个程序破坏系统资源，保证安全。这时候就会称这个进程处于<strong>内核态</strong> 。当应用程序在跑自己的代码的时候，就称为<strong>用户态</strong>。</p>
<p>2.<strong>Binder驱动</strong></p>
<p>  Linux系统内部是支持socket，信号量等进程通信的，但是安卓系统在性能和安全两个方面设计了自己的进程通信方式：Binder。两个用户空间想要通信，必须通过内核空间来支持。所以安卓就是将binder驱动作为内核模块添加到Linux Kernel。Binder驱动运行在kernel空间，支持用户空间的通信，可以堪称一个桥梁，所有包含binder的数据包传输都会通过binder驱动来完成，无一例外！在binder驱动里面，binder的实体和引用是以节点（struct）的形式存在的，包括server的binder实体，clinet里面拥有的binder引用，内核的0号应用以及SM的binder实体（后两者后面会提到）。</p>
<p>  驱动是Binder通信的核心，系统中所有的Binder实体以及每个实体在各个进程中的引用都登记在驱动中；驱动需要记录Binder引用-&gt;实体之间多对一的关系；为引用找到对应的实体；在某个进程中为实体创建或查找到对应的引用；记录Binder的归属地（位于哪个进程中）；通过管理Binder的强/弱引用创建/销毁Binder实体等等。</p>
<p>3.<strong>ServiceManager, Binder,Clinet, Server</strong></p>
<p>  在Binder的机制中，SM, Clinet, Server以及上面提到的Binder驱动是很重要的四个部分，而binder就可以看成是这四个部件之间沟通的管道。但是binder在每个部件里面的形态，功能是完全不同的。宏观来看，binder可以看成是安卓跨进程通信的方式，工具，协议。微观的来看，binder可以看成各个部件里面重要的结构，类，binder可以看成binder驱动里面的红黑树数据结构，binder可以看成进程之间传输的数据包。binder作为胶水，将不同的进程粘合在一起，模糊了进程隔离。</p>
<p>  ServiceManager是独立于client, server的系统进程。是由zygote进程fork出来的。它在IPC通信中的作用是作为”通讯录”。所有的server里面的binder实体会先在SM里面注册自己的信息，key是binder的名字（独一无二），在AIDL的生成代码里面你会看到这个玩意:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR =<span class="string">"com.example.zane.ipc_test.IBookManager"</span>;</span><br></pre></td></tr></table></figure>
<p>value就是这个binder的引用，这样就把这个binder的信息保存下来了。也就是说client需要通过SM，以名字来去得到server的binder引用。然后通过这个引用去操作server端的binder。这里也体现了binder中面向对象的设计理念。clinet自己并不知道自己获得的这个binder引用是真的实体还是什么假的实体，它只会去拿着自己获得的引用去操作。并且server中binder实体的引用会在SM,和所有需要跟自己通信的clinet里面存在。在这里，你可以把引用看成指针，或者代理对象。</p>
<p>  client和server就是客户端和服务端。</p>
<p>  在服务端：如果你熟悉AIDL进行进程间通信的流程或者看过我上篇博客，你应该对binder的存在形式有所体会。首先是一个aidl类型的接口，定义了binder的所有功能函数。并且这些功能函数需要被编号，因为服务端是通过解析客户端传递过来的数据包中的函数编号来知道自己应该去调用什么函数。在Stub类中有这么几行代码(函数编号):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>  我们知道Stub就是Binder在Server的实体，里面实现了很多函数，onTransact()就是来分析客户端的请求类型的函数，然后调用相应的函数，并且将返回结果放在数据包中返回给客户端。</p>
<p>  在客户端：同样的，我们在客户端也需要去实现Binder，只不过这个binder是SM转发给我们的，如果客户端和服务端在同一个进程，那么就会返回binder实体，如果不在同一个进程就会返回binder的代理。由于binder代理和binder实体都是实现了AIDL接口的类。所以客户端看不出来这个binder是实体或是引用。如果你做过IPC通信，你会知道以上的过程是通过asInterface(IBiner binder)这个方法实现的。</p>
<hr>
<h2 id="实现流程">实现流程</h2><p>  直接上一张我自己画的简介图！</p>
<p><img src="/img/ipc2-1.png" alt="简介图"></p>
<p>  可以很清楚的看出，binder驱动是整个流程的核心！</p>
<p>  1.Server将自己的binder通过binder驱动在SM中进行注册。</p>
<p>  2.binder驱动会建立一个binder实体的数据节点和实体的引用。</p>
<p>  3.Binder驱动再把名字和引用打包发给SM。</p>
<p>  4.Client通过binder驱动拿着他所需要的binder名字向SM请求binder。</p>
<p>  5.SM在自己的查找表里面找到对应的引用之后再通过binder驱动返回给client。</p>
<p><strong>所有的系统服务在SystemServer进程深沉之后就会被建立并且注册在ServiceManager里面，开发者也可以开发自定义的服务并且注册在ServiceManager里面成为系统级别的服务，前提是这个包含服务的应用必须是system用户并且带了system签名（系统安全），否则是不能随意注册的！</strong></p>
<p>  好了，再来一张我在一位大牛博客里面截下来的图片，这个流程描述就更具体了：</p>
<p><img src="/img/ipc2-2.png" alt="具体图"></p>
<p>  其实就是多了binder驱动里面的一些数据结构节点和一个叫0号引用的东西。那么这个0号引用是什么呢？我们知道SM, Client, Server都是运行在三个不同的进程的。那么第一步Server要向SM注册自己binder的信息，那么这里已经涉及到了跨进程通信了。那么这个进程通信是怎么实现的呢？通过上图可以看到，所有的Client里面的0号引用都指向了SM里面的binder。也就是说SM和其他所有Server通信的过程都是SM先通过特殊的命令在biner驱动中建立了自己binder的实体节点，并且其他所有地方的0号引用都默认留给SM的binder实体引用。</p>
<hr>
<h1 id="结束语">结束语</h1><p>  上一篇文章讲的AIDL生成代码的分析，本来准备第二篇总结一下AIDL的使用。后来通过不断的学习觉得这篇文章讲的东西更值得总结！</p>
<p>  总之，binder要学习的东西还是很多。比如binder协议，binder传输数据包类型，binder在驱动里面的数据结构，缓存和线程池管理等等…<strong>Binder在安全性，效率性都优于Linux系统默认支持的IPC通信方式,拥有面向对象的设计原理。</strong></p>
<p><strong>未经博主同意，不得转载该篇文章</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;p&gt;  写完IPC的第一篇我就有点后悔了。。因为binder的水太深了，老罗写binder写了十几万字。如果深入学习会大量涉及到系统层的知识，甚至SM,Binder驱动都是用c语言写的。。最近也是看了很多大牛关于binder的文章，可以说对
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android-IPC系列（一）</title>
    <link href="http://yoursite.com/2016/03/19/Android-IPC%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/03/19/Android-IPC系列（一）/</id>
    <published>2016-03-19T07:52:20.000Z</published>
    <updated>2016-10-26T13:51:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>未经博主同意，不得转载该篇文章</strong></p>
<h1 id="前言">前言</h1><p>  IPC－进程间通信。安卓虽然是一个基于linux内核的系统，但是安卓却有自己的一套IPC机制。想要弄懂安卓的IPC机制首先要理解几个framework层的概念，安卓的序列化机制以及binder和AIDL的实现流程（其它基于binder的ipc实现方式就不再多说了～）。在写这篇博客之前反复看了几遍《安卓开发艺术探索》的第二章，以及凯子哥（csdn）的framework层的文章and与一位大神学长交流，以保证文章的可靠性。这篇文章我将以自己的语言总结对于ipc的学习成果～</p>
<p>  <strong>Demo地址</strong>:<a href="https://github.com/Zane96/IPC-demo" target="_blank" rel="external">IPC-demo</a></p>
<h2 id="几个概念">几个概念</h2><p>1.<strong>Binder</strong>:</p>
<p>  Binder是安卓的一个类，实现了Binder接口（后面多次出现）。Binder我理解成安卓IPC机制的核心，也就是实现IPC的核心工具。它不仅用于安卓开发层还用于安卓的framework层。在架构层里面binder是各种系统manager之间连接的工具（WindowManager, ActivityManager等等）。开发层用于service，别告诉我你不知道service里面会返回一个IBinder。</p>
<p>2.<strong>AIDL</strong>:</p>
<blockquote>
<p>前不久在一个安卓群看到有个面试官问别人aidl是什么。。别人当时就蒙蔽了。。</p>
</blockquote>
<p>  AIDL(Android Interface Definition Language)，安卓接口定义语言。它是安卓实现IPC通信的一种比较重要的方式，并且底层基于binder。所以我们就讲这个啦！</p>
<p>3.<strong>linux的进程</strong>：</p>
<blockquote>
<p>这个问题我专门请教了一个学长～</p>
</blockquote>
<p>  Linux没有很严格的纯粹进程概念。一堆线程共享一块内存区域就是一个进程。当你的手机启动的时候，系统会启动一个init进程，这个应该可以成为Linux的主进程了。之后的所有进程都是从init进程fork出来的，比如zygote进程和SystemServer进程。</p>
<p>4.<strong>zygote进程</strong></p>
<p>  顾名思义（受精卵），这个进程会像个受精卵一样不停的“分裂”，去fork出别的进程。几乎后面出现的所有进程都是从这个进程fork出来的。包括SystemServer进程，ActivityManagerService等等。但是具体来说，AMS是SystemServer里面fork出来的。也许你会问为什么要这样做，那是因为这样设计更高效（当然我只是个普通的开发者，并不懂那些大神是怎么想的哈哈）。</p>
<p>4.<strong>ActivityManagerService</strong>:</p>
<p>  这个玩意，我觉得是相当重要的，为什么这么说呢，因为它管理着手机中<strong>所有</strong>Activity的生死。你说重不重要？？？当你打开一个app后，AMS会立马在zygote里面fork一个进程出来，并且复制一个虚拟机（Dalvik or ART）和一些资源以及一个线程（是的，这就是UI线程～，不要怀疑自己！）。启动一个app是AMS和Lanucher, ActivityThread一起合作做到的。具体的实现，自己可以去看看别的文章，这不是我们要讲的重点。另外说一点，AMS, activity之间也是通过binder来进行通信，你要知道，AMS, zygote, activity都是在不同的进程里面。</p>
<p>5.<strong>App与进程</strong>:</p>
<p>  一个app对应一个进程。这种说法我不太敢苟同。首先一个app，一个进程这种说法太模糊，因为app是可以设置多进程的哇。。（设置组件的process），所以我觉得多进程的app应该看成共享apk资源的多个应用。</p>
<p>6.<strong>ShareUID</strong>:</p>
<blockquote>
<p>之前在一个群里面听前辈们讨论app资源共享的问题，多次看到这个单词，当时在想，卧槽，这tm什么鬼？！</p>
</blockquote>
<p>  这个东西你可以大概理解成每个apk的ID。一个apk对应一个uid，所以一个app里面跑在同一个进程里面的组件数据可以共享。如果一个app里面某个组件让他跑在别的进程里面，相当于是创建了一个新的application，这个组件跟自己app里面的其它组件并没有多大关系。然后ipc就可以起作用了，通过binder进行进程间通信。如果两个属于不同app的组件，自然是有不同的application和虚拟机了，然后通过签名文件和uid来进行数据共享。普通的资源文件比如string, color这些文件是不需要相同的uid就可以访问的，但是data里面的数据是需要这样的。具体怎么做，自己有兴趣也可以去查查资料～</p>
<p>7.<strong>序列化与反序列化</strong>:</p>
<p>  首先你要知道，数据的传输都是要把数据转换成字节码，不管你是什么类型的数据。（嗯，没有例外！）序列化就是把数据转换成字节码的过程，而反序列化自然就是在数据传输的目的地把字节码转换成原始数据。之前自己为了方便，所有都使用Serializable来做序列化。后来知道Parcelable的效率更高。因为Serializable要做大量的IO操作。所以以后都要使用安卓里面的Parcelable来做序列化哦～</p>
<blockquote>
<p>好了，基本的概念介绍完毕。！如果我有说的不合理的地方请大家无情给我指出！！啪啪的打我的脸</p>
</blockquote>
<hr>
<h2 id="Binder的工作原理">Binder的工作原理</h2><blockquote>
<p>我们直接通过aidl文件生成的源码来理解binder的工作原理！</p>
</blockquote>
<p>  首先新建一个aidl的文件包。声明三个aidl文件。并且在java包里面声明我们要传输的类Book。</p>
<p><img src="/img/ipc1.png" alt="结构图"></p>
<p>  代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 16/3/16.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bookId;</span><br><span class="line">    <span class="keyword">public</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> bookId, String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookId = bookId;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeInt(bookId);</span><br><span class="line">        dest.writeString(bookName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Book&gt;()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel in)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Book</span><span class="params">(Parcel in)</span></span>&#123;</span><br><span class="line">        bookId = in.readInt();</span><br><span class="line">        bookName = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"bookId "</span> + bookId +<span class="string">" bookName "</span> + bookName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Book.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.zane.ipc_test;</span><br><span class="line">parcelable Book;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.zane.ipc_test;</span><br><span class="line"><span class="keyword">import</span> com.example.zane.ipc_test.Book;</span><br><span class="line"><span class="keyword">import</span> com.example.zane.ipc_test.IOnNewBookArrivedListener;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(IOnNewBookArrivedListener listener)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unRegisterListener</span><span class="params">(IOnNewBookArrivedListener listener)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// IOnNewBookArrivedListener.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.zane.ipc_test;</span><br><span class="line"><span class="comment">//监听服务端是否有新书籍，如果有新书籍就立即推送到客户端,观察者模式</span></span><br><span class="line"><span class="keyword">import</span> com.example.zane.ipc_test.Book;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOnNewBookArrivedListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">newBookArrived</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  好了，咱先不管IOnNewBookArrivedListener.aidl这个文件。我们分析IBookManager.aidl的生成源码。项目包里面的gen目录下面有一个xxx.aidl包里面会有一个IBookManager.java的文件。我们就是要分析它！嗯，搞掂它！</p>
<p>  当我用sublime打开它之后，老子差点吐掉。。</p>
<p><img src="/img/ipc2.png" alt="迷之代码"></p>
<p>  。。然后我凭借我的强迫症一个个的给它缩进！我就是这么雷锋。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * This file is auto-generated.  DO NOT MODIFY.</span><br><span class="line"> * Original file: /Users/Zane/编程/AndroidStudioProjects 13-52-23-071/IPC_Test/app/src/main/aidl/com/example/zane/ipc_test/IBookManager.aidl</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">package</span> com.example.zane.ipc_test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">zane</span>.<span class="title">ipc_test</span>.<span class="title">IBookManager</span></span><br><span class="line">  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//binder的唯一标识符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.example.zane.ipc_test.IBookManager"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Cast an IBinder object into an com.example.zane.ipc_test.IBookManager interface,</span><br><span class="line"> * generating a proxy if needed.</span><br><span class="line"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.example.zane.ipc_test.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">      <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.example.zane.ipc_test.IBookManager))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.example.zane.ipc_test.IBookManager)iin);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> com.example.zane.ipc_test.IBookManager.Stub.Proxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">    </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (code)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">          reply.writeString(DESCRIPTOR);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_getBookList:</span><br><span class="line">        &#123;</span><br><span class="line">          data.enforceInterface(DESCRIPTOR);</span><br><span class="line">          java.util.List&lt;com.example.zane.ipc_test.Book&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          reply.writeTypedList(_result);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_addBook:</span><br><span class="line">        &#123;</span><br><span class="line">          data.enforceInterface(DESCRIPTOR);</span><br><span class="line">          com.example.zane.ipc_test.Book _arg0;</span><br><span class="line">          <span class="keyword">if</span> ((<span class="number">0</span>!=data.readInt())) &#123;</span><br><span class="line">            _arg0 = com.example.zane.ipc_test.Book.CREATOR.createFromParcel(data);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            _arg0 = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">zane</span>.<span class="title">ipc_test</span>.<span class="title">IBookManager</span></span><br><span class="line">  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">    Proxy(android.os.IBinder remote)</span><br><span class="line">    &#123;</span><br><span class="line">      mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.example.zane.ipc_test.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">      android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">      android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">      java.util.List&lt;com.example.zane.ipc_test.Book&gt; _result;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">        _result = _reply.createTypedArrayList(com.example.zane.ipc_test.Book.CREATOR);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> _result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.example.zane.ipc_test.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">    </span>&#123;</span><br><span class="line">      android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">      android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">if</span> ((book!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">          _data.writeInt(<span class="number">1</span>);</span><br><span class="line">          book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          _data.writeInt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">          mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">          _reply.readException();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">public</span> java.util.List&lt;com.example.zane.ipc_test.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.example.zane.ipc_test.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  如果，你是第一次接触这个，或者以前没看过什么源码，内心应该跟我之前一样，也是崩溃的。但是，我们是程序员，在源码面前千万不能低头！大概看一遍，Proxy这个类看到没，嗯，没错了，用到了代理。再看Stub这个这个内部类，继承了什么？大声告诉我！嗯，就是Binder类。没错，这个Stub就是后面多次用到的Binder！其实这么多代码，只需要理解Stub, Proxy这两个类就差不多了。我们来细看代码：</p>
<p>asInterface(Binder obj):</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.example.zane.ipc_test.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//查询本地的binder</span></span><br><span class="line">      android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.example.zane.ipc_test.IBookManager))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.example.zane.ipc_test.IBookManager)iin);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> com.example.zane.ipc_test.IBookManager.Stub.Proxy(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>  这个方法在后面使用的部分会多次用到。作用就是将服务端的Binder对象转换成客户端所需要的AIDL接口类型的对象。<strong>不知道你有没有感受到，这其实就是一种类似接口回调的过程。在客户端使用这个方法去得到服务端的binder类型的接口，然后调用服务端的方法。</strong></p>
<p>  代码很简单，如果客户端和服务端在一个进程那么就返回这个binder，如果是多进程就返回远程代理类Proxy的实例。</p>
<blockquote>
<p>写到这里，突然感冒加重有点发烧的感觉。。。orz，我还是坚持下去！</p>
</blockquote>
<p>  我们再来看Proxy类里面的两个实现了IBookManager接口的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.example.zane.ipc_test.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">      android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">      android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">      java.util.List&lt;com.example.zane.ipc_test.Book&gt; _result;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        <span class="comment">//调用onTransact()方法</span></span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//读取异常</span></span><br><span class="line">        _reply.readException();</span><br><span class="line">        <span class="comment">//获得返回值并返回给客户端</span></span><br><span class="line">        _result = _reply.createTypedArrayList(com.example.zane.ipc_test.Book.CREATOR);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> _result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>  data是输入对象，reply是输出对象，result是最后返回给客户端的数据。这个是getBookList的方法，没有参数，只有返回值，所以data写入token标识符之后就直接调用了Stub类里面的onTransact()方法。在onTransact()方法里面把结果值写入reply并且返回true表示客户端与服务端连接成功。如果返回false就表示连接失败！再看addBook(Book book)的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.example.zane.ipc_test.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">    </span>&#123;</span><br><span class="line">      android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">      android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        <span class="comment">//防止传入的参数为null</span></span><br><span class="line">        <span class="keyword">if</span> ((book!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">          _data.writeInt(<span class="number">1</span>);</span><br><span class="line">          book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          _data.writeInt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用onTransact()方法</span></span><br><span class="line">          mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">          _reply.readException();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>  我想如果你不是特别傻，应该可以类比上面看得懂这个吧！我在上面写了一些注释。然后就来看Stub是来如何响应RPC（远程过程调用）的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">    </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (code)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">          reply.writeString(DESCRIPTOR);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_getBookList:</span><br><span class="line">        &#123;</span><br><span class="line">          data.enforceInterface(DESCRIPTOR);</span><br><span class="line">          java.util.List&lt;com.example.zane.ipc_test.Book&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          reply.writeTypedList(_result);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_addBook:</span><br><span class="line">        &#123;</span><br><span class="line">          data.enforceInterface(DESCRIPTOR);</span><br><span class="line">          com.example.zane.ipc_test.Book _arg0;</span><br><span class="line">          <span class="keyword">if</span> ((<span class="number">0</span>!=data.readInt())) &#123;</span><br><span class="line">            _arg0 = com.example.zane.ipc_test.Book.CREATOR.createFromParcel(data);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            _arg0 = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>  这个方法通过传进来的不同code来响应客户端不同的请求。</p>
<ol>
<li><p>TRANSACTION_getBookList里面，首先调用获得服务端的List，然后写入reply。返回true表示连接成功，并且让客户端从reply里面read出来返回过来的数据。</p>
</li>
<li><p>TRANSACTION_addBook里面，通过Parcelable去new出了一个新的Book实例。然后调用服务端的addBook方法，把这个实例返回给服务端。你如果第一次使用Parceable可能会不理解怎么new出新的Book的。你回头去看看你的Book类你就懂了！</p>
</li>
</ol>
<p>嗯！就是这么简单！源码我们基本就分析完了！我们再来总结一下流程。</p>
<ol>
<li>客户端发出请求，然后将客户端发送请求的线程挂起（这个下篇文章再说）</li>
<li>Binder写入参数（从客户端传入）到data，如果没有则不写入。</li>
<li>调用transact()方法</li>
<li>onTransact()响应，调用Service(服务端)的实现方法，并且把客户端需要的数据写入reply，如果没有则不写入。</li>
<li>result读出数据返回客户端，唤醒客户端，客户端获得数据。</li>
</ol>
<hr>
<h1 id="总结">总结</h1><p>  开始准备一篇文章直接写完。。发现得需要两篇了！</p>
<p>  这篇文章我们解决了一些IPC的基本概念知识and通过aidl学习binder的工作原理。</p>
<p>  <strong>啊啊，，，突然发烧了卧槽，好难受，下篇我们接着说AIDL的使用！</strong></p>
<p><strong>未经博主同意，不得转载该篇文章</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;未经博主同意，不得转载该篇文章&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;p&gt;  IPC－进程间通信。安卓虽然是一个基于linux内核的系统，但是安卓却有自己的一套IPC机制。想要弄懂安卓的IPC机制首先要理解几个framework层
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>MVP中Model的进一步细化——DataManager</title>
    <link href="http://yoursite.com/2016/03/01/MVP%E4%B8%ADModel%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%BB%86%E5%8C%96%E2%80%94%E2%80%94DataManager/"/>
    <id>http://yoursite.com/2016/03/01/MVP中Model的进一步细化——DataManager/</id>
    <published>2016-03-01T12:57:31.000Z</published>
    <updated>2016-10-26T13:52:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>  首先上篇文章讲到的是依赖注入（dagger），然后我使用rxjava, retrofit, dagger2, mvp做了一个练手app——<a href="https://github.com/Zane96/GithubQuery" target="_blank" rel="external">githubQuery</a>，算是第一次尝试吧。再是mvp用的是我自己的一个框架<a href="https://github.com/Zane96/EasyMVP" target="_blank" rel="external">EasyMVP</a>。然后在model层我学习了一个老外的想法，抽出来了一个叫datamanager的东西，它属于model层，用于过滤和操作从model层得到的数据。主要的目的是方便dagger提供单一的数据层依赖，并且减少presenter层的代码量。这几个库都不好上手，但是我觉得多用多写就好了，我现在已经在用这套方法在做别的项目了。</p>
<h3 id="依赖注入图">依赖注入图</h3><h2 id=""><img src="/img/gtihubquery依赖注入图1.png" alt="依赖注入图"></h2><p><img src="/img/githubquery依赖注入图2.png" alt="依赖注入图2"><br>  可以看到我在ActivityComponent中的API是抛出了很多的inject方法用来注入其他所有的activity，但是这种做法适合小项目，项目大了之后，如果每个activity的依赖需求不同还是很麻烦，所以最好一个activity一个component。对照这个图看代码基本问题不大，我记得当时对于@Inject这个注解的理解不是很深刻！</p>
<p>  DataManager相当于是model所有数据源的代理层，作为ApplicaitonComponent的API暴露出来，然后作为ActivityComponent的依赖注入进去。</p>
<h4 id="@Inject()">@Inject()</h4><p>  如果@Inject标注的是构造方法。那么表明这个类的对象也是依赖注入图里面的一员，前提是这个构造函数里面的所有参数都是来自依赖注入图（@provide）。</p>
<h3 id="项目架构图">项目架构图</h3><p><img src="/img/githubquery项目架构图.png" alt="项目架构图"></p>
<p><strong>注意，我的mvp开发模式是将activity,fragment作为presenter。</strong></p>
<p>  在这里DataManager就是整个架构的核心了。因为我们使用的是rxjava+retrofit，自然要有一种流的思想。你可以这样想，一个数据流从hepler类流到datamanager，然后在这里做你所需要的变换。比如你需要把所有学生姓名的首字母大写，但是api返回的元数据是没有大写的。这样做其实就是为了给activity等presenter瘦身。我贴出我的DataManager的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 16/1/26.</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GithubApiService githubApiService;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataManager</span><span class="params">(@ContextType(<span class="string">"MyApplication"</span>)</span>Context context, GithubApiService githubApiService)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.githubApiService = githubApiService;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对用户信息进行一层过滤或者操作,然后在presenter中去调用这个方法.</span></span><br><span class="line">    <span class="comment">//当然我在这里做的操作毫无意义，但是如果有需要还是会减少activity活着fragment中的代码量。</span></span><br><span class="line">    <span class="comment">//presenter只负责调用。然后获得数据而不管代码的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;Users&gt; <span class="title">getUserInfo</span><span class="params">(String userName)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> githubApiService.getUserInfo(userName)</span><br><span class="line">                .map(<span class="keyword">new</span> Func1&lt;Users, Users&gt;() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Users <span class="title">call</span><span class="params">(Users users)</span> </span>&#123;</span><br><span class="line">                        String name = users.getName();</span><br><span class="line">                        users.setName(name + <span class="string">" datamanager"</span>);</span><br><span class="line">                        <span class="keyword">return</span> users;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .flatMap(<span class="keyword">new</span> Func1&lt;Users, Observable&lt;Users&gt;&gt;() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Observable&lt;Users&gt; <span class="title">call</span><span class="params">(<span class="keyword">final</span> Users users)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Users&gt;() &#123;</span><br><span class="line">                            <span class="annotation">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Users&gt; subscriber)</span> </span>&#123;</span><br><span class="line">                                subscriber.onNext(users);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对库的信息进行一层过滤</span></span><br><span class="line">    <span class="keyword">public</span> Observable&lt;List&lt;Repos&gt;&gt; getReposInfo(String userName)&#123;</span><br><span class="line">        <span class="keyword">return</span> githubApiService.getReposInfo(userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我将用户的名字后面加了一个datamanager，在这里虽然没什么意义，但是要体现datamanager的作用所在。</p>
<h3 id="不足">不足</h3><p>没有任何东西是完美的。</p>
<p>这里如果只有一个DataManager的话，那么如果数据量一大，这个类会变得非常的臃肿和复杂。</p>
<p>所有东西都是在不断尝试吧，贴出这个思想创始人的文章:<a href="https://labs.ribot.co.uk/android-application-architecture-8b6e34acda65#.3fb3ymcjc" target="_blank" rel="external">Android Application Architecture</a></p>
<p>好了，去上课了。。近代史！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;p&gt;  首先上篇文章讲到的是依赖注入（dagger），然后我使用rxjava, retrofit, dagger2, mvp做了一个练手app——&lt;a href=&quot;https://github.com/Zane96/GithubQuery&quot;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>MVP开发框架的一次尝试——EasyMVP</title>
    <link href="http://yoursite.com/2016/01/28/MVP%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E2%80%94%E2%80%94EasyMVP/"/>
    <id>http://yoursite.com/2016/01/28/MVP开发框架的一次尝试——EasyMVP/</id>
    <published>2016-01-28T11:56:51.000Z</published>
    <updated>2016-10-26T13:52:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>  用MVP模式开发安卓相信大家也应该不是很陌生了。各种各样的mvp开发模式，框架也是层出不穷。之前写过一篇<a href="http://zane96.github.io/2015/12/06/MVP%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B0%E5%B0%9D%E8%AF%95/" target="_blank" rel="external">《MVP的一种新的尝试》</a> ，然后我基于这种模式（activity作为presenters）做了一个可能问题还是很多的开发框架:<a href="https://github.com/Zane96/EasyMVP" target="_blank" rel="external">项目地址</a> 。并且根据这个框架在前几天结合rxjava,retrofit,dagger做了一个挺简单的demo app：<a href="https://github.com/Zane96/GithubQuery" target="_blank" rel="external">githubQuery</a> 。我在想做这套框架之后意外的发现一个大牛做的框架和我是一样的思想！都是借鉴了这篇文章:<a href="https://github.com/bboyfeiyu/android-tech-frontier/tree/master/androidweekly/%E4%B8%80%E7%A7%8D%E5%9C%A8android%E4%B8%AD%E5%AE%9E%E7%8E%B0MVP%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B0%E6%80%9D%E8%B7%AF" target="_blank" rel="external">《借鉴文章》</a> 。做的也是大同小异了，顺便也借鉴了不少，还借鉴了另一个学长把adapter和viewholder解耦的思想。</p>
<h2 id="传统mvp模式的不足">传统mvp模式的不足</h2><ol>
<li><p>如果把activity作为view，那么如果activity异常销毁，那么恢复数据就是个问题了。并且还必须要把presenter和view生命周期同步。如果使用bundle，这是就直接破坏了mvp的设计模式，因为这样难免会把v和m耦合在一起。而将activity作为presenter，可以很方便的使用bundle和model层的数据进行异常恢复。</p>
</li>
<li><p>context以及各种安卓系统服务，使用intent等等。</p>
</li>
<li><p>开始想用dagger进一步把v-p-m解耦，后来发现不用了，，</p>
<p>具体不足请看前言中的借鉴文章！</p>
</li>
</ol>
<h2 id="EasyMVP">EasyMVP</h2><h3 id="介绍">介绍</h3><p>   1.使用泛型来使view和presenter解耦，通过编译期间从子activity传递过来的view类型反射获得具体view类型。并且框架完成activity的视图渲染，并且提供同步activity生命周期的函数供开发者使用。</p>
<p>   2.默认使用butterknife作为view的依赖注入。</p>
<p>   3.adapter作为presenter，并且与viewholder完全解耦，viewholder归入view层。默认使用recycle view。（别再提listview了）</p>
<p>   <img src="/img/EasyMVP.png" alt="图解"></p>
<h3 id="BaseActivityPresenters">BaseActivityPresenters</h3>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivityPresenter</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">IView</span>&gt; <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> V v;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//通过注解获得对应的view的实例</span></span><br><span class="line">            v = getRootViewClass().newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//调用view层中生成根视图的函数</span></span><br><span class="line">        v.creatView(getLayoutInflater(), <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">//调用view层初始化控件的函数，这里默认使用butterkinfe了。</span></span><br><span class="line">        v.initView();</span><br><span class="line">      <span class="comment">//视图渲染</span></span><br><span class="line">        setContentView(v.getRootView());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//抛出跟onCreat()函数同步的函数给开发者</span></span><br><span class="line">        inCreat(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接触绑定</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        v.removeView();</span><br><span class="line">        v = <span class="keyword">null</span>;</span><br><span class="line">        inDestory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Class&lt;V&gt; <span class="title">getRootViewClass</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">inCreat</span><span class="params">(Bundle savedInstanceState)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">inDestory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inPause</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inRestart</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inStop</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inResume</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inStart</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        inStart();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code>我已经在代码里面添加了一些注释。<span class="keyword">*</span><span class="keyword">*</span>框架已经默认了使用butterkinfe<span class="keyword">*</span><span class="keyword">*</span>，要避免重复依赖。再来看view层的框架代码。这样做其实是可以看成是在抽出一个BaseActivity，把一些操作黑箱化。
</code></pre><h3 id="IView">IView</h3>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IView</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">creatView</span><span class="params">(LayoutInflater inflater, ViewGroup parent)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">View <span class="title">getRootView</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRootViewId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用butterkinfe的unbind()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeView</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>确定了几个<span class="built_in">view</span>代理层最基本的操作。
</code></pre><h3 id="BaseViewImpl">BaseViewImpl</h3>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 15/12/18.</span><br><span class="line"> * 将view加载的过程写在抽象类，做到代码复用。</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseViewImpl</span> <span class="keyword">implements</span> <span class="title">IView</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> View view;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> SparseArray&lt;View&gt; mViews = <span class="keyword">new</span> SparseArray&lt;View&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//根据activity传递过来的参数和具体view类传递过来的id生成根视图。</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">creatView</span><span class="params">(LayoutInflater inflater, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> resourceId = getRootViewId();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resourceId == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"rootview's id can't be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        view = inflater.inflate(resourceId, parent, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//这就是baseactivitypresenter中调用用来渲染试图的方法。</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> View <span class="title">getRootView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由子类去重写</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getRootViewId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加注解view方式</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ButterKnife.bind(<span class="keyword">this</span>, view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ButterKnife.unbind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="BaseListViewHolder">BaseListViewHolder</h3><p>   这个是可以和baseviewimpl对应的，是一个viewholder的抽象父类。用的同样的方法通过中间层做到view holder和adapter解耦。区别不是太大！</p>
<p>   <img src="/img/EasyMVP2.png" alt=""></p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 15/12/18.</span><br><span class="line"> * 这个中间的base层用来做到viewholder与adapter的解耦。</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseListViewHolderImpl</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">Object</span>&gt; <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseListViewHolderImpl</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(itemView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成viewholder的构造方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseListViewHolderImpl</span><span class="params">(ViewGroup parent, @LayoutRes <span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(LayoutInflater.from(parent.getContext()).inflate(res, parent, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(M data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T extends View&gt; T $(<span class="annotation">@IdRes</span> <span class="keyword">int</span> id) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) itemView.findViewById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>我继承了recycle <span class="keyword">view</span>的<span class="keyword">view</span> holder，并且暴露出来一个构造函数，相当于代理层的构造函数，然后函数里面调用了recycle <span class="keyword">view</span>中viewholder的构造方法，以此来生成最终的<span class="keyword">view</span> holder。

而<span class="keyword">M</span>则是recycle <span class="keyword">view</span>展示的model的数据类型。以此保证<span class="keyword">view</span> holder和adapter数据类型的一致。方便下面的操作。

setData()方法的设计有点像接口回调，在holder的子类里面实现这个函数，在adapter里面进行回调。
</code></pre><h3 id="BaseListAdapterPresenter">BaseListAdapterPresenter</h3><pre><code>我的这个框架的启蒙文章里面也说，适配器是可以作为presenter的。这个抽象类的主要任务就是调用具体holder子类的构造函数，并且传递数据给<span class="function"><span class="title">setData</span><span class="params">()</span></span>方法，形成接口回调。
</code></pre>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 15/12/18.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseListAdapterPresenter</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">Object</span>&gt; <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">BaseListViewHolderImpl</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Context mContext;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;M&gt; mDatas;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseListAdapterPresenter</span><span class="params">(Context mContext)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(mContext, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据具体adapter子类构造函数获得的数据去初始化这里的数据。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseListAdapterPresenter</span><span class="params">(Context mContext, List&lt;M&gt; mDatas)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = mContext;</span><br><span class="line">        <span class="keyword">this</span>.mDatas = mDatas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseListViewHolderImpl <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> OnCreatViewHolder(parent, viewType);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//给具体adapter子类去实现，在子类里面调用具体的holder构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> BaseListViewHolderImpl <span class="title">OnCreatViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> M <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDatas.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDatas.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="问题">问题</h1><p>   刚开始这样写完了之后，发现一个问题就是presenter里面难免会需要view层的控件。比如点击一个button实现页面跳转，首先跳转功能当然要写在presenter，这就是跟传统mvp不同的一点。然后我就在想如果把view的控件一个个的暴露给presenter，但是如果需求量一大后果不堪设想。。然后我就看到那个大牛的框架用一个方法解决了这个问题：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">protected</span> <span class="keyword">final</span> SparseArray&lt;View&gt; mViews = <span class="keyword">new</span> SparseArray&lt;View&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> &lt;T extends View&gt; <span class="function">T <span class="title">bindView</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        T view2 = (T) mViews.get(id);</span><br><span class="line">       <span class="keyword">if</span> (view2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">           view2 = $(id);</span><br><span class="line">           mViews.put(id, view2);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> view2;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">public</span> &lt;T extends View&gt; <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (T) bindView(id);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">protected</span> &lt;T extends View&gt; T $(<span class="annotation">@IdRes</span> <span class="keyword">int</span> id) &#123;</span><br><span class="line">       <span class="keyword">return</span> (T) view.findViewById(id);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露监听函数</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(View.OnClickListener listener, <span class="keyword">int</span>... ids)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (ids == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> id : ids) &#123;</span><br><span class="line">           get(id).setOnClickListener(listener);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<pre><code>他用了一个可变长度的数组来存储控件。首先你可以用<span class="function"><span class="title">get</span><span class="params">(int id)</span></span>方法或者$(int id)方法（建议就用<span class="function"><span class="title">get</span><span class="params">()</span></span>，因为不必重复去findview）去在presenter中获得控件，但是不到万不得已别这样做，不然就破坏了mvp的设计模式。再就是很佩服他的<span class="function"><span class="title">setOnClickListener</span><span class="params">(View.OnClickListener listener, int... ids)</span></span>方法。完美的解决了在presenter不获得控件还能完成监听这个问题。
</code></pre><hr>
<h2 id="使用">使用</h2><p>   简单demo：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 16/1/27.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainView2</span> <span class="keyword">extends</span> <span class="title">BaseViewImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Bind</span>(R.id.button)</span><br><span class="line">    Button button;</span><br><span class="line">    <span class="annotation">@Bind</span>(R.id.edit)</span><br><span class="line">    EditText edit;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRootViewId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R.layout.activity_2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String test)</span></span>&#123;</span><br><span class="line">        edit.setText(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   这是一个view，看到了，由于框架做了butterkinfe绑定，所以直接@Bind()！然后返回自己对应的xml文件id。</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 16/1/27.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity2</span> <span class="keyword">extends</span> <span class="title">BaseActivityPresenter</span>&lt;<span class="title">MainView2</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;MainView2&gt; <span class="title">getRootViewClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MainView2.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inCreat</span><span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        v.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                startActivity(<span class="keyword">new</span> Intent(MainActivity2.<span class="keyword">this</span>, MainActivity.class));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, R.id.button);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inDestory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   返回对应view的class，并且完成了一次点击button跳转页面。</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 15/12/20.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainListViewHolder</span> <span class="keyword">extends</span> <span class="title">BaseListViewHolderImpl</span>&lt;<span class="title">data</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    TextView mTextView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainListViewHolder</span><span class="params">(ViewGroup parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent, R.layout.listview_item_layout);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mTextView = $(R.id.item_text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(data data)</span> </span>&#123;</span><br><span class="line">        mTextView.setText(data.getDatas());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   viewholer中不能使用butterknife默认绑定，这个问题我还没想到办法怎么解决。。不过直接用$()函数也是不错的。看到重写了父类的抽象方法，而这个函数在adapter里面被回调。</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 15/12/20.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRecycleviewAdapter</span> <span class="keyword">extends</span> <span class="title">BaseListAdapterPresenter</span>&lt;<span class="title">data</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRecycleviewAdapter</span><span class="params">(Context mContext, List&lt;data&gt; datas)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mContext, datas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseListViewHolderImpl <span class="title">OnCreatViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MainListViewHolder(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(BaseListViewHolderImpl holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        holder.setData(getItem(position));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   调用了父类的构造函数，返回了具体holder子类。大家会发现我并没有把holder和adapter完全解耦。对，我只是把item和adapter解耦了。使item的逻辑由自己管理，并且将holder分离出来并入view层。这块是借鉴了学长一个库的经验：项目地址：<a href="https://github.com/Jude95/EasyRecyclerView" target="_blank" rel="external">EasyRecycleView</a></p>
<h1 id="总结">总结</h1><blockquote>
<p>这是我第一次去尝试写一个框架出来，并且借鉴了很多别人的思想。而且实践的次数不多，算是自己迈出的第一步吧，以后肯定会遇到越来越多的问题，但是很值得。突然发现我这么一个小小的框架都需要想很多问题，那些牛逼框架能设计出来真是不容易。</p>
</blockquote>
<p>   <strong>未经博主同意，不得转载该篇文章</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;p&gt;  用MVP模式开发安卓相信大家也应该不是很陌生了。各种各样的mvp开发模式，框架也是层出不穷。之前写过一篇&lt;a href=&quot;http://zane96.github.io/2015/12/06/MVP%E6%A8%A1%E5%BC%8
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>DI理解以及Dagger生成代码分析</title>
    <link href="http://yoursite.com/2016/01/22/DI%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8ADagger%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/22/DI理解以及Dagger生成代码分析/</id>
    <published>2016-01-22T14:34:03.000Z</published>
    <updated>2016-10-26T13:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>  依赖注入是我在安卓项目架构学习（dagger+mvp+retrofit+rxjava+eventbus）里面的又一大步。通过一天多的系统学习（看别人的项目源码，博客文章，自己看dagger的生成源码），差不多也可以去自己总结一下了。dagger2的用法网上太多教程了，我就不再描述了。这里我只总结依赖注入的概念，在项目架构中的作用以及部分最基础的生成源码个人分析。建议大家在学习dagger之前先去学习java注解和反射，因为dagger确实不好理解，如果有了注解基础学习起来会更轻松。</p>
<p>  以前看人家大牛的项目都有个inject包，以前想当然的以为就是个注解包。。也不懂里面的component和module包是干嘛的。现在想想，也又算一种进步吧！</p>
<p>  <strong>大家可以通过我这个练手app巩固dagger的用法</strong> :<a href="https://github.com/Zane96/GithubQuery" target="_blank" rel="external">githubQuery</a></p>
<h2 id="依赖注入？（DI_and_IOC）">依赖注入？（DI and IOC）</h2><blockquote>
<p>其实依赖注入也是为了模块<strong>解耦</strong>，你会发现一切一切，不论是mvp还是dagger都是为了模块解耦。dagger和mvp结合起来还可以做到把m-v-p之间进一步解耦。所谓耦合就是两个模块联系在了一起，什么意思呢？比如一个模块A里面new了另一个模块B的对象，这时候就说两个模块耦合在了一起，如果现在B模块的构造函数做了修改，那么你还需要去修改模块A里面的代码。而我们希望的是B无论怎么修改都不会影响模块A。（联系mvp模式，无论m层怎么修改，都不会影响v层）而依赖注入可以用两种方法来解决：</p>
</blockquote>
<p>1.传递依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  B b;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  或者传递给 B的更高层级的抽象层（面向接口编程的思想）。</p>
<p>2.注入依赖。（如dagger di框架）</p>
<blockquote>
<p>其实这种解决办法就叫做<strong>控制反转</strong>（ioc）。<strong>把添加依赖的权利给外部，自己不去主动添加依赖关系</strong></p>
<p>好像有人分不大清楚dagger和butterknife有啥区别。。其实区别很大，butterkinfe也是通过注解来实现依赖注入，不过他做的是view的依赖注入。而dagger做的是更高层次的模块之间的依赖注入。</p>
</blockquote>
<p>  话说以前还写了一个很简单的view依赖注入框架（用的反射），我记得我以前在github上面写的是依赖注入框架，后来赶紧改成了view依赖注入框架。。</p>
<h2 id="依赖注入器？">依赖注入器？</h2><blockquote>
<p>如果说用传递依赖的话，那么如果模块A需要模块B的大量对象，或者说依赖程度很高，那么传递函数里面的依赖参数将会很多。</p>
<p>而使用注入器可以极大的减少代码量，模块之间的依赖关系也会很清晰。把注入器看作项目的一个模块(inject)专门负责把某些模块注入到他的依赖中去。当然说这些你可能还是不能体会到它的好处，多去写写，看看人家的项目代码才能慢慢体会。（比如我把所有的基础配置以及application的context全部提供在applicaion的module，然后直接把这个module注入到baseactivity或者application中去，然后其他的activity module再去继承这个application module。一行代码就去注入很多的依赖！）</p>
</blockquote>
<h2 id="Dagger2">Dagger2</h2><blockquote>
<p>dagger2就是现在一个比较火的依赖注入器框架。它使用的预编译期间生成代码完成依赖，而不是用的反射。。都知道反射对手机应用开发影响是比较大的。我学习这个框架就把它想成了一个注射器，component是针管，module是注射瓶，里面的依赖对象是注入的药水，build方法是插进患者，inject方法的调用是推动活塞。这样形象的理解还是很容易理解的！！</p>
</blockquote>
<p>  dagger需要掌握的就是component, module, scope,  provides, singleton.</p>
<p>  下面来探讨部分生成源码吧。</p>
<hr>
<blockquote>
<p>描述：我现在有两个medule,并且其中一个component依赖另一个component。代码如下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 16/1/21.</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityModule</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function">UserModel <span class="title">provideUserModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserModel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityModule2</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function">UserModelTwo <span class="title">provideUserModelTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserModelTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Component</span>(modules = ActivityModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActivityComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">//void inject(Activity activity);</span></span><br><span class="line">    <span class="function">UserModel <span class="title">userModel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Component</span>(dependencies = ActivityComponent.class, modules = ActivityModule2.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActivityComponent2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个model/bean代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 16/1/21.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"xuzhi"</span>;</span><br><span class="line">    <span class="keyword">private</span> String age = <span class="string">"20"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModelTwo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phone = <span class="string">"1888"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在activity中的注入代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">activityComponent = DaggerActivityComponent</span><br><span class="line">                                    .builder()</span><br><span class="line">                                    .activityModule(<span class="keyword">new</span> ActivityModule())</span><br><span class="line">                                    .build();</span><br><span class="line">activityComponent2 = DaggerActivityComponent2</span><br><span class="line">                                     .builder()</span><br><span class="line">                                     .activityComponent(activityComponent)</span><br><span class="line">                                     .activityModule2(<span class="keyword">new</span> ActivityModule2())</span><br><span class="line">                                     .build();</span><br><span class="line">activityComponent2.inject(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们都知道，编译之后dagger框架会自动给我们生成以dagger+xxxcomponent为名的类。如我的代码就是生成了DaggerActivityComponent类，并且通过一系列的方法调用最终构建成功。看过生成代码的人会感觉他用的就是包装器模式！我们首先来看DaggerActivityComponent的builder()方法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Generated</span>(<span class="string">"dagger.internal.codegen.ComponentProcessor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerActivityComponent</span> <span class="keyword">implements</span> <span class="title">ActivityComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Provider&lt;UserModel&gt; provideUserModelProvider;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerActivityComponent</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</span><br><span class="line">    initialize(builder);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>  可以看到生成了一个Provider<usermodel> provideUserModelProvider;，而在这个组件所对应的模块里面我们提供了user model的对象。DaggerActivityComponent的构造器先不管。一步步来，我们看到builder()方法return了一个Builder类型的对象，往下看你就会看到Builder这个静态内部类！代码如下：</usermodel></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ActivityModule activityModule;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActivityComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (activityModule == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.activityModule = <span class="keyword">new</span> ActivityModule();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DaggerActivityComponent(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">activityModule</span><span class="params">(ActivityModule activityModule)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (activityModule == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"activityModule"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.activityModule = activityModule;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>  注入代码中，我们紧接着调用了activityModule(ActivityModule activityModule)方法。我们看到因为在ActivityComponent中我们用@component添加了ActivityModule。所以这里生成了这样一个方法来让你传递一个对象进来。之后我们调用了build()方法，这个方法里面调用了DaggerActivityComponent类的构造方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DaggerActivityComponent</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</span><br><span class="line">    initialize(builder);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>  这里也没啥看的，继续看initialize(builder);方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.provideUserModelProvider =     ActivityModule_ProvideUserModelFactory.create(builder.activityModule);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>  这里有个新类，叫做xxxxFactory，这个类很重要，点进去继续看creat方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Generated</span>(<span class="string">"dagger.internal.codegen.ComponentProcessor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityModule_ProvideUserModelFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">UserModel</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ActivityModule module;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ActivityModule_ProvideUserModelFactory</span><span class="params">(ActivityModule module)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> module != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.module = module;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserModel <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserModel provided = module.provideUserModel();</span><br><span class="line">    <span class="keyword">if</span> (provided == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Cannot return null from a non-@Nullable @Provides method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> provided;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Factory&lt;UserModel&gt; <span class="title">create</span><span class="params">(ActivityModule module)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActivityModule_ProvideUserModelFactory(module);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  很简单，就是把我们的ActivityModule存在了这个类里面，并提供一个get方法，这个get方法之后会用到。</p>
<p>  DaggerActivityComponent类的代码我们就看完了，很简单，因为这个针头并没有提供inject方法哈哈，而是多重依赖给了ActivityComponent2.接下来看DaggerActivityComponent2的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Generated</span>(<span class="string">"dagger.internal.codegen.ComponentProcessor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerActivityComponent2</span> <span class="keyword">implements</span> <span class="title">ActivityComponent2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Provider&lt;UserModel&gt; userModelProvider;</span><br><span class="line">  <span class="keyword">private</span> Provider&lt;UserModelTwo&gt; provideUserModelTwoProvider;</span><br><span class="line">  <span class="keyword">private</span> MembersInjector&lt;MainActivity&gt; mainActivityMembersInjector;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerActivityComponent2</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</span><br><span class="line">    initialize(builder);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>  第一个module中的usermodel也被注入到了第二个module中！接着看Builder类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ActivityModule2 activityModule2;</span><br><span class="line">    <span class="keyword">private</span> ActivityComponent activityComponent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActivityComponent2 <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (activityModule2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.activityModule2 = <span class="keyword">new</span> ActivityModule2();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (activityComponent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"activityComponent must be set"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DaggerActivityComponent2(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">activityModule2</span><span class="params">(ActivityModule2 activityModule2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (activityModule2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"activityModule2"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.activityModule2 = activityModule2;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">activityComponent</span><span class="params">(ActivityComponent activityComponent)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (activityComponent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"activityComponent"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.activityComponent = activityComponent;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>  ActivityModule2 activityModule2，ActivityComponent activityComponent;都是这个类的静态变量，因为一个是依赖一个是对应的 module。然后你可以自己看看注入代码，我们确实是分别调用了activityComponent(ActivityComponent activityComponent)，activityModule2(ActivityModule2 activityModule2)之后才去调用build()；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userModelProvider = <span class="keyword">new</span> Factory&lt;UserModel&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> ActivityComponent activityComponent = builder.activityComponent;</span><br><span class="line">      <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> UserModel <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserModel provided = activityComponent.userModel();</span><br><span class="line">        <span class="keyword">if</span> (provided == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Cannot return null from a non-@Nullable component method"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> provided;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.provideUserModelTwoProvider = ActivityModule2_ProvideUserModelTwoFactory.create(builder.activityModule2);</span><br><span class="line">    <span class="keyword">this</span>.mainActivityMembersInjector = MainActivity_MembersInjector.create((MembersInjector) MembersInjectors.noOp(), userModelProvider, provideUserModelTwoProvider);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>  最上面有一段代码，其用意相当于重新构建一个xxxxFactory类。你可以看到之前那个xxxFactory类是实现了Factory<xxx>接口，而这里则是用匿名内部类做到了，为什么要这么做呢，我认为是因为这个变量是继承过来的，所以不应该再去重复creat而是通过activitycomponent来调用userModel()方法来获得。然后我们就把两个成员变量都初始化了！之后再来看注入，我们点到MainActivity_MembersInjector.create((MembersInjector) MembersInjectors.noOp(), userModelProvider, provideUserModelTwoProvider);方法去看：</xxx></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Generated</span>(<span class="string">"dagger.internal.codegen.ComponentProcessor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity_MembersInjector</span> <span class="keyword">implements</span> <span class="title">MembersInjector</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MembersInjector&lt;AppCompatActivity&gt; supertypeInjector;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Provider&lt;UserModel&gt; modelProvider;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Provider&lt;UserModelTwo&gt; model2Provider;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_MembersInjector</span><span class="params">(MembersInjector&lt;AppCompatActivity&gt; supertypeInjector, Provider&lt;UserModel&gt; modelProvider, Provider&lt;UserModelTwo&gt; model2Provider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> supertypeInjector != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.supertypeInjector = supertypeInjector;</span><br><span class="line">    <span class="keyword">assert</span> modelProvider != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.modelProvider = modelProvider;</span><br><span class="line">    <span class="keyword">assert</span> model2Provider != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.model2Provider = model2Provider;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectMembers</span><span class="params">(MainActivity instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Cannot inject members into a null reference"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    supertypeInjector.injectMembers(instance);</span><br><span class="line">    instance.model = modelProvider.get();</span><br><span class="line">    instance.model2 = model2Provider.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MembersInjector&lt;MainActivity&gt; <span class="title">create</span><span class="params">(MembersInjector&lt;AppCompatActivity&gt; supertypeInjector, Provider&lt;UserModel&gt; modelProvider, Provider&lt;UserModelTwo&gt; model2Provider)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MainActivity_MembersInjector(supertypeInjector, modelProvider, model2Provider);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  很清楚了，也是一种包装器模式。我们可以类比，每一个被注入的类都会生成一个xxx_MembersInject类。看到我们把两个Factory对象都传进来了，并且调用了get方法来获得我们需要注入的依赖对象。大功告成，最后看DaggerActivityComponent2里面的最后一个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity activity)</span> </span>&#123;</span><br><span class="line">    mainActivityMembersInjector.injectMembers(activity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>  对！就是我们MainActivity里面调用的inject()方法。对应上一份源码看，懂了吧！这就是注入过程，所以我把inject()方法的调用比做活塞的推动。</p>
<hr>
<blockquote>
<p>所以看了这么多，其实就是想多了解一下dagger如何运作，我们的调用代码tmd为什么要这么写。嗯，就是这样！之前学这个也是越看越烦啦，后来慢慢的总结一下也是极好的。下面就准备开始用mvp+dagger2+rxjava+retrofit来搞点事情了。并且我还不准备用我自己的mvp框架，感觉写的太渣了，分分钟爆炸的节奏。。</p>
</blockquote>
<p><strong>未经博主同意，不得转载该篇文章</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;p&gt;  依赖注入是我在安卓项目架构学习（dagger+mvp+retrofit+rxjava+eventbus）里面的又一大步。通过一天多的系统学习（看别人的项目源码，博客文章，自己看dagger的生成源码），差不多也可以去自己总结一下了。
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>大二上学期总结</title>
    <link href="http://yoursite.com/2016/01/16/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/01/16/大二上学期总结/</id>
    <published>2016-01-16T15:38:15.000Z</published>
    <updated>2016-10-26T13:53:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写一点东西来结束大二上学期">写一点东西来结束大二上学期</h1><p>  感觉昨天还是在高考，今天就大二上结束了。岁月如梭，时不我待。</p>
<p>  刚回家一天多，想写点东西总结一下大二上学期。</p>
<h2 id="生活">生活</h2><blockquote>
<p> 程序员嘛，也不要整天张口闭口都是技术，聊聊生活也是挺好的。大二换了寝室楼栋，终于摆脱了坑爹的五栋。18栋还是挺棒的。由于18栋时4人间，所以脖子和老蒋没和我们在一起住了，我，辉儿子，薛撸撸，以及新加入我们的王叔叔住在一起了，组成了重邮319新生代F4。朕作为319之父，很幸运能和国舅和儿子们住在一起，学习生活虽然烦累，但在寝室还是总有些乐趣聊以自慰。</p>
<p>  这学期主要吃兴业苑的食堂。反正吃多了，怎么都觉得难吃，一回家妈妈就说我瘦了。在大学很难睡着晚上，莫名其妙的晚上喜欢亢奋（有时候是因为睡前还是想技术的问题）。反正学校过的当然不如家里了。</p>
<p>  其实要说生活还是很枯燥的，每天就是寝室，教室，工作室三点一线的生活，和高中也差不多了，这学期在大学每天在工作室待到晚上11点才到寝室（周末不休息），比高中回得还迟。然而枯燥却很有意义。</p>
<p>  辉儿子每天都在寝室锻炼身体，之前有去跑跑步，主要每天坐着太累了。想想确实得锻炼一下身体了，不然夏天穿衣服不好看，  下学期争取早点回寝室，洗澡锻炼两不误。</p>
<p>  直接把考试的学习方面也在这里总结一下吧，这学期学的运筹学和概率论确实在开头给我造成了不小麻烦，上课也听，但是我每天确实是没工夫记这些玩意，平时我也从来不关注我这些学科，都在搞自己的技术活，还好后来期末复习拼命弄了两周，及格应该没问题了。java考试和教学真的无力吐槽了。。对这种教育现状心累</p>
<p>  这学期没有了学生会这些，也没有去下山通宵了，毕竟这种事情大一做做就可以了，大二了，该踏实点了。这学期有一次班聚，喝白酒吐了一晚上，所以之后再也没有碰酒了，酒量也不行，以后能不碰坚决不碰，啤酒在内。</p>
</blockquote>
<h2 id="技术">技术</h2><blockquote>
<p>  这学期搬到了学校的蓝山工作室，环境确实好多了啊，挺温馨的，并且满爷凯爷也还在，也没觉得很陌生。大家一起坐着敲代码还是很happy的。工作室也有很多次技术交流会包括大四实习回来的学长学姐介绍经验和新技术。感觉，嗯，挺棒的。</p>
<p>  这学期换了个电脑，终于摆脱了windows和渣渣电脑的困扰，苹果大法好！开发效率大大提升。然后在工作室又给电脑配了一个显示屏，一个人一个办公桌，爽到嗨起哈哈。</p>
<p>  我在这学期开始了写博客，通玩github，看知乎（技术大牛太多，学习圣地！），看技术周报，写周报。</p>
<p>  这学期的我觉得时间主要分为两大块，一个是跟凯爷一起合作的一个项目（还是拿了点小奖励哈哈）一个是重学暑假学的一些东西。（自定义view，rxjava, retrofit, mvp,mvvm，view绘制,touch system，事件分发机制,handler实现原理，asynctask源码等等等等）。当然，我说的主要是安卓方面的。。暑假学一遍这些东西如果说是一次入门，这学期算是开始实践吧，写了很多的demo放在github上，博客总结。也有尝试去看看大牛写的关于安卓（系统架构）更深层次东西。mvp正在尝试去写一个开发框架，刚迈出了第一步，项目地址在我的github上，当然我参考了很多大牛的框架。mvvm这个开发模式伴随着data-banding的出现，不知道以后又会给安卓带来多大的改变，不过先做着吧，反正没害处，这也是我第一次尝试去做一个框架（当然很low）。这学期把python基础看了些，额，后来忙别的就落下进度了。这学期开始系统看看各位大牛的博客，安卓的学习当然主要是这些，还有很多琐碎的学习也记不大清楚了。</p>
<p>  确实这学期在做项目的时候会发现很多以前不曾想过的问题，暴露出来的问题也很多，安卓坑，但有时候我还是在自己坑自己，很多血的教训才是第一次受到，以后会更多。</p>
<p>  这学期根据自己的长远目标，开始进军数据结构和设计模式（一个让我觉得以前我写的代码大部分都是屎的学问）。看完了《大话数据结构》和《head first设计模式》，以及一点《深入理解jvm》和《effective java》，复习了一点《java核心技术》。数据结构我也只是看了书，准备去过一遍大学mooc的视频，主要是给我实践的机会几乎没有。安卓的话还是不急着去大量做开发，基础打好了再去做别的才是我选择的路。在请教了很多学长学姐以及我的小舅舅之后，我还是决定把oc基础的学习延后，先学js基础和web app开发框架。当然了，安卓依旧是我的主心骨了。这也算是我之后的打算了。</p>
<p>  深入学习java就准备从jvm和《effective java》开始了，已经进军jvm了,接下来是linux，java大法好，但是c草，当然还是要学的！苦逼</p>
</blockquote>
<hr>
<p><strong>始终记住和别人的差距，然后想办法弥补，大二上每天的生活很累但是很值得，大二下继续加油</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写一点东西来结束大二上学期&quot;&gt;写一点东西来结束大二上学期&lt;/h1&gt;&lt;p&gt;  感觉昨天还是在高考，今天就大二上结束了。岁月如梭，时不我待。&lt;/p&gt;
&lt;p&gt;  刚回家一天多，想写点东西总结一下大二上学期。&lt;/p&gt;
&lt;h2 id=&quot;生活&quot;&gt;生活&lt;/h2&gt;&lt;blockqu
    
    </summary>
    
      <category term="随记" scheme="http://yoursite.com/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>《深入理解jvm》读书笔记——java虚拟机内存区域</title>
    <link href="http://yoursite.com/2016/01/11/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2016/01/11/《深入理解jvm》读书笔记——java虚拟机内存区域/</id>
    <published>2016-01-11T10:46:11.000Z</published>
    <updated>2016-10-26T13:52:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java的虚拟机内存区域">java的虚拟机内存区域</h1><h2 id="运行时数据区">运行时数据区</h2><p>1.方法区（method area）</p>
<p>2.堆（heap）</p>
<p>3.虚拟机栈（VM Stack）</p>
<p>4.本地方法栈（native method stack）</p>
<p>5.程序计数器（program counter register）</p>
<hr>
<h3 id="程序计数器">程序计数器</h3><blockquote>
<p>  这是运行区内存里面占的比较少的一块内存。它是用来标记当前虚拟机运行的字节码的行号。字节码解释器就是通过改变这个计数器来选取下一条字节码来执行。</p>
</blockquote>
<p><strong>线程恢复跟这个也有关系。当线程恢复之后，这个计数器标识的行号就是这个线程断开的位置记录，每一个线程独自拥有一个计数器</strong></p>
<p><strong>如果虚拟机现在执行的是java方法，那么计数器记录的是正在执行的虚拟机字节码指令位置，如果执行的是native方法，那么不记录。</strong></p>
<blockquote>
<p>本地方法：Java不是完美的，Java的不足除了体现在运行速度上要比传统的C++慢许多之外，Java无法直接访问到操作系统底层（如系统硬件等)，为此Java使用native方法来扩展Java程序的功能。　可以将native方法比作Java程序同Ｃ程序的接口，其实现步骤：</p>
</blockquote>
<p>　　１、在Java中声明native()方法，然后编译；</p>
<p>　　２、用javah产生一个.h文件；</p>
<p>　　３、写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）；</p>
<p>　　４、将第三步的.cpp文件编译成动态链接库文件；</p>
<p>  ５、在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。</p>
<h3 id="java虚拟机栈">java虚拟机栈</h3><blockquote>
<p>  java虚拟机栈是线程私有。用来描述java方法的执行。每个方法执行，都会在栈里面生成一个栈帧，用于存储局部变量，操作数栈，动态链接，方法出口等。</p>
</blockquote>
<p>  局部变量表：存编译期就可知的基本数据类型和对象引用（看作指针吧）。</p>
<p>  <strong>局部变量表的大小在编译期间就可以确定大小，并且在运行期间不会改变这一块内存的大小。</strong></p>
<blockquote>
<p>定义了两个异常</p>
</blockquote>
<p>1.stackoverflow:如果线程请求的栈深度大于了虚拟机的规定深度。</p>
<p>2.oom:如果虚拟机栈在动态扩展的时候，无法申请到足够的内存。</p>
<h3 id="本地方法栈">本地方法栈</h3><blockquote>
<p>  用来描述native方法的执行，与上着类似。java的本地方法我好像还是在这里第一次遇到唉。。以后再深究。这块内存同样定义了两种异常。</p>
</blockquote>
<h3 id="java堆">java堆</h3><blockquote>
<p>  这块倒是在没学习虚拟机之前就了解过。这是运行数据内存中最大的一块内存，同样也是gc重点关注的地方。这块就是用来存对象实例的。线程共享！</p>
</blockquote>
<p>  <strong>可以通过-Xmx, -Xms来控制这一块的内存大小，哈哈，终于能理解当初在windows下运行android studio为啥要加这个声明才能建立工程了</strong></p>
<p>  同样的，如果内存不够用可并且不能扩展，那么就会报oom。</p>
<h3 id="方法区">方法区</h3><blockquote>
<p>  我理解的是这一块就是来存储类信息的。包括类的静态变量，常量，编译后的代码。同样也是线程共享的。</p>
</blockquote>
<p>  <strong>在现在的虚拟机设计下，方法区不等同于永久带（我理解的是gc永远不会去回收内存的区域）</strong></p>
<h3 id="运行常量池">运行常量池</h3><blockquote>
<p>  常量池时包含在方法区的，用于存放编译期间生成的各种数据（class文件的常量池）。但是这个常量池不是静态的，是动态的，是可以在运行的时候存入新的数据。根据这个特性，String.intern()方法运用的很多。</p>
</blockquote>
<p>  <strong>简单补充：String.intern()方法，这个方法会先判断常量池里面有没有这个string的对象，如果有的话会直接返回这个对象的引用，而不会再去生成一个新的对象，所以字符串不可变这个特性也支持了这种做法，如果不存在才会去生成一个新的对象然后再返回引用。String s = “s”;和String s = new String(“s”);的区别在于第一种会直接把这个数据对象放入常量池儿第二种会像生成一个对象一样把数据对象放入java堆中。所以尽量使用第一种，并且字符串拼接也要使用StringBuilder或者StringBuffer，避免＋，因为这样每＋一次就会生成一个StringBuffer对象，造成大量的空间浪费。</strong></p>
<p>  如果这个区域的内存不够的话也会造成oom。</p>
<hr>
<h2 id="java对象的创建">java对象的创建</h2><blockquote>
<p>  对象的创建在我们程序员的眼里就是简单的new，但是这里说的是jvm内部时如何实现的。首先虚拟机遇到一个new指令之后，会去常量池里面（方法区里面的）看这个有没有这种符号引用的类类型（类信息），如果没有的话要去加载类信息，如果有的话就去java堆划出一块内存区域。</p>
<p>  接下来是对象的设置，这里要涉及对象头。对象头一般分为两块（数组对象时三块），一块用来存储对象的元信息，hash码等等一块用来确定这个对象是哪个类型的对象。数组对象会多出一块来存储大小。</p>
</blockquote>
<p>  <strong>这在虚拟机的眼里已经完成了独享的创建，但是还差对象的初始化哈，接下来就是对象的init</strong></p>
<h2 id="java对象的访问">java对象的访问</h2><blockquote>
<p>  我们都知道对象实例在java堆，引用存储在虚拟机栈。要通过引用来操作对象实例，得去访问它</p>
</blockquote>
<p>  1.句柄访问法：</p>
<p>  <strong>这种方法相当于是把对象实例和引用解耦了（解耦无处不在！），堆里面有一个对象实例有一个句柄池来指向对象实例和对象类型数据（方法区里面的类信息）的地址，然后引用时指向这个句柄池。也就是说引用通过句柄池来访问对象实例。这样做就是有解耦的好处啦！如果对象实例的地址变了，引用不用变，只需要修改句柄池的数据就好了。</strong></p>
<p>  2.直接指针法：</p>
<p>  <strong>这种方法就是直接引用指向对象实例的地址啦。这种方法访问速度更快！</strong></p>
<p>  <strong>未经博主同意，不得转载该篇文章</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java的虚拟机内存区域&quot;&gt;java的虚拟机内存区域&lt;/h1&gt;&lt;h2 id=&quot;运行时数据区&quot;&gt;运行时数据区&lt;/h2&gt;&lt;p&gt;1.方法区（method area）&lt;/p&gt;
&lt;p&gt;2.堆（heap）&lt;/p&gt;
&lt;p&gt;3.虚拟机栈（VM Stack）&lt;/p&gt;
&lt;p&gt;4.本地
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Context学习笔记</title>
    <link href="http://yoursite.com/2015/12/15/Context%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2015/12/15/Context学习笔记/</id>
    <published>2015-12-15T12:30:43.000Z</published>
    <updated>2016-10-26T13:52:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Context—上下文环境。">Context—上下文环境。</h1><blockquote>
<p>android代码与java代码的最大差别就是，android的组件必须通过context来创建实例。context是安卓的一个类，四大组件包括application类的最终父类都是context类。它是维持安卓各种组件能够正常工作的一个核心类。</p>
</blockquote>
<p><strong>context有两个子类一个是ContextWrapper：上下文功能封装类,ContextImpl：上下文功能的实现类。</strong></p>
<blockquote>
<p>context可以用来启动新的ativity， 弹出toast， 启动service， 发送广播， 操作数据库等等。不同的context的能力是不同的。比如弹出一个Dialog必须依赖在一个activity上面，所以必须通过activity的context才能来弹出一个Dialog。</p>
</blockquote>
<p><strong>一个application类或者他的子类对象本身就是一个context。</strong></p>
<blockquote>
<p>getApplication()；获得application对象实例。getApplicationContext();同样也是返回application实例，但是这个返回的实例作用域更大。getBaseApplication()；用于返回ContextImpl类的对象（实现类）。activity, application, service都是做了一层接口封装，所有的实现都是在ContextImpl中。</p>
</blockquote>
<p><strong>application（或者其他），ContextWrapper与ContextImpl三者实际上是有一种类适配器的设计模式联系在一起的。application是调用适配器，ContextWrapper是适配器，ContextImpl是被转换者。application调用getResource(), registerBroadcast()等等方法，实际上在适配器里面转换成了调用ContextImpl中对应的方法。application并不知道他的实现，也不用知道，做到了解耦。</strong></p>
<p>自定义application类的最佳实践：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;  </span><br><span class="line"><span class="number">2</span>.       </span><br><span class="line"><span class="number">3</span>.     <span class="keyword">private</span> <span class="keyword">static</span> MyApplication app;  </span><br><span class="line"><span class="number">4</span>.       </span><br><span class="line"><span class="number">5</span>.     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyApplication <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="number">6</span>.         <span class="keyword">return</span> app;  </span><br><span class="line"><span class="number">7</span>.     &#125;  </span><br><span class="line"><span class="number">8</span>.       </span><br><span class="line"><span class="number">9</span>.     <span class="annotation">@Override</span>  </span><br><span class="line"><span class="number">10</span>.     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="number">11</span>.         <span class="keyword">super</span>.onCreate();  </span><br><span class="line"><span class="number">12</span>.         app = <span class="keyword">this</span>;  </span><br><span class="line"><span class="number">13</span>.     &#125;  </span><br><span class="line"><span class="number">14</span>.       </span><br><span class="line"><span class="number">15</span>. &#125;</span><br></pre></td></tr></table></figure>
<p><strong>applcation本身就是一个单例了，不用再去做单例模式了。也不应该去new，因为它不是一个java类。application的实例除了不能start an activity和show a dialog其他都可以。</strong></p>
<blockquote>
<p>context造成的内存泄漏。在单例模式或者引用静态变量的时候，尽量避免用activity的context,因为静态变量的生命周期是整个应用。如果一个activity销毁了，那么他的context不能被销毁就造成了内存泄漏。所以尽量用application来代替。</p>
</blockquote>
<p><strong>未经博主同意，不得转载该篇文章</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Context—上下文环境。&quot;&gt;Context—上下文环境。&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;android代码与java代码的最大差别就是，android的组件必须通过context来创建实例。context是安卓的一个类，四大组件包括applicati
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>Handler</title>
    <link href="http://yoursite.com/2015/12/15/Handler/"/>
    <id>http://yoursite.com/2015/12/15/Handler/</id>
    <published>2015-12-15T11:57:16.000Z</published>
    <updated>2016-10-26T13:52:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>Handler是安卓内置的消息处理机制。虽然后来安卓又封装了handler推出了AsyncTask，并且现在又出了很多异步消息处理机制比如EventBus, RxJava等等。Eventbus内部都是使用了handler了的。所以我觉得学习这个还是很重要的。这篇文章是我转自一个朋友的博客,在这个基础上我做了一点补充,最后配上一张我做的图解。原文<a href="http://kermit95.github.io/2015/08/28/handler%E6%80%BB%E7%BB%93/" target="_blank" rel="external">王凯的博客</a></p>
<hr>
<h3 id="概述">概述</h3><p> Handler是android用来更新UI，处理消息的机制。</p>
<h3 id="使用线程和Handler更新UI">使用线程和Handler更新UI</h3><ul>
<li>方法一</li>
</ul>
<p> 新建handler对象，并覆写handleMessage()，在主线程中开启一个子线程，进行耗时操作（比如下载图片），得到图片之后，利用handler的sendMessage()，将图片发送给handler，在handleMessage()中进行UI的更新。发送时有两种方式，一种是’handler.sendMessage()’，一种是’message.sendToTarge()’。</p>
<ul>
<li>方法二</li>
</ul>
<p> 用view的post方法，post方法接收一个runnable对象，该方法将这个runnable对象发送至主线程执行。</p>
<h3 id="原理">原理</h3><p> 上述方法都是从非UI线程发送消息到UI线程，通知UI线程进行界面更新。</p>
<p> Android使用消息机制实现线程间的通信，线程通过Looper建立自己的消息循环，MessageQueue是FIFO的消息队列，Looper负责从MessageQueue中取出消息，并且分发到消息指定目标Handler对象。Handler对象绑定到线程的局部变量Looper，封装了发送消息和处理消息的接口。</p>
<h3 id="实现一次线程通信的流程">实现一次线程通信的流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        Log.i(<span class="string">"Test"</span>, <span class="string">"CustomThread recive message "</span> + (String)msg.obj);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主线程中开启子线程，然后发送消息给目标handler。</p>
<h4 id="Looper">Looper</h4><p> 要想理解子线程中发生了什么必须先理解Looper。在Looper.prepare()中，Looper被设置成了线程的局部变量’ThreadLocal.set(new Looper(…))’，并且在Looper的构造函数里获取了当前线程和一个消息队列。可以说Looper在哪个线程，handler的handleMessage()方法就在哪个线程执行，因为handleMessage()方法是在Loop.loop()方法中执行的。</p>
<h6 id="ThreadLocal">ThreadLocal</h6><p> TreadLocal是为了解决线程安全的一个方案，与之对应的还有synchronized。但是本质区别是synchronized是为了数据共享，ThreadLocal是为了数据隔离。在android的handler机制中，TreadLocal维护了一个Looper对象，也就是说每个线程只能有各自的Looper，不可以共享。TreadLocal通过set和get方法存取维护的变量（这里是Looper）。关于ThreadLocal就说到这里。<strong>补充：多线程如果要访问共享数据的话，是需要做到同步的。共享数据是有很大风险的，比如不正当的操作导致所有的线程阻塞。而ThreadLocal则是给每个的线程提供了一个初始变量值，保证一个线程对应一个变量，这个变量称为局部变量。在线程中你是可以通过get来获得你set的局部变量的。</strong></p>
<h4 id="Handler">Handler</h4><p> Handler中获得到了<strong>线程局部变量Looper</strong>的消息队列。为什么Handler要持有消息队列呢，因为在发送消息环节，Handler对象需要将消息对象放入消息队列中。分析Handler，就必须明确Looper所属的线程，如果我们是在主线程创建Handler，那么Looper就是主线程的’MainLooper’，但是Looper的创建和loop方法的调用都在底层执行了。每个Handler获取消息队列的途径是，每个handler都和一个Looper绑定，每个Looper都持有一个消息队列，这样每个handler就可以获取一个消息队列。</p>
<p>关于Handler的构造方法：</p>
<ul>
<li>可以无参数</li>
<li>可以传入一个callback，用于截断消息向handleMessage()传入</li>
<li>可以传入一个Looper对象</li>
</ul>
<h4 id="loop()方法">loop()方法</h4><p> loop()方法用来从消息队列中取得方法。loop()方法所做的事：</p>
<ul>
<li>获取Looper，从而获得消息队列</li>
<li>从消息队列中取出消息，并通过消息对象中的”target”分发消息。（这里的target是一个Handler对象）</li>
<li>将分发后的消息回收</li>
</ul>
<h4 id="HandlerThread">HandlerThread</h4><p> 通过这个Thread可以稳定的获取Looper，可以通过’Hander handler = new Handler(handlerThread.getLooper())’的方式得到一个handler。而这个handler是和handlerthread绑定的，这样就可以在handlerthread线程处理消息。</p>
<p> 一般说来，都是在主线程建立handler对象，Looper是getMainLooper()，所以handleMessage都是在UI线程调用。handlerthread的目的就是能在非UI线程处理消息。</p>
<h4 id="总结">总结</h4><p> Looper持有：currentThread, messagequeue, threadlocal。在Looper.prepare()方法中，threadlocal存储了一个Looper对象，并通过Looper的构造方法，使这个looper对象获得了当前线程的实例(Thread.currentThread())，从而实现了looper和线程的关联(底层实现，是将looper作为threadlocal的value，然后将threadlocal的value赋值给currentThread的value)，所以可以将这个方法看作将所在线程变成循环线程(looper线程)的标识；在Looper.loop()中，通过myLooper()得到threadlocal中的looper，也就是所在线程的looper,进行消息分发。</p>
<p> Message持有：target(一个handler)，message有obtain方法，有的方法可能少用，但是大多和target有关，即message可以和某个handler进行绑定。但是大多时候我们不会改变message的target，事实上我们根本就不需要改变，在handler的sendMessage方法中，最终调用的是这个方法，将message放入自己持有messagequeue中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">  msg.target = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是把发送消息的Handler设置成了message的target(目标，就是这个msg将被这个target处理)。而常用的sendToTarget()方法必须设置target才能发送消息，如下代码会报空指针，必须先message.setTarget()。或者使用handler.send….方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"hi~~"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  setContentView(R.layout.activity_main);</span><br><span class="line">  Message message = Message.obtain();</span><br><span class="line">  message.sendToTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Handler持有：messagequeue, callback。在Handler的构造方法中，获得当前线程的looper的messageqeue(这也是为什么要先Looper.prepare()后new Handler()的原因，必须先要有looper才会有messagequeue)，至于callback:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##图解：<br><img src="/img/Handler.png" alt="图解"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;p&gt;Handler是安卓内置的消息处理机制。虽然后来安卓又封装了handler推出了AsyncTask，并且现在又出了很多异步消息处理机制比如EventBus, RxJava等等。Eventbus内部都是使用了handler了的。所以我觉得
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>MVP模式的一种新尝试</title>
    <link href="http://yoursite.com/2015/12/06/MVP%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B0%E5%B0%9D%E8%AF%95/"/>
    <id>http://yoursite.com/2015/12/06/MVP模式的一种新尝试/</id>
    <published>2015-12-06T11:54:22.000Z</published>
    <updated>2016-10-26T13:52:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>  在暑假的时候学习了一遍mvp开发模式在android中的运用。那个时候学的时候确实觉得mvp模式做安卓开发特别清晰，代码模块分的特别清楚。但是在自己写demo的时候还是把自己有点绕晕了。因为mvp模式运用了大量的接口（面向接口编程）来实现view和model层的解耦。那时候甚至连设计模式都没看，所以一下子接触这种抽象的设计模式有点不适应。虽然说google的data-binding的不断完善会导致安卓上面mvvm模式越来越火，但是我觉得设计模式嘛，学习一下没有坏处，可以提升自己的理解力。这篇博客主要讲一种mvp的一种新尝试（将activity, fragment, adapter作为presenter）。</p>
<h2 id="MVP">MVP</h2><blockquote>
<p>  mvp模式与mvc模式最大的差别就是，它将view层跟model实现完全解耦。所有的数据交互都在presenter层中。view,model和presenter的交互通过接口，view和model的交互通过presenter。解耦的好处就是视图层和数据层两者互不影响，所有的逻辑都在presenter中，他作为一个中间层可以给多个view来使用。完全通过接口来解耦可以提高代码维护度。</p>
<p>  而mvc模式则是视图层可以通过control与数据层交互也可以直接跳过control和数据层直接交互。这样大多数时候会在view层里面new出model／bean的对象来。这样就把两者耦合在了一起。</p>
</blockquote>
<h3 id="传统mvp">传统mvp</h3><blockquote>
<p>  传统的mvp模式是将activity或者fragment作为view层，将所有的逻辑代码抽出到presenter（一个java类）。这是我暑假写的一个demo源码 <a href="https://github.com/Zane96/mvp-test-login" target="_blank" rel="external">传统mvp demo</a> 。</p>
</blockquote>
<p><img src="/img/mvp1.png" alt=""></p>
<blockquote>
<p>可以通过我的项目分包看出来，每一个类实现接口，通过接口来进行抽象解耦，以及数据交互。</p>
</blockquote>
<h3 id="一种新思想">一种新思想</h3><blockquote>
<p>  这个思想也是通过github上面一个翻译的文章看来的。因为activity中包含着context， intent，获得系统服务等等，如果把activity作为视图层就应该避免这些业务逻辑。所以将activity仅仅作为视图层有点发挥不出他的真正价值。所以我们考虑把activity，fragment，adapter来作为presenter处理逻辑，用java类文件来作为视图层。并且这样做了之后，我感觉代码的清晰度是有提升的。这是我写的demo源码：<a href="https://github.com/Zane96/MVPLogin" target="_blank" rel="external">新mvp demo</a> 。</p>
</blockquote>
<p><img src="/img/mvp2.png" alt=""></p>
<blockquote>
<p>  大概思路是用一个抽象类来抽出activity中必不可少的ui代码（比如setContentView()以及初始化各种控件）。然后每一个view类文件实现扩展了view层基接口的接口，这样做的目的是为了实现view和baseacitivty之间的解耦。（这个确实倒腾了很久，因为我感觉原文章的代码有问题）。之后在抽象类里面去通过presenter返回的view文件类型，用反射获得对象并进行view的渲染。然后再在presenter中去处理逻辑。看代码吧！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 15/12/5.</span><br><span class="line"> * 用于抽出activity中对于ui的操作代码</span><br><span class="line"> * 弄出两个抽象方法来保证生命周期同步</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePresentActivity</span>&lt;<span class="title">X</span> <span class="keyword">extends</span> <span class="title">V</span>, <span class="title">V</span> <span class="keyword">extends</span> <span class="title">Vu</span>&gt; <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> V vu;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            vu = getVuClass().newInstance();</span><br><span class="line">            vu.init(getLayoutInflater(), <span class="keyword">null</span>);</span><br><span class="line">            setContentView(vu.getView());</span><br><span class="line">            onBindVu();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        onDestroyVu();</span><br><span class="line">        vu = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;X&gt; <span class="title">getVuClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onBindVu</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroyVu</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  首先解释这个抽象类的两个泛型。Vu是view层的基接口，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 15/12/5.</span><br><span class="line"> * view类的超类</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(LayoutInflater inflater, ViewGroup container)</span></span>;</span><br><span class="line">    <span class="function">View <span class="title">getView</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   可以看到有两个方法，一个用来进行view渲染，一个是返回根视图。而泛型里面的V就是扩展了Vu的第二层接口。最后X就是实现了第二层接口的view类文件。这样做的目的就是做到解耦，防止我用传入的类文件去实例化类文件，这里应该是去实例化接口。（用X的对象去实例化V）</p>
<p>  然后再看onBindVu()和onDestoryVu()方法，这个方法是在继承了这个抽象类的presenter里面去实现的，目的是为了达到生命周期同步。</p>
<p>  getVuClass()方法就是要获得这个presenter对应的view类文件类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 15/12/5.</span><br><span class="line"> * 为了使view类和present类解藕</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">VuLoginActivity</span> <span class="keyword">extends</span> <span class="title">Vu</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Button <span class="title">getButtonLogin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Button <span class="title">getButtonClear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">EditText <span class="title">getEditTextAccount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">EditText <span class="title">getEditTextPassword</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearText</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这就是扩展了Vu接口的第二层接口。看到我添加了几个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 15/12/5.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivityViewImpl</span> <span class="keyword">implements</span> <span class="title">VuLoginActivity</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> View view;</span><br><span class="line">    <span class="keyword">protected</span> Button buttonLogin;</span><br><span class="line">    <span class="keyword">protected</span> Button buttonClear;</span><br><span class="line">    <span class="keyword">protected</span> EditText account;</span><br><span class="line">    <span class="keyword">protected</span> EditText password;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(LayoutInflater inflater, ViewGroup container)</span> </span>&#123;</span><br><span class="line">        view = inflater.inflate(R.layout.activity_main, container, <span class="keyword">false</span>);</span><br><span class="line">        buttonLogin = (Button)view.findViewById(R.id.button_login);</span><br><span class="line">        buttonClear = (Button)view.findViewById(R.id.button_clear);</span><br><span class="line">        account = (EditText)view.findViewById(R.id.account);</span><br><span class="line">        password = (EditText)view.findViewById(R.id.password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Button <span class="title">getButtonLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buttonLogin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Button <span class="title">getButtonClear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buttonClear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EditText <span class="title">getEditTextAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EditText <span class="title">getEditTextPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        account.setText(<span class="string">""</span>);</span><br><span class="line">        password.setText(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这里代码也很简单啦！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">BasePresentActivity</span>&lt;<span class="title">LoginActivityViewImpl</span>, <span class="title">VuLoginActivity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onBindVu</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">        vu.getButtonLogin().setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                String userName = vu.getEditTextAccount().getText().toString();</span><br><span class="line">                String password = vu.getEditTextPassword().getText().toString();</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, userName, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">if</span>(userName.equals(user.getUserName()) &amp;&amp; password.equals(user.getPassword())) &#123;</span><br><span class="line">                    Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, LoginSuccessActivity.class);</span><br><span class="line">                    intent.putExtra(<span class="string">"username"</span>, userName);</span><br><span class="line">                    startActivity(intent);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"错误"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        vu.getButtonClear().setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                vu.clearText();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroyVu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyVu();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Class&lt;LoginActivityViewImpl&gt; <span class="title">getVuClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LoginActivityViewImpl.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这个就是presenter。看到我在对应的生命周期里面做了逻辑处理，并且返回他对应的view类文件。</p>
<h1 id="结束语">结束语</h1><blockquote>
<p>  MVP模式确实给项目维护带来了一些便捷，但是也发现，相对于小的项目会导致你的代码量迅速膨胀。所有很多人弄一些mvp的开发框架。确实我自己也想用这种新思路来倒腾一个。但是对于大型项目，这样的代码膨胀并不算什么，带来的好处绝对优于坏处。这次学习又巩固了一下我的设计模式。以一句话结尾：<strong>面对接口编程， 避免面对实现编程</strong></p>
</blockquote>
<p><strong>未经博主同意，不得转载该篇文章</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;p&gt;  在暑假的时候学习了一遍mvp开发模式在android中的运用。那个时候学的时候确实觉得mvp模式做安卓开发特别清晰，代码模块分的特别清楚。但是在自己写demo的时候还是把自己有点绕晕了。因为mvp模式运用了大量的接口（面向接口编程）
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>关于RecycleView显示异步加载图片乱序的问题</title>
    <link href="http://yoursite.com/2015/11/26/%E5%85%B3%E4%BA%8ERecycleView%E6%98%BE%E7%A4%BA%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E4%B9%B1%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2015/11/26/关于RecycleView显示异步加载图片乱序的问题/</id>
    <published>2015-11-26T14:41:45.000Z</published>
    <updated>2016-10-26T13:52:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于RecycleView显示加载图片乱序的问题">关于RecycleView显示加载图片乱序的问题</h1><h1 id="前言">前言</h1><blockquote>
<p>本来之前都在准备touch的第二篇博客。但是突然想起之前做的一个项目中和搭档一起遇到一个问题，就是recycleview的item中的imageview显示图片错位（网络加载图片）。当然。。当时在做项目，自然就是赶紧找解决办法呗，看了官方教程和郭神的博客，但是只看他们的教程还是没有很好的解决，因为我们的东西是有些item的imageview为空，而他们讲的都是所有item的imageview都有图片。不过最后也还是稀里糊涂的解决了哈哈。昨天自己写了一个demo,放在我的github嗒。通过源码和大神们的博客想总结一下这个问题。<a href="https://github.com/Zane-cqupt/BestBitmapDownload" target="_blank" rel="external">源码地址</a></p>
</blockquote>
<h2 id="关于这个问题">关于这个问题</h2><blockquote>
<p>如果大家看过郭神的博客或者自己遇到过，就会知道解决这个问题有三种方法，第一是给imageview设置tag，第二是我用到的，给AsyncTask和imageview双向添加弱引用，进行逻辑判断。第三当然就是用第三方库啰，比如volley的图片加载或者现在最牛逼的fresco！第三方库的控件之所以能解决这个问题，其实就是自己内部做了处理。虽然提倡<strong>不要造重复的轮子</strong> ,但是得知道轮子时怎么造出来的。而我们遇到的问题（有些item的imageview为空图）连第三方库都不能解决。通过看imageview的源码，很快也解决了这个问题。那么recycleview显示异步加载图片错位的原因是什么呢？</p>
</blockquote>
<p><img src="/img/4.1.png" alt="图解"></p>
<blockquote>
<p>RecycleView和ListView一样，每个item里面的控件<strong>都是复用的</strong> ！也就是说不可能你有10k个item系统就给你提供10k个imageview，要不然系统造就gg了。所以正是这个原因也导致了我们遇到的这个坑。系统真正提供给你的imageview可能只有显示的item多一点点～</p>
</blockquote>
<p><img src="/img/4.2.png" alt=""></p>
<blockquote>
<p>从这个图你就可以清楚的知道为什么会错乱了。首先<strong>itemA处于显示状态，然后隐藏，那么他的imageview被收回到recycleBin等待下一次被利用。并且这个imageview已经跟一个drawable关联了，这个drawable就是task请求的结果，task是否在被回收之前已经完成自己的使命并不确定。接下来itemB从隐藏变成了显示状态。那么itemA的那个imageview就可能会被系统拿去给itemB使用。一旦使用就会导致图片错乱。也就是说，，一个imageview就有了两个task，两个drawble…不错乱才怪了</strong> 。</p>
</blockquote>
<h2 id="解决它！">解决它！</h2><h4 id="思路">思路</h4><blockquote>
<p>既然是因为拿到的imageview包含一个task而导致错乱，那么我们取消它不就完了。确实就是这样。</p>
</blockquote>
<ol>
<li><p>在每一个task里面放进它所对应的imageview弱引用(使系统想收回资源的时候大胆的收回)</p>
<p>将imageview通过task的构造器在适配器里面把imageview传给task。</p>
</li>
<li><p>在每一个imageview里面放入它对应的task的弱引用。</p>
<p>这个比较复杂。我需要用一个BitmapDrawable类来做桥梁。因为imageview和drawable的关联用set方法就ok了。在自定义的BitmapDrawable的子类的构造器里面我们传入默认的占位图和task引用。在子类里面进行弱引用包装。</p>
</li>
</ol>
<blockquote>
<p>双引用实现了之后，<strong>我们不管系统给我的imageview的task是否完成，都判断两个task的url是否相同。如果相同就可以不用管了，如果url都不相同还管你个屁，直接把imageview中带来的task给我取消了。哈哈，可能大家觉得这样就够了。说实话，我之前也是这么想的，可是如果只做到这一步，新显示的item还是会显示一段时间的imageview的drawable直到自己的task完成才会恢复正常。原因就是传进来的imageview的task在传进来之前就可能已经完成了。这个弯一定要绕过去！</strong>思路有了，我们开始看代码吧！</p>
<p>直接上适配器的代码了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 15/11/25.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecycleViewAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">RecycleViewAdapter</span>.<span class="title">MyViewHolder</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图片缓存LruCache</span></span><br><span class="line">    <span class="keyword">private</span> LruCache&lt;String, BitmapDrawable&gt; mLrucache;</span><br><span class="line">    <span class="keyword">private</span> LayoutInflater layoutInflater;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecycleViewAdapter</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        layoutInflater = LayoutInflater.from(context);</span><br><span class="line">        <span class="keyword">int</span> maxSize = (<span class="keyword">int</span>) Runtime.getRuntime().maxMemory();</span><br><span class="line">        <span class="keyword">int</span> cacheSize = maxSize / <span class="number">8</span>;</span><br><span class="line">        mLrucache = <span class="keyword">new</span> LruCache&lt;String, BitmapDrawable&gt;(cacheSize)&#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, BitmapDrawable value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value.getBitmap().getByteCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        View view = layoutInflater.inflate(R.layout.item_recycleview, parent, <span class="keyword">false</span>);</span><br><span class="line">        MyViewHolder holder = <span class="keyword">new</span> MyViewHolder(view);</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我用到了Lrucache进行图片缓存。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(MyViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    String url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if(position != 1) &#123;</span></span><br><span class="line">        url = Images.imageUrls[position];</span><br><span class="line">        BitmapDrawable drawable = getBitmapFromMemoryCache(url);</span><br><span class="line">        <span class="keyword">if</span>(drawable != <span class="keyword">null</span>)&#123;</span><br><span class="line">            holder.imageView.setImageDrawable(drawable);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            loadBitmap(url, holder.imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//else &#123;</span></span><br><span class="line">    <span class="comment">//    holder.imageView.setImageResource(R.drawable.ic_launcher);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Images.imageUrls.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先判断缓存里面是否有存储的图像，提高效率。可以看到我上面代码的注释，那是为了测试后面某个item的imageview为空的情况。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加imageview的弱引用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapDownloadTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Void</span>, <span class="title">BitmapDrawable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ImageView imageView;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;ImageView&gt; imageViewWeakReference;</span><br><span class="line">    <span class="keyword">public</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitmapDownloadTask</span><span class="params">(ImageView imageView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imageView = imageView;</span><br><span class="line">        imageViewWeakReference = <span class="keyword">new</span> WeakReference&lt;ImageView&gt;(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> BitmapDrawable <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        url = params[<span class="number">0</span>];</span><br><span class="line">        Bitmap bitmap = downloadBitmap(url);</span><br><span class="line">        BitmapDrawable bitmapDrawable = <span class="keyword">new</span> BitmapDrawable(context.getResources(), bitmap);</span><br><span class="line">        addBitmapToMemoryCache(url, bitmapDrawable);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bitmapDrawable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(BitmapDrawable bitmapDrawable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isCancelled())&#123;</span><br><span class="line">            bitmapDrawable = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//第二次判断，如果iamgeview里面的task跟这个item根据适配器传进来的正确url启动的task不相同，就不显示图片</span></span><br><span class="line">        <span class="keyword">if</span>(imageViewWeakReference != <span class="keyword">null</span> &amp;&amp; bitmapDrawable != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ImageView imageView = imageViewWeakReference.get();</span><br><span class="line">            BitmapDownloadTask task = getBitmapWorkerTask(imageView);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> == task &amp;&amp; imageView != <span class="keyword">null</span>)&#123;</span><br><span class="line">                imageView.setImageDrawable(bitmapDrawable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//imageView.setImageDrawable(bitmapDrawable);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Bitmap <span class="title">downloadBitmap</span><span class="params">(String imageUrl)</span> </span>&#123;</span><br><span class="line">        Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">        HttpURLConnection con = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(imageUrl);</span><br><span class="line">            con = (HttpURLConnection) url.openConnection();</span><br><span class="line">            con.setConnectTimeout(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            con.setReadTimeout(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">            bitmap = BitmapFactory.decodeStream(con.getInputStream());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                con.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里面onPostExecute()方法进行的判断是我们的逻辑判断的第二步。我们取出imageview对应的task跟“正规军task”进行比较，如果为空或者不相等的话，阻止imageview设置上一次task完成之后得到的drawable。注意，这些都是在item的”正规军task”里面执行的哦，别绕昏了！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来根据传进来的imageview获得对应的drawable,再获得对应的task</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BitmapDownloadTask <span class="title">getBitmapWorkerTask</span><span class="params">(ImageView imageView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (imageView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Drawable drawable = imageView.getDrawable();</span><br><span class="line">            <span class="keyword">if</span> (drawable <span class="keyword">instanceof</span> AsyncDrawable) &#123;</span><br><span class="line">                <span class="keyword">final</span> AsyncDrawable asyncDrawable = (AsyncDrawable) drawable;</span><br><span class="line">                <span class="keyword">return</span> asyncDrawable.getBitmapTask();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码就是根据imageview获得对应task的方法了。之前说到，我是把BitmapDrawable作为绑定的桥梁。所以先获得drawable然后再获得task。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加task的弱引用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncDrawable</span> <span class="keyword">extends</span> <span class="title">BitmapDrawable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;BitmapDownloadTask&gt; taskWeakReference;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AsyncDrawable</span><span class="params">(Resources res, Bitmap bitmap</span><br><span class="line">                                    , BitmapDownloadTask task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(res, bitmap);</span><br><span class="line">            taskWeakReference = <span class="keyword">new</span> WeakReference&lt;BitmapDownloadTask&gt;(task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> BitmapDownloadTask <span class="title">getBitmapTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> taskWeakReference.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个就是桥梁啰。代码很简单～</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将drawable与imageview绑定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBitmap</span><span class="params">(String url, ImageView imageView)</span></span>&#123;</span><br><span class="line">        Bitmap mLoadingBitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.ic_launcher);</span><br><span class="line">        <span class="keyword">if</span> (cancelBeforeTask(url, imageView))&#123;</span><br><span class="line">            BitmapDownloadTask task = <span class="keyword">new</span> BitmapDownloadTask(imageView);</span><br><span class="line">            AsyncDrawable drawable = <span class="keyword">new</span> AsyncDrawable(context.getResources(), mLoadingBitmap, task);</span><br><span class="line">            <span class="comment">//!!!!</span></span><br><span class="line">            imageView.setImageDrawable(drawable);</span><br><span class="line">            task.execute(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个方法就是用来根据适配器给我的url启动一次“正规军task”的方法了～<strong>if (cancelBeforeTask(url, imageView))</strong>这里就是我做的第一次判断。如果返回true那么就启动正规军 task.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来进行第一步的判断，如果imageview对应的task的url跟传进去的url不同，那么取消上一次task</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancelBeforeTask</span><span class="params">(String url, ImageView imageView)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        BitmapDownloadTask task = getBitmapWorkerTask(imageView);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(task != <span class="keyword">null</span>)&#123;</span><br><span class="line">            String imgUrl = task.url;</span><br><span class="line">            <span class="keyword">if</span> (imgUrl != url || imgUrl == <span class="string">""</span>)&#123;</span><br><span class="line">                task.cancel(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果系统给我的imageview的task的url跟适配器给我的正规url不同，那么表示两个task启动的图片都不同，所以取消上一次的task然后返回true。</p>
</blockquote>
<h2 id="结果呢？">结果呢？</h2><p><img src="/img/4.3.png" alt="结果"></p>
<blockquote>
<p>特么的，当然是没问题的啦！可是！！！如果我现在第二个item设置为空图，就又会出现问题了！</p>
</blockquote>
<p>我改一下代码使第二张图不为空，效果如下：</p>
<p><img src="/img/4.4.png" alt=""></p>
<p>然后我滑动一下屏幕，效果如下：</p>
<p><img src="/img/4.5.png" alt=""></p>
<blockquote>
<p>卧槽。。对，这就是我们当初遇到的问题。如何解决呢？很简单，如果为空那就给它一个永久的占位图就可以了。</p>
</blockquote>
<p><img src="/img/4.6.png" alt="like this!"></p>
<h1 id="结束语">结束语</h1><blockquote>
<p>说实话有些东西不必弄的太深，分享最近的一些感想：给你一大堆材料，让你搭建一个高楼。材料如何生产质量更好，你不必太关心。材料质量怎样，你需要去关心。而如何把这栋房子搭建的更牢固，怎么搭建用料最少，复用性更高，耦合度更低，才是最需要去关心的。有时候房子的构建不好，会出现不稳固，不健壮，甚至地基不稳（内存泄露？）。实在可怕——做项目有感而发。  但是这种问题，并且是工作中遇到的问题，还是值得去探究并解决的。如何找到解决问题，也是面试官考察你的很重要的一点。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于RecycleView显示加载图片乱序的问题&quot;&gt;关于RecycleView显示加载图片乱序的问题&lt;/h1&gt;&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本来之前都在准备touch的第二篇博客。但是突然想起之前做的一个项目中和搭档一起遇到
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
</feed>
