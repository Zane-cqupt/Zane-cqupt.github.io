<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Zane's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="Talk is Cheap, Show me The Code">
<meta property="og:type" content="website">
<meta property="og:title" content="Zane's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Zane's Blog">
<meta property="og:description" content="Talk is Cheap, Show me The Code">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zane's Blog">
<meta name="twitter:description" content="Talk is Cheap, Show me The Code">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>


  <title> Zane's Blog </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?cb28c7b1af22910846ab0156ab0d9f01";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Zane's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">爱编程，爱生活，不羁放纵爱自由</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/26/BitmapPool的设计与实践/" itemprop="url">
                  BitmapPool的设计与实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-26T21:46:48+08:00" content="2016-10-26">
              2016-10-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/26/BitmapPool的设计与实践/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/26/BitmapPool的设计与实践/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>未经博主同意，不得转载该篇文章</strong></p>
<h2 id="前言">前言</h2><p>​   前一段时间在重新做自己的图片提供器的开发库<a href="https://github.com/Zane96/EasyImage" target="_blank" rel="external">EasyImage</a>, 把加载网络图片的这块的功能完成了。主要也是在练习一下Java并发的东西。在完成了基本的架构之后，我发现RecycleView加载图片的时候，快速滑动列表的时候卡顿非常的明显。和<strong>Glide</strong>比起来差太远。虽然完全不是一个量级的东西。但是还是想做点什么让卡顿降低一点。</p>
<h2 id="问题">问题</h2><p>​   如果要问卡顿出现的原理，不是本文的讨论的重点。总之来说，就是手机超过了16ms才去刷新一个帧，就会导致界面卡顿。我通过Monitor跟踪分析了RecycleView快速滑动的时候的内存占用。发现Bitmap在疯狂的产生，清除。在图像上产生了大量的强制gc的信号。嗯，虽然RecycleView的ImageView重用了，但是Bitmap的内存是不停的根据适配进来的数据生成，释放，生成，释放…。所以造成大量的虚拟机强制GC，导致界面卡顿。所以，很简单的道理，应该想到将Bitmap的内存复用起来。毕竟RecycleView中重复加载的的Bitmap的Config都是一致的。</p>
<p>​   并且<strong>Glide</strong>， <strong>Fresco</strong>都是使用了Bitmap复用技术。总的来说，解决方式找到了，但是如何解决还是遇到了很多问题。</p>
<ul>
<li>我开发的是一个图片加载库，那么我如何找到Bitmap内存回收的Point？如何找到Bitmap内存复用的Point?毕竟这个复用操作对开发者是隐藏的。我不可能去让开发者在Adapter的ViewHolder中去回调Bitmap复用／释放的操作。</li>
<li>如何判断一个Bitmap是否该回收？如果这个Bitmap被多个ImageView引用了怎么办？</li>
<li>如何将被复用的Bitmap内存和新的数据融合？</li>
<li>LruCache的时候是否该回收？DiskCache呢？如果Bitmap在LruCache存储中因为内存满了被踢出了缓存中或者因为数据源对应缓存的Bitmap数据更新而被踢出内存中的旧Bitmap，如果给它的引用计数减1？</li>
<li>如何通过ImageView的宽高来拿到相对应的Bitmap的宽高？（后面内存复用的时候需要这个）</li>
</ul>
<p>基于以上的问题，我基本上一步步的进行了解决，最终完成了BitmapPool的设计。</p>
<h2 id="设计">设计</h2><p>​   先上一张导图。</p>
<p>​   <img src="/img/bitmappool1.jpg" alt=""></p>
<p>​   可以看到，我基本上将很多功能都已经模块化了。首先一个图片加载库，会提供多种数据形式的数据加载，网络，Resource，本地文件，缓存等等。而这些不同的加载形式都可以封装成不同的加载模块或者说加载策略。然后通过策略模式去提供不同的加载模块。所以在这里我们把他们看成<strong>数据提供源</strong>。（这里的数据源最终转换成Bitmap的像素点阵）</p>
<p>​   所有的数据源提供的数据都通过BitmapDecode和Bitmap内存融合。然后拥有了全新像素点阵的Bitmap全部被封装成LeasedDrawable发布到UImageLoader中进行最终的渲染。所以很清楚的发现，<strong>UImageLoader</strong>中就是Bitmap被复用的计数点。</p>
<p>​   <strong>计数点和LeasedDrawable</strong>可以一起来解释。上述的第二个问题，实际上可以被JVM中内存是否该被回收中的引用计数算法解决。如果发布一次，那么引用计数加1，回首一次，那么引用计数减1。如果减完了之后引用计数为0，那么就可以进行内存的回收到BitmapPool中等待复用了。而谁来进行引用的计数呢？很简单的道理，使用<strong>BitmapDrawable</strong>。在RecycleView加载图片错位那里，我也是通过这个类将Bitmap进行封装，然后存储它的Task解决的。一样的道理，这里也是进行对Bitmap的二次封装，然后进行引用计数的增加或者减少。</p>
<p>​   可以看到数据源那里我写了<strong>DiskCache</strong>，但是没有<strong>LruCache</strong>。其实这个问题不难。。我也不知道为啥我会被傻x的困扰了好久（大概是因为最近太开心了吧2333，科科，严肃）。LruCache实际是一个将点对点的映射（数据源信息到拥有正确像素点阵的Bitmap）关系存储到了内存中。所以，存储进去的时候，我们不应该引用计数减1啊，，因为还在内存中啊少年。但是DiskCache直接将Bitmap打成了Stream存入了磁盘中。所以Disk和Lru需要分开对待。</p>
<p>​   还有一点，如果Bitmap在Lru中因为Lru的内存空间忙了而被踢出去了，怎么拿到被剔除的Bitmap并且进行回收操作？嗯，，我还不是不知道，但是我通过看Lru的源码发现了这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Called for entries that have been evicted or removed. This method is</span><br><span class="line">     * invoked when a value is evicted to make space, removed by a call to</span><br><span class="line">     * &#123;<span class="doctag">@link</span> #remove&#125;, or replaced by a call to &#123;<span class="doctag">@link</span> #put&#125;. The default</span><br><span class="line">     * implementation does nothing.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;The method is called without synchronization: other threads may</span><br><span class="line">     * access the cache while this method is executing.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> evicted true if the entry is being removed to make space, false</span><br><span class="line">     *     if the removal was caused by a &#123;<span class="doctag">@link</span> #put&#125; or &#123;<span class="doctag">@link</span> #remove&#125;.</span><br><span class="line">     * <span class="doctag">@param</span> newValue the new value for &#123;<span class="doctag">@code</span> key&#125;, if it exists. If non-null,</span><br><span class="line">     *     this removal was caused by a &#123;<span class="doctag">@link</span> #put&#125;. Otherwise it was caused by</span><br><span class="line">     *     an eviction or a &#123;<span class="doctag">@link</span> #remove&#125;.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">entryRemoved</span><span class="params">(<span class="keyword">boolean</span> evicted, K key, V oldValue, V newValue)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​   看到没，<strong>@param evicted true if the entry is being removed to make space</strong>。通过源码可以发现，entryRemoved方法只在<strong>trimToSize</strong>方法中才会传入True</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Remove the eldest entries until the total of remaining entries is at or</span><br><span class="line"> * below the requested size.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> maxSize the maximum size of the cache before returning. May be -1</span><br><span class="line"> *            to evict even 0-sized elements.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>​   注释写的很清楚了。所以，我们只需要继承LruCache然后实现<strong>entryRemoved</strong>方法，并且当<strong>evicted</strong>为True的时候将Bitmap的引用计数减1就可以了。</p>
<p>​   解决了以上问题之后，还剩最后一点。如何将内存复用？好像通过Bitmap的API或者文档看不出来能直接更改像素点阵的方法。好在有<strong>inBitmap</strong>这个玩意。详情请查阅文档：<a href="https://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inBitmap" target="_blank" rel="external">传送门</a>。使用BitmapFactory.Option的这个字段，可以做到通过这个Option加载新的Bitmap的时候将bitmap内存复用。但是在Android4.4之上的版本使用的时候有些小限制：</p>
<ul>
<li>被加载的Bitmap必须是jpg或者png格式的图片</li>
<li>inSampleSize字段必须是1</li>
<li>两个Bitmap的Configuration（这里是size）必须相同</li>
</ul>
<p>所以完全可以看出来，google做的这个优化完全就是为了优化RV加载网络图片的。</p>
<p>对。。还有最后一点，如何通过ImageView的size路由到上次被渲染的Bitmap的size？我反正是写了一些Ugly Code，我在BitmapDecode中做了一个“路由表”用来存储映射关系。</p>
<h2 id="实践">实践</h2><p>​   把以上的问题和思路都解决理清之后，就可以开始实践了！</p>
<p>​   先上core class <strong>BitmapPool</strong>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Zane on 16/10/19.</span><br><span class="line"> * Email: zanebot96<span class="doctag">@gmail</span>.com</span><br><span class="line"> * Blog: zane96.github.io</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Bitmap中的bitmap存储数据结构,需要在代码中进行线程安全的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Bitmap&gt; mBitmaps = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//位图池是否正在销毁</span></span><br><span class="line">    <span class="keyword">boolean</span> isRecycled;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BitmapPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isRecycled = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保持单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BitmapPool instance = <span class="keyword">new</span> BitmapPool();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BitmapPool <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * inBitmap这个字段从Android 3.0才添加,而4.4之后才要求我如下代码的要求。这里我们只要大于3.0的版本</span><br><span class="line">     * 我们都满足如下要求,因为本来这里就是为生成大量Bitmap的具有回收机制的控件而设计的(item中Bitmap的config相同)</span><br><span class="line">     * <span class="doctag">@param</span> width</span><br><span class="line">     * <span class="doctag">@param</span> height</span><br><span class="line">     * <span class="doctag">@return</span> true 在Bitmap中找到了合适的Bitmap内存空间,false 没有找到合适的Bitmap,需要自己生成</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> BitmapFactory.<span class="function">Options <span class="title">getReuseOption</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBitmaps)&#123;</span><br><span class="line">            Log.i(<span class="string">"BitmapPool"</span>, <span class="string">"Prereuse "</span> + mBitmaps.size()+ <span class="string">" size"</span>);</span><br><span class="line">            BitmapFactory.Options options = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB)&#123;</span><br><span class="line">                Bitmap reuseBitmap = getBitmapBySize(width, height);</span><br><span class="line">                <span class="keyword">if</span> (reuseBitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Log.i(<span class="string">"BitmapPool"</span>, <span class="string">"reuse"</span>);</span><br><span class="line">                    options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">                    options.inBitmap = reuseBitmap;</span><br><span class="line">                    options.inSampleSize = <span class="number">1</span>;</span><br><span class="line">                    options.inMutable = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> options;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 将Lru中</span><br><span class="line">     * <span class="doctag">@param</span> bitmap</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putReuseBitmap</span><span class="params">(Bitmap bitmap)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBitmaps)&#123;</span><br><span class="line">            Log.i(<span class="string">"BitmapPool"</span>, <span class="string">"putin"</span>);</span><br><span class="line">            mBitmaps.add(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据传入的所需要的Bitmap的宽和高来返回Bitmap池中符合要求的Bitmap.</span><br><span class="line">     * 必须是宽高一致。不然无法复用</span><br><span class="line">     * 注意不要出现ConcurrentModificationException</span><br><span class="line">     * <span class="doctag">@param</span> width</span><br><span class="line">     * <span class="doctag">@param</span> height</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Bitmap <span class="title">getBitmapBySize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">        List&lt;Bitmap&gt; removeBitmaps = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Bitmap returnBitmap = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Bitmap bitmap : mBitmaps)&#123;</span><br><span class="line">                <span class="keyword">if</span> (bitmap.isRecycled()) &#123;</span><br><span class="line">                    removeBitmaps.add(bitmap);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.i(<span class="string">"BitmapPool"</span>, <span class="string">"width height "</span> + width + <span class="string">" "</span> + height + <span class="string">" bitmap: "</span> + bitmap.getWidth() + <span class="string">" "</span> + bitmap.getHeight());</span><br><span class="line">                    <span class="keyword">if</span> (bitmap.getWidth() == width &amp;&amp; bitmap.getHeight() == height)&#123;</span><br><span class="line"></span><br><span class="line">                        removeBitmaps.add(bitmap);</span><br><span class="line">                        returnBitmap = bitmap;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mBitmaps.removeAll(removeBitmaps);</span><br><span class="line">            <span class="keyword">return</span> returnBitmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 清空BitmapPool缓存的Bitmap内存空间</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearBitmapPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBitmaps)&#123;</span><br><span class="line">            isRecycled = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!mBitmaps.isEmpty())&#123;</span><br><span class="line">                Bitmap bitmap = mBitmaps.remove(i);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (!bitmap.isRecycled())&#123;</span><br><span class="line">                    bitmap.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看和BitmapPool有着PY交易的LeasedDrawable类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**LeasedDrawable作为和BitmapPool进行交易的中间层</span><br><span class="line"> * 通过引用计数来管理Bitmap的回收/销毁 与否</span><br><span class="line"> *</span><br><span class="line"> * Created by Zane on 16/10/20.</span><br><span class="line"> * Email: zanebot96<span class="doctag">@gmail</span>.com</span><br><span class="line"> * Blog: zane96.github.io</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeasedDrawable</span> <span class="keyword">extends</span> <span class="title">BitmapDrawable</span> <span class="keyword">implements</span> <span class="title">ILeasedDrawable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger mReferenceCount;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean isRecycle = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BitmapPool bitmapPool = BitmapPool.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LeasedDrawable</span><span class="params">(Bitmap bitmap)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(bitmap);</span><br><span class="line">        mReferenceCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mReferenceCount.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRecycle.get())&#123;</span><br><span class="line">            mReferenceCount.decrementAndGet();</span><br><span class="line">            Bitmap bitmap = getBitmap();</span><br><span class="line">            Log.i(<span class="string">"LeasedDrawable"</span>, <span class="string">"reference count: "</span> + mReferenceCount);</span><br><span class="line">            <span class="keyword">if</span> (mReferenceCount.get() &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"reference to bitmap can't smaller than 0"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mReferenceCount.get() == <span class="number">0</span>)&#123;</span><br><span class="line">                isRecycle.set(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (bitmapPool.isRecycled)&#123;</span><br><span class="line">                    bitmap.recycle();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//回收内存</span></span><br><span class="line">                    Log.i(<span class="string">"LeasedDrawable"</span>, <span class="string">"recycle"</span>);</span><br><span class="line">                    bitmapPool.putReuseBitmap(bitmap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我觉得。。代码真的不复杂。并且如果实在开发中自己去做一个BitmapPool（如果你傻x的不用优秀的图片加载库）去优化性能，这一点都不难。</p>
<h2 id="总结">总结</h2><p>自己也快到了找实习的时候了。思想上跟不上，基础上跟不上我觉得会很糟糕。这个库本来就是写来练习设计模式的，基本上没有实践的用处。。不过，好在做完了，并且可以用。</p>
<p>最后一句话，朱大告诉我的：<strong>面试中，基础比深度重要</strong>。互勉。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/20/单元测试总结/" itemprop="url">
                  单元测试总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-20T13:05:15+08:00" content="2016-09-20">
              2016-09-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/20/单元测试总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/20/单元测试总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="单元测试小总结">单元测试小总结</h2><p>​ 单元测试往往在产品赶着上线的情况下被忽视。然后单元测试往往会节约大量修改bug的时间。还有一点，单元测试能够验证你的代码的结构是否具有松耦性，因为高度耦合的代码是难以做单元测试的。所以代码中经常通过Dagger来做单元测试。另一点，可以发现老外的项目基本上每个项目都做过不同程度的单元测试，不论项目是大是小，然而中国人好像比较忽视这一点，从现在AS一打开都会给你建测试包都可以看出来老外是很重视单元测试的。</p>
<h3 id="单元测试是什么">单元测试是什么</h3><p>​ 不关有单元测试，还有UI测试，集成测试等等。单元测试简单的来说就是来验证某个类里面的某个方法能不能传入一个参数然后返回一个我们预期的值，如果没有返回值就去验证函数中代码能不能正常按预期跑一遍。实际上是如何测试是个非常灵活的事情。常用的单元测试框架有：JUnit，Mockito，Robolectric，DaggerMock等等</p>
<h3 id="最简单的示例">最简单的示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Add</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 对上述代码进行单元测试只需要最基本的JUnit框架就够了，没错，就是AS给你自动引入的JUnit。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">addTest</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">      Add add = <span class="keyword">new</span> Add();</span><br><span class="line">    assertEquals(<span class="number">3</span>, add.sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 然后将直接control+sheft+R运行这个测试方法。看上面的代码当然是可以通过，所以控制台会直接通过，如果将预期值改为4，那么就会报错。</p>
<p>​ 所以单元测试大概可以看成三部分：</p>
<ul>
<li>初始化对象</li>
<li>调用</li>
<li>验证</li>
</ul>
<p>​ 也许这样的代码让你觉得单元测试毫无意义，但是在实际项目中，复杂的逻辑没有这么好写单元测试。首先MVP这样的模块化解耦构建的项目会对单元测试代码的书写轻松很多。总之：<strong>松耦合</strong></p>
<p>​ <strong>JUnit</strong>还有很有的小使用技巧：比如@Before，@After，@Beforeclass，@Afterclass，fail（），assertXXXXXX（）等等，可以在我最下面的推荐的文章里面去深入学习。这里我们只做大概的介绍和总结。</p>
<h3 id="用Mockito去做一些不可思议的事情">用Mockito去做一些不可思议的事情</h3><p>​ Mockito中有一个类很重要叫<strong>Mock</strong>。不知道听说过Mock数据没有，就是用自己模拟的数据去代替真实的数据，实际开发中，移动端和后台定义好json字段之后，移动端可以先用Mock数据代替真实数据，和后台一起进行开发。这里的Mock类一样道理，就是在单元测试中去模拟一个实例，然后代替需要被测试的代码中真实的对象。然后通过Mock出来的对象替换被测试代码中的对象，再使用Mockito进行验证对象的函数是否成功被调用。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserManager mUserManager = <span class="keyword">new</span> UserManager();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (username == <span class="keyword">null</span> || username.length() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (password == <span class="keyword">null</span> || password.length() &lt; <span class="number">6</span>) <span class="keyword">return</span>;</span><br><span class="line">        mUserManager.performLogin(username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserManager</span><span class="params">(UserManager userManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mUserManager = userManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginPresenterTest</span></span>&#123;</span><br><span class="line">  <span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    UserManager mockUserManager = Mockito.mock(UserManager.class);</span><br><span class="line">    LoginPresenter loginPresenter = <span class="keyword">new</span> LoginPresenter();</span><br><span class="line">    loginPresenter.setUserManager(mockUserManager);</span><br><span class="line"></span><br><span class="line">    loginPresenter.login(<span class="string">"xiaochuang"</span>, <span class="string">"xiaochuang password"</span>);</span><br><span class="line"></span><br><span class="line">    Mockito.verify(mockUserManager).performLogin(<span class="string">"xiaochuang"</span>, <span class="string">"xiaochuang password"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概步骤如下：</p>
<ul>
<li>Mock对象出来</li>
<li>将对象手动替换到被测试代码中</li>
<li>验证Mock对象的函数是否被成功调用</li>
</ul>
<p>也许你发现了，这样必须要给被测试类写一个setter方法，这是极度。。不优雅的。所以！所以！我们引出了Dagger来给我们将Mock对象注入到被测试类～～（激动）</p>
<p><strong>Mockito</strong>的功能大概如下：</p>
<ul>
<li>更改Mock对象的函数行为</li>
<li>验证Mock对象的函数是否被调用</li>
</ul>
<p>具体的，，使用方法当然不再多说。</p>
<h3 id="通过Robolectrie在JVM上直接加载Android类">通过Robolectrie在JVM上直接加载Android类</h3><p>​ 单元测试方便的就是不需要跑一遍项目，不需要打一堆Log，不需要balabala~，但是Android类是不能直接跑在JVM上的，只能在手机上的虚拟机上（ART）。所以如果单元测试中涉及到Android类，就通过Robolectrio来解决。我感觉他的思路就是类似动态代理一样的在代码跑的过程中用他自己的类来替换Android类。比如Activity就对应了ShadowActivity类。并且这些代理类还提供了更多的接口让开发者能够更方便的获得对象的状态。</p>
<p>Ps：Robolectrie对于as插件的版本要求比较坑，我遇到一个版本bug，弄了一下午。。。</p>
<h3 id="通过Dagger来优雅的进行依赖注入">通过Dagger来优雅的进行依赖注入</h3><p>​ <strong>Dagger</strong>的使用自然我不会在这里多说。我说说单元测试是如何使用Dagger的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginTestModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginTestModule</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">provideContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordValidator <span class="title">providePasswordValidator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PasswordValidator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">provideSharedPreferences</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PreferenceManager.getDefaultSharedPreferences(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiService <span class="title">provideApiService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UsersManager <span class="title">provideUserManager</span><span class="params">(SharedPreferences sp, ApiService service)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UsersManager(sp, service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoginPresenter <span class="title">provideLoginPresenter</span><span class="params">(UsersManager manager, PasswordValidator passwordValidator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoginPresenter(manager, passwordValidator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>(modules = &#123;LoginTestModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginTestComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Inject</span></span><br><span class="line">    LoginPresenter loginPresenter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditText mUsername;</span><br><span class="line">    <span class="keyword">private</span> EditText mPassword;</span><br><span class="line">    <span class="keyword">private</span> Button mButton;</span><br><span class="line">    <span class="keyword">private</span> LinearLayoutManager layoutManager;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过一个holder来传入mock出来的mocule</span></span><br><span class="line">        LoginComponentHolder.getComponent().inject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        mUsername = (EditText) findViewById(R.id.edit_name);</span><br><span class="line">        mPassword = (EditText) findViewById(R.id.edit_password);</span><br><span class="line">        mButton = (Button) findViewById(R.id.button);</span><br><span class="line"></span><br><span class="line">        mButton.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            String username = mUsername.getText().toString();</span><br><span class="line">            String password = mPassword.getText().toString();</span><br><span class="line">            loginPresenter.login(username, password);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginComponentHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LoginTestComponent component;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setComponent</span><span class="params">(LoginTestComponent component2)</span></span>&#123;</span><br><span class="line">        component = component2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoginTestComponent <span class="title">getComponent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> component;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中要测试的是Button点击之后presenter的login（）方法会被成功调用。loginPresenter是通过项目中使用Dagger简单注入进去的（<strong>注意是通过Field Injection inject进去的</strong>），并且我们用一个ComponentHolder来维护这个Module对应的Component。测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RunWith</span>(RobolectricGradleTestRunner.class)</span><br><span class="line"><span class="annotation">@Config</span>(constants = BuildConfig.class, sdk = <span class="number">21</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginPresenterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LoginTestModule mockModule;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//不能调用mock()因为dagger规定module的provide方法不能返回null</span></span><br><span class="line">        mockModule = Mockito.spy(<span class="keyword">new</span> LoginTestModule(RuntimeEnvironment.application));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMainActivityLogin</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        LoginPresenter loginPresenter = Mock(LoginPresenter.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始更改mockModule的方法行为,返回mock的loginPresenter到mockModule的dependency中去</span></span><br><span class="line">        Mockito.when(mockModule.provideLoginPresenter(Mockito.any(UsersManager.class),</span><br><span class="line">                Mockito.any(PasswordValidator.class))).thenReturn(loginPresenter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将这个module生成的component放到容器中去</span></span><br><span class="line">        LoginTestComponent component = DaggerLoginTestComponent.builder()</span><br><span class="line">                .loginTestModule(mockModule)</span><br><span class="line">                .build();</span><br><span class="line">        LoginComponentHolder.setComponent(component);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过Robolectric生成mock MainActivity</span></span><br><span class="line">        MainActivity mainActivity = Robolectric.setupActivity(MainActivity.class);</span><br><span class="line">        ((EditText)mainActivity.findViewById(R.id.edit_name)).setText(<span class="string">"zane"</span>);</span><br><span class="line">        ((EditText)mainActivity.findViewById(R.id.edit_password)).setText(<span class="string">"123"</span>);</span><br><span class="line">        Button mButton = (Button) mainActivity.findViewById(R.id.button);</span><br><span class="line">        mButton.performClick();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证</span></span><br><span class="line">        Mockito.verify(loginPresenter).login(<span class="string">"zane"</span>, <span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 大致的思路其实就是Mock对应的Module，然后通过Mockito来更改provide方法的行为（返回一个Mock对象，更改Module的Dependency），然后将Mock的Module（更改了Dependency行为）注入到ComponentHolder中。最终MainActivity中inject的时候，就会被注入一个Mock对象。</p>
<p>​ 首先强调一点，不应该为了使用Dagger而使用Dagger。嗯，就是如果能不用Dagger，那就尽量不用。首先上面我强调了LoginPresenter是通过Field Inject的方式注入进去的，一般通过这种方式注入进去的，很难不通过更改Dagger依赖图去改变注入的依赖对象。但是如果LoginPresenter是通过Constructor Inject注入到依赖图的话，完全可以调用构造函数new一个对象出来，构造函数的参数都可以直接传进去，所以不用费大力气去修改依赖图了。</p>
<h3 id="使用DaggerMock来简化代码">使用DaggerMock来简化代码</h3><p>​ 如果觉得上述通过Dagger来做单元测试代码还是很复杂，可以使用黑科技DaggerMock来简化你的代码。在使用这个框架之前必须学习一下JUnit的Rule。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> DaggerMockRule daggerMockRule = <span class="keyword">new</span> DaggerMockRule(LoginTestComponent.class, <span class="keyword">new</span> LoginTestModule(RuntimeEnvironment.application))</span><br><span class="line">            .set(<span class="keyword">new</span> DaggerMockRule.ComponentSetter() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setComponent</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                    LoginComponentHolder.setComponent((LoginTestComponent) o);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"> <span class="annotation">@Mock</span></span><br><span class="line"> LoginPresenter loginPresenter;</span><br></pre></td></tr></table></figure>
<p>就靠这些模版代码就可以轻松的将loginPresenter注入到被测试代码中。</p>
<ul>
<li>通过JUnit的Rule注解来修饰DaggerMockRule，然后告诉DaggerMock你想怎么build Component，使用什么Module，Component build了之后放到哪里。</li>
<li>通过Mock注解修饰你需要修改的依赖对象</li>
<li>框架会反射，再遍历Module中所有被@Provider修饰的函数，如果发现返回的对象类型是@Mock修饰的对象类型，那么就会进行Mock替换。</li>
</ul>
<h3 id="异步代码的单元测试">异步代码的单元测试</h3><p>​ 对于异步的单元测试，有两种解决办法</p>
<ul>
<li>等待异步执行完，回调之后在进行比较</li>
<li>将异步过程在测试代码中转换成同步过程</li>
</ul>
<p>异步的实现手段太多了，线程池，AsyncTask，<strong>RxJava</strong>等等….</p>
<p>第一种方式我们可以通过CountDownLatch来通知异步完成，还可以在Callback中直接测试。这种方式适用于所有拥有Callback形式的异步操作。</p>
<p>第二种方式，比如线程池，我们可以通过依赖注入一个同步的线程池来解决，Rxjava可以使用上述方式，因为Subscriber实际上是一个Callback，可以通过自定义调度插件（RxjavaScheduleHook）来覆盖默认的线程调度方式。</p>
<p><strong>Ps：Android Studio2.2正式版已经默认导入Espresso进行UI测试了</strong></p>
<hr>
<p>参考代码：<a href="https://github.com/lanshan-studio/Android-UnitTest" target="_blank" rel="external">AndroidUnitTest</a></p>
<p>参考文章：<a href="http://chriszou.com/2016/07/24/android-unit-testing-daggermock.html" target="_blank" rel="external">小创的系列教程</a>(作者是蘑菇街的Android开发工程师。敬佩，感谢写出如此优秀的单元测试教学系列文章)</p>
<p>官方文档：<a href="https://google.github.io/android-testing-support-library/" target="_blank" rel="external">官方文档</a></p>
<p>官方代码示例：<a href="https://github.com/googlesamples/android-testing" target="_blank" rel="external">android-test</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/Android系统安全学习（二）/" itemprop="url">
                  Android系统安全学习（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T15:31:02+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/Android系统安全学习（二）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/Android系统安全学习（二）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android中系统Service的安全">Android中系统Service的安全</h2><h3 id="Binder的安全">Binder的安全</h3><ul>
<li>RPC的server端里面的bind thread里面bind会调用getCallingUID()方法来进行对调用远程服务的客户端的check，bind自然是运行在bind thread pool里面的。</li>
<li>ServiceManager是一个远程服务名字管理（注册）器，服务可以通过向ServiceManager注册来使自己晋升为系统服务。提供一个AddService和getService两种服务。他自己的binder是0，在自己这个process fork出来的时候就已经被注册了。</li>
</ul>
<h3 id="Zygote进程fork子进程的安全问题">Zygote进程fork子进程的安全问题</h3><ul>
<li>startActivity的时候，在AMS环境中处理的时候，当activity实例还未生成的时候，会先fork一个进程出来，不然通过反射弄出来的组件实例没有运行环境。在Process.start()之前，会通过PMS解析apk获得uid和gid，然后将这两个参数以及其他参数传给Process.start()方法。这个方法里面会像Zygote进程提出一个request，通过一个ConnectScoket进行连接，将request以二进制流的形式传给Zygote，然后会收到一个pid。Zygote进程里面在main()函数里面会初始化一个功能，循环的读取Peer，并且把这个Peer转换为ZygoteSocket，然后读取request信息，然后就开始fork并且获取进程pid了。</li>
</ul>
<ul>
<li>fork是在Native层做得，因为子进程的EffectiveUID和RealUID世袭父进程的RealUID。并且Zygote进程的RealUID = root，所以需要给fork出来的进程的uid改成request传进来的uid，gid，降级。这些都是在Native层做得。之后回到Java层，才会跳到ActivityThread里面进程activity实例的构建等等等等…。</li>
</ul>
<h3 id="Zygote进程Socket的安全检查">Zygote进程Socket的安全检查</h3><ul>
<li>再从Socket获得Peer的时候，会进行很多东西的检查。比如先检查远端请求进程的UID，如果是root，那么接受，如果是系统服务进程，要么必须要求他说要求让我fork的进程的uid的数字是大于1000的（即一个普通进程），不然就拒绝。当然，普通应用是没资格请求Zygote去fork进程的。</li>
</ul>
<h3 id="ContentProvider以及URI的安全理解">ContentProvider以及URI的安全理解</h3><p>ps：<strong>找到共性，进行抽象</strong></p>
<ul>
<li>ContentProvider就是对一个app的文件，数据库等等数据对外提供一个统一的数据接口，并且可以进程不同app应用之间的数据传递。ContentProvider的设计实际上也是使用了Binder进行跨进程，进而也是一种C/S的设计理念。</li>
<li>Android进程之间都有自己的工作目录，并且地址空间也是分离的，想要直接access是不可以的。</li>
<li>一个ContentProvider的访问权限在manifast里面定义，另一个应用的ContentResolver访问的时候通过URI来提供权限给数据提供者check。URI：content://权限/数据。</li>
</ul>
<h3 id="Policy模式">Policy模式</h3><p>​ 安卓中解决用户隐私，安全的策略模式</p>
<h3 id="SDCard安装应用">SDCard安装应用</h3><ul>
<li>往SD卡上装的应用必须要给手机设备绑定，因为SDccard是可以拔出的，然而数据不应该任何设备都可以访问，所以应用和私有数据会通过SystemKey加密存储在SD卡的.Android_Secure这个隐藏文件夹里面。System key存储在系统的/data/misc/systemkeys文件里。</li>
</ul>
<h3 id="SuperUser机制">SuperUser机制</h3><ul>
<li>换字体，换开机动画，删除系统应用等等都需要Root权限。</li>
<li>Root刷机，找到系统漏洞之后，就会在system文件夹里面安装su文件和superuser apk。su的Owner和Group都是Root，具有可执行权限，并且具有setUid和setGid的权限（会提升或者叫改变自己的EffectiveUID）</li>
<li>RootExplorer会运行su文件（先通过Runtime启动一个shell，然后通过shell启动SU进程），su首先EUID会继承父进程的RUID，生成完进程之后就会通过SUID将自己的EUID提升为Root。SU起来之后，会启动一个SuperuserRequestActivity来询问用户是否授权，并且用户未做决定之前会一直循环的读sqlite中的某个标志位，如果用户允许那么SU继续运行，否则return退出。</li>
<li>在得到用户的允许之后，SU会将自己的RUID设置为Root，使得SU的子进程都是Root的。并且SU自己本身不会去主动fork子进程，而是在SU的进程空间里面去load shell的代码，这样SU只提供一个ROOT的运行空间，如果SU的RUID不是Root，那么sh如果需要启动其他子进程的话，就不会是Root的进程了，那么就会出问题，所以SU的RUID必须为Root</li>
<li>RootExplorer在做了上述的启动过程之后，就可以通过IO流向 shell中写命令，然后这些命令都会在SU中去运行。所以Android中App获得Root权限不是自身的UID升级为Root，而是通过具有Root权限的sh流在执行shell命令。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/29/Android系统安全学习（一）/" itemprop="url">
                  Android系统安全学习（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-29T19:54:14+08:00" content="2016-08-29">
              2016-08-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/29/Android系统安全学习（一）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/29/Android系统安全学习（一）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>进程：一个可执行文件的活动表现，一次生命的历练</p>
<p>进程的地址空间界限，虚拟内存0到4g（32位）,物理内存实际就0到1g</p>
<p>3到4g是内核态，所有进程共享，0到3g是进程的私有空间</p>
<p>这种边界围栏可以防止某一个进程的Crash不会扩延到其他的进程</p>
<p>操作系统的内核Crash，那么整个系统Crash，如果是用户态的普通Crash，不会导致其他的进程Crash</p>
<p>旧时代的塞班系统，单进程多任务，一个app gg那么整个手机gg</p>
<p>一个应用是无法访问另一个应用的数据存储地址</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>多用户目录：每个用户都有自己的HOME，独立的工作目录</p>
<p>用户的访问和操作资源的权限，权限管理</p>
<p>UID GID，16进制整形值，他们才是进程的特征标志，UserId, GroupId</p>
<p>用户是静态表现，进程才是用户的动态表现</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>文件是一种资源，，在Linux里面，一切皆是资源</p>
<p>通过UID来描述文件的Target人群，UID属于GID，如果文件的Target是多个用户，那么就是通过GID来限定权限</p>
<p>root是超级用户，UID＝0，可以做任何事情</p>
<p>PID，进程运行的ID，每次可能不同，GIDs进程所属的全部GID</p>
<p>android的root UID是0，AID_SYSTEM的UID是1000，后面的系统进程只能在1000的基础上累加</p>
<p>android的AID<em>APP的UID是10000，所有的开发应用进程的userId只能在10000的基础上累加，并且UID是通过100xx减去10000，再在这个数字前面加上APP</em>，APP_XX</p>
<p>以上都是宏定义的，name和UID的连接关系是通过一个map来做的</p>
<p>应用的GIDs里面立邦会有一些系统进程的ID，其实就是表明了这些应用的权限</p>
<p>chmod是用来更改权限，r,w,x分别占用一个bit</p>
<p>chown是用来修改文件UID和GID的</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>UID分很多种，Real UID用来表明身份，Effective UID用来表示权利的标示，文件对进程的权限访问就是通过Effective UID来进行判断的</p>
<p>EffectiveUID = root，那么这个进程就是“皇权”进程</p>
<p>UID世袭遵循，身份UID世袭，权利UID不世袭</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>平民身份需要root权限</p>
<p>如果可执行文件设置了setUID标志的话，那么在执行这个文件的时候，子进程的Effective UID就不会在去和父进程的Real UID一样，而是会被提升到可执行文件的owner UID（root等）,但是这样之后，自己是否要为自己正身是很关键的问题，一旦正身，自己的子进程将都是root进程</p>
<p>setUID包含了x这个标志位，占用了x的位置，叫s</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>Capability：与UID相比，细粒度的权限管理，解决权限过剩的问题</p>
<p>UID粒度大的列子：一个进程只需要一个root的某一个权限，却获得了所有的root的权限。</p>
<p>”我们不仅需要皇帝，还需要地方官“</p>
<p>进程的：</p>
<p>Permitted Capability Sets：这个进程最大的权利范围，围栏</p>
<p>Effective Capability Sets：这个进程实际使用的权利集合</p>
<p>Inheritable Capability Sets：这个进程唯一可以直接继承的权限</p>
<p> Capability BoundSet：Init进程的这个参数默认全部为1，可以被子进程继承</p>
<p>文件的：</p>
<p>Permitted Capability Sets：该可执行文件可以为其进程带来的Per Ca Sets</p>
<p>Effective Capability Sets：该执行文件running所在的进程的Per Ca Stes是否全部添加到Effective Ca Sets，只可能会是两个值，Disable和Able</p>
<p>Inheritable Capability Sets：与可执行文件所running的进程的父进程的Inher Ca Sets进行位与运算，然后共同决定子进程Per Ca Sets</p>
<p>计算公式：</p>
<p>P’(permitted) = (p(inheritable) &amp; F(inheritable)) | (F(permotted) &amp; cap_bset)</p>
<p>P’(effective) = F(effective) ? P’(permitted) : 0</p>
<p>P’(inheritable) ＝ P(inheritable)</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>SELinux对于安全性控制的两种模式：</p>
<p>DAC：传统的安全管理模式，主体（进程）对它所属的对象和运行的程序有全部的控制权，这样一旦病毒程序获得了root，那么病毒将可以为所欲为</p>
<p>MAC：SELinux基于的安全策略，管理员来控制访问，用户无法改变，默认情况下应用程序和用户程序没有任何的权限，权限都被管理员规定好了</p>
<p>SEAndroid：将原本运行在Linux系统上的SELinux移植到Android平台，添加了对于Binder IPC, Socket, Properties的访问控制加入到了SEAndroid。目的：即使恶意应用篡夺到了root权限，但是恶意应用仍然会被控制着</p>
<p>自签名：证书的签名者和拥有者都是一个人，可以作为证书链的根证书，</p>
<p>证书链：可以回溯到根证书</p>
<p>权限只会给手机可信任的应用</p>
<p>权限的完整性保护：通过认证并获得签名再加policy权限，将所有的manifist…resource这些文件打包保护起来，所以签名之后，不可能再去偷偷的添加权限</p>
<p>权限的授权安全策略：一般的权限，一般的签名可以通过授权，但是特权的权限，只有通过系统内置的私钥签名才能通过授权，所以一般的应用是拿不到特权权限的</p>
<p>Shared Process UID：</p>
<p>android:sharedUserId=”xxxx”</p>
<p>sharedUID相同就可以共享资源，应用进程的UID相同不能共享数据，只能sharedUID相同才行，这样做的话，相当于同一个开发商或者合作的开发商才会使多个app拥有相同的shareUID，也是在manifist里面注明sharedUID</p>
<p>Android签名：</p>
<ul>
<li><p>完整性鉴别：验证apk的完整性（自签名）</p>
</li>
<li><p>自签名只能表明自己的身份，但是不能表明身份是否可信任</p>
</li>
<li><p>安卓应用的区分标志是Package Name，如果Package Name相同的话，就是进行升级操作，但是升级的要求就是必须签名相同，防止恶意软件冒充其他应用的包名，如果不一致的话，就会先卸载之前的应用，然后再安装新的应用，正常的升级不会删除旧的数据。</p>
</li>
<li><p>apk里面的META INF文件夹就是与签名有关的东西</p>
</li>
</ul>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>安卓权限类别：</p>
<ul>
<li><p>Normal，如果不定义protectionLevel的话，默认就是Normal</p>
</li>
<li><p>Dangerous</p>
</li>
<li><p>Signature：特权权限，必须被用开发厂商私钥加密的签名的apk才允许使用</p>
</li>
<li><p>SignatureOrSystem，必须被用开发厂商和系统私钥加密的签名的aok才允许使用</p>
</li>
</ul>
<p>如果是安卓层级特有的service所提供的服务，那么这样的权限申请将会在Android Framework层进行check out（一个IPC的调用），如果是非安卓特有的服务权限，比如网络请求，文件访问，这些Linux可能就提供了，那么可以通过多个入口进行访问，比如用java的api进行文件读写，而这些权限的check out都是在OS层面统一控制，因此我们需要将这些的权限 mapping到os的GID上。（所有的安卓内置的权限都在framework/base/core/res/mainfest.xml里面定义）</p>
<p>为什么你在应用的mainfest里面定义了读写文件的权限，就可以去访问了呢？：</p>
<p>安卓SD Card文件里面的文件，UID为system的权限为空，GID为Sdcard_rw的权限为rex，others的权限为r－x。所以这个应用进程要想读写scared的话，就必须将自己的GIDs里面添加一个Sdacrd_rw，而manifest里面添加的那个权限申请，最后就会将这个权限和Sdcard_rw映射在一起，并且给添加到这个应用进程的GIDs里面</p>
<p>platform.xml文件定义了一些内置的mapping关系，但是这个文件的更改权限own和group都是root，所以是不能被应用随意篡改的</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>四大组件：呈现层</p>
<p>activity：相当于是将你的ui(view)，通过一个一个的逻辑块分割开，变成一个一个的具有逻辑的页面</p>
<p>组件的Public和Private：组件如果public，那么这个组件可以和其他的进程的组件进行通信，如果组件是private的话，那么这个组件只能和自己进程的组件或者和其他应用里面sharedUID相同的组件进行通信。通过android:expored这个字段来控制组件的public和private，如果不声明的话，就是default值。</p>
<p>default值的理解：如果组件内部通过显示或者隐示的拥有IntentFilter的话，default值就是True，这样其他进程的应用的组件可以通过包名类名来（或者通过一个action等）与这个组件进行通信，如果不拥有IntentFilter的话，那么default值就是False</p>
<p>如果一个组件是public，但是控制某些人才能启动这个组件，那么就需要在manifest的组件里面声明一个permission，这个permission你自己可以在manifest里面定义，那么其他的应用必须要申请了这个permission才可能会被允许和这个组件进行通信。在service安全中，如果你希望不关关是控制是否能够boun or start这个service而是可以进一步的控制能否调用这个service中的某些功能，那么应该及时的调用checkCallingPermission()这个方法，进行细粒度的检查。在ContentProvider安全里面，一般来说他会提供read和wirte两个功能，所以说，exported可以控制你是否能连接到他，如果要进行下一步的操作，必须要申请有他声明在组件里面的readPermission和writePerrimission两个权限，根据你所需要的功能来进行申请。BroadcastReceiver也是一样的道理，可以声明一个权限</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>应用的安装要对用户可知可控，一定要呈现一个view去给用户控制</p>
<p>所以一个应用要去安装其他应用，就必要委派给系统的Install App去负责通知用户，如果用户选择了确认安装，那么会进一步调用Install Package这个系统应用去安装，，并且这个应用拥有INSTALL_PACKAGE这个signature|system等级的权限，也就是说，手机只能是通过Install Package这个应用来安装app。在安装的过程中，就会给应用的applicationinfo.uid赋值，会创建工作目录，并且这个工作目录要和uid,gid对应起来，保证私有的读写权限</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>首先，所有的调用系统远程服务都是通过Binder进行一次远程调用，而在远程的Binder线程池里面，可以调用getCallingUid()方法，这个方法将获得客户端的进程UID，这个UID将会被用于更高级别的系统服务权限识别（就是看你的应用注册权限没有，没有就蹦掉）</p>
<p>还有，服务端的服务将会通过Binder运行时的注册到ServiceManager里面，这时，ServiceManager将会检查这个系统服务的UID，来判断是否是可以被注册的服务</p>
<p> ActivityThread-&gt;ActivityManagerService-&gt;请求Zygote fork子进程-&gt;返回到ActivityThread</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/26/利用redis构建多消费者请求队列/" itemprop="url">
                  利用redis构建多消费者请求队列
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-26T22:40:16+08:00" content="2016-08-26">
              2016-08-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/26/利用redis构建多消费者请求队列/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/26/利用redis构建多消费者请求队列/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="原文：http://peiqiang-net/2014/12/31/python-simple-queue-redis-queue-html">原文：<a href="http://peiqiang.net/2014/12/31/python-simple-queue-redis-queue.html" target="_blank" rel="external">http://peiqiang.net/2014/12/31/python-simple-queue-redis-queue.html</a></h3><h2 id="前言">前言</h2><p>​ 最近在捣腾爬虫，用python去爬取知乎的用户信息，项目地址：<a href="https://github.com/Zane96/Script_Set/tree/master/ZHIHU_Crawler" target="_blank" rel="external">ZHIHU_Crawler</a>（Mongodb+requests+xpath+redis）。由于是年轻的python司机，开始用进程池进行爬取遇到了很多无法解决的问题。后来看到了这篇文章，利用redis的数据存储结构构建一个简单的请求队列，完整地说是一个多消费者请求阻塞队列。这个思想跟Android诸多图片请求库的思想都是相同的，只不过Android多是用Java的并发Api实现（通过Future＋BlockingQueue，我的想法以后是这样去构建），本人上学期也正想自己去造个重复的轮子，但是半路看《Java并发编程》看的有点懵逼，不过下学期一定会补起来。<a href="https://github.com/Zane96/EasyImageProvider" target="_blank" rel="external">EasyImageProvider</a>。<strong>（Zane写）</strong></p>
<h2 id="文章">文章</h2><p>​ 本文展示了如何使用<a href="http://redis.io/" target="_blank" rel="external">redis</a>构建一个简单的多生产者，多消费者队列并且提供类似python标准库<a href="http://docs.python.org/library/queue.html" target="_blank" rel="external">queue</a>一样的接口。你可以使用这个队列方便的从多个进程或者耗时的计算到多个消费者进程之间共享数据。</p>
<p>​ 我们使用redis<a href="http://redis.io/topics/data-types#lists" target="_blank" rel="external">列表</a>来保存数据。redis列表按照字符串插入的顺序保存数据。</p>
<p>​ 下面的redis命令会被用到：</p>
<ul>
<li><a href="http://redis.io/commands/rpush" target="_blank" rel="external">rpush</a> 在列表的末尾插入一个元素</li>
<li><a href="http://redis.io/commands/blpop" target="_blank" rel="external">blpop</a> 从列表开头获取一个元素，如果列表是空则阻塞</li>
<li><a href="http://redis.io/commands/lpop" target="_blank" rel="external">lpop</a> 从列表开头获取一个元素，如果列表是空则返回空</li>
<li><a href="http://redis.io/commands/llen" target="_blank" rel="external">llen</a> 返回列表的长度</li>
</ul>
<p>实现过程使用了<a href="https://github.com/andymccurdy/redis-py" target="_blank" rel="external">redis-py</a>库和服务器进行交互:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisQueue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Simple Queue with Redis Backend"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, namespace=<span class="string">'queue'</span>, **redis_kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""The default connection parameters are: host='localhost', port=6379, db=0"""</span></span><br><span class="line">        self.__db= redis.Redis(**redis_kwargs)</span><br><span class="line">        self.key = <span class="string">'%s:%s'</span> %(namespace, name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qsize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the approximate size of the queue."""</span></span><br><span class="line">        <span class="keyword">return</span> self.__db.llen(self.key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return True if the queue is empty, False otherwise."""</span></span><br><span class="line">        <span class="keyword">return</span> self.qsize() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""Put item into the queue."""</span></span><br><span class="line">        self.__db.rpush(self.key, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, block=True, timeout=None)</span>:</span></span><br><span class="line">        <span class="string">"""Remove and return an item from the queue.</span><br><span class="line"></span><br><span class="line">        If optional args block is true and timeout is None (the default), block</span><br><span class="line">        if necessary until an item is available."""</span></span><br><span class="line">        <span class="keyword">if</span> block:</span><br><span class="line">            item = self.__db.blpop(self.key, timeout=timeout)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            item = self.__db.lpop(self.key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> item:</span><br><span class="line">            item = item[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_nowait</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Equivalent to get(False)."""</span></span><br><span class="line">        <span class="keyword">return</span> self.get(<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure>
<p>​ 使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#62;&#62;&#62; from RedisQueue import RedisQueue&#10;&#62;&#62;&#62; q = RedisQueue(&#39;test&#39;)&#10;&#62;&#62;&#62; q.put(&#39;hello world&#39;)</span><br></pre></td></tr></table></figure>
<p>​ 现在我们使用redis-cli客户端查看数据库，期望的结果如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&#62; keys *&#10;1) &#34;queue:test&#34;&#10;redis 127.0.0.1:6379&#62; type queue:test&#10;list&#10;redis 127.0.0.1:6379&#62; llen queue:test&#10;(integer) 1&#10;redis 127.0.0.1:6379&#62; lrange queue:test 0 1&#10;1) &#34;hello world&#34;</span><br></pre></td></tr></table></figure>
<p>​ 我们可以使用一个不同的脚本来获取数据：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#62;&#62;&#62; from RedisQueue import RedisQueue&#10;&#62;&#62;&#62; q = RedisQueue(&#39;test&#39;)&#10;&#62;&#62;&#62; q.get()&#10;&#39;hello world&#39;</span><br></pre></td></tr></table></figure>
<p>随后的q.get()调用会一直阻塞直到某人重新向队列发送一个新的数据。</p>
<p>接下来的工作将是到队列的 编码/解码（例如<a href="http://docs.python.org/library/json.html" target="_blank" rel="external">python-json</a>），这样你就可以不受限制的发送任何字符串。</p>
<p>现在已经存在漂亮而又简单的<a href="https://github.com/richardhenry/hotqueue" target="_blank" rel="external">hotqueue</a>库，它具有像上面例子中的接口别且提供编码/解码功能。</p>
<p>其他值得提到的使用redis做后端的有:</p>
<ul>
<li><a href="http://flask.pocoo.org/snippets/73/" target="_blank" rel="external">flask-redis</a> flask里使用redis做后端的一个基本的消息队列。</li>
<li><a href="http://celeryproject.org/" target="_blank" rel="external">celery</a> 一个基于分布式消息传递的异步任务队列/工作队列。比其他类库更高级点，可以配合不同的后端工作。</li>
<li><a href="http://nvie.com/rq/" target="_blank" rel="external">rq</a> 简单的python类库作用是队列化任务并且在后端使用消费者进程处理它们。</li>
<li><a href="https://github.com/defunkt/resque" target="_blank" rel="external">resque</a> 一个使用redis做后端的ruby库，主要为了创建后台工作，把他们放到多个队列，稍后处理他们。github在使用，并且有一个漂亮的web监控页面。</li>
<li><a href="https://github.com/binarydud/pyres" target="_blank" rel="external">pyres</a> python下resque的克隆版。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/09/Web缓存的分析/" itemprop="url">
                  Web缓存的分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-09T14:39:36+08:00" content="2016-07-09">
              2016-07-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/09/Web缓存的分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/09/Web缓存的分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2><p>不论是在移动端还是前端，web缓存（Http缓存）都是很重要的一部分。在移动端，对于用户流量控制的优化，web缓存就起到了决定性的作用。最开始接触这块是在使用OkHttp的拦截器修改Http请求头进行web缓存，后来仔细研究了一下这块。而Web缓存就是客户端和服务端之间通过一种约束，通过<strong>新鲜度</strong>和<strong>校验</strong>来给客户端提供缓存资源。</p>
<h3 id="Web缓存的好处">Web缓存的好处</h3><ul>
<li>缓存可以减少手机流量的消耗</li>
<li>可以更快的响应用户的操作，提升用户体验度</li>
<li>降低资源服务器的压力，减少并发量</li>
</ul>
<h3 id="Web缓存的分类">Web缓存的分类</h3><ul>
<li><p>手机文件缓存</p>
<p>由于移动端不像前端，前端开发中浏览器都默认实现了Web缓存，所以我们可以通过请求头的控制来让浏览器自动为我们进行缓存。但是移动端没有这种默认实现Web缓存的容器，所以需要我们自己手动通过文件缓存网络请求过来的报文。Okhttp或者结合Retrofit（一样）都是可以通过OkhttpClient添加一个构造好的Cache实例，其中Cache实例我们需要指定文件路径和大小。具体可以看我这个代码<a href="https://github.com/Zane96/ICY-ClaTable" target="_blank" rel="external">Demo</a>。</p>
</li>
</ul>
<ul>
<li><p>CDN缓存（内容分发网关缓存）</p>
<p>实际上是网关缓存的一种，而网关缓存又叫反向代理缓存（提前接受客户端发来的原始请求，然后进行按需请求分配）。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。通常情况下，浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，浏览器和服务器之间的缓存机制，在这种架构下同样适用。</p>
</li>
<li><p>代理服务器缓存</p>
<p>代理服务器是一种处在客户端和服务端中间的服务器，处在两者之间的网络之中。代理服务器以共享缓存的方式保存着报文副本，可以减少客户端到原始服务器的长距离请求。自然访问同一种报文副本的用户越多，代理服务器的利用率越高，缓存的命中率也越高。</p>
</li>
<li><p>数据库缓存</p>
<p>这是后台开发的时候，缓存从数据库中查找的数据，减少数据库的并发（比如NoSQL）。</p>
</li>
</ul>
<h3 id="共有缓存和私有缓存">共有缓存和私有缓存</h3><ul>
<li>共有缓存(Cache-Control: public)：这种缓存常见的就是代理缓存，意思就是一个用户群体都可以访问这个缓存服务器，这个缓存服务器缓存了所有群体的报文缓存</li>
<li>私有缓存(Cache-Control: private)：这种缓存常见的就是文件缓存（本地缓存），只允许一个用户个体去访问。</li>
</ul>
<h3 id="Web缓存的层次结构">Web缓存的层次结构</h3><p>一般来说，安卓中的图片多级缓存和这个概念不大相同，这里的多级缓存的意思是在客户端和服务端之间部署多级缓存。常见部署如下：</p>
<ul>
<li>手机文件缓存（浏览器缓存）: <strong>一级缓存</strong></li>
<li>小型的局域网内缓存：<strong>二级缓存</strong>，小型的，代价小，容量小的缓存代理</li>
<li>大型的广域网内缓存：<strong>三级缓存</strong> ，大型的，代价高，容量大的缓存代理</li>
</ul>
<h3 id="Web缓存的流程">Web缓存的流程</h3><p>先上张图：</p>
<p><img src="/img/web.png" alt="流程"></p>
<ol>
<li>在客户端发起一次请求的时候，首先一层一层的缓存会根据算法判断缓存中是否存在文档副本，如果不存在的话就会像资源服务器或者父代理缓存服务器（上一级缓存服务器）继续请求客户端需要的资源。</li>
<li>如果资源副本存在的话就会根据资源的元数据（记录资源在缓存中保存了多长时间以及它被用了多少次）来计算资源的新鲜度，如果资源新鲜的话就直接返回给客户端。</li>
<li>如果不新鲜的话，会判断资源在缓存中的副本和在资源服务器里面的文本副本是否一致，如果一致表示资源未发生改变，那么仍然还是由缓存返回。</li>
<li>如果资源发生改变，那么由资源服务器来返回资源给客户端，并且用这份资源存入缓存中。</li>
</ol>
<p>大致流程就是这样，请求－检验－在验证，下面对于过程的细节详细说说：</p>
<h4 id="文档过期的判断">文档过期的判断</h4><p>缓存数据是否过期是由数据的使用期和过期日期共同决定的。</p>
<ul>
<li><p>过期时期(新鲜生存期)</p>
<p>过期时期可以通过Cache-Control的max-age和max-stale或者Expires来设置。其中，Cache-Control中指定的是相对时间，而Expries指定的是数据过期的绝对时间。但是资源服务器的时间经常会出现与客户端不同步的情况（我就遇到过这种坑。。）所以用相对时间更加合理，并且Cache-Control的优先级要高于Expries。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Cache-Control: max-stale = <s></s></th>
<th>在指定的秒数里面缓存可以提供过期了的数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control: max-age = <s></s></td>
<td>在指定的秒数里面，缓存里面的数据不会过期</td>
</tr>
<tr>
<td>Cache-Control: min-fresh = <s></s></td>
<td>至少在未来数秒内数据要保持新鲜</td>
</tr>
<tr>
<td>Cache-Control: private or public</td>
<td>私有缓存或者共有缓存</td>
</tr>
<tr>
<td>Cache-Control: no-cache</td>
<td>提供数据之前必去要去和资源服务器的数据进行比对判断数据是否更新</td>
</tr>
<tr>
<td>Cache-Control: no-store</td>
<td>禁止一切缓存</td>
</tr>
<tr>
<td>Cache-Control: must-revalidate</td>
<td>告诉缓存，必须严格遵循服务器的规定，验证之后才能提供过期的数据</td>
</tr>
<tr>
<td>Cache-Contero: only-if-cached</td>
<td>只有当缓存中有副本的时候，客户端才能获取一份数据副本</td>
</tr>
</tbody>
</table>
<p>需要注意的是</p>
<ol>
<li><strong>no-cache</strong> 不是不使用缓存而是必须比对了之后才能提供，no-store才是完全禁止缓存</li>
<li>优先级：no-staore&gt;no-cache&gt;must-revalidate&gt;max-age&gt;Exprise</li>
</ol>
<p>在移动端的开发中，如何控制我们的数据缓存过期时间需要移动端和后台共同商量之后得出一套方案，比如像数据不停变换更新的并且数据量不大的，应该禁用缓存以保证数据的及时性，像周刊，课表这种长期不变的数据应该添加上合理的缓存时间。</p>
<ul>
<li><p>使用时间</p>
<p>所谓使用时间就是数据从资源服务器发出之后，到被客户端收到，一共经历了多久。但是使用时期并不容易计算。因为服务器，代理，客户端之间时间不同步，网络延时，网络传输耗时等等都会造成使用时期难以计算。</p>
<p>1.直接通过Date首部进行计算</p>
<p>​ 这种计算方式我就被坑过，之前直接设置max-age=3600（一分钟）发现一点缓存效果都没有。我发现响应头的Date首部与现在时间不同，慢了好几天。首先要理解Date首部，<strong>Date首部是服务器发出相应的时间，并且是服务器的绝对时间，并且Date首部只能是资源服务器设置，代理和缓存都不能修改，时间的描述格式由RFC822定义</strong>，所以如果时间不同步的话，直接用客户端时间减去Date来计算使用期是行不通的。</p>
<p>2.通过Age首部进行计算</p>
<p><strong>Age首部只适用于HTTP/1.1的设备，Age表示数据从产生到现在经过了多长时间，是个相对时间</strong></p>
<p>通过Age首部，我们可以累加资源在各个代理中存在的时间，加上数据从资源服务器到缓存的网络传输时间（一般用缓存到服务器，服务器到缓存双向的传输时间来保守估计）。</p>
<p>所以我们可以看出，完整的使用时期计算应该是如下图：</p>
<p><img src="/img/web2.png" alt=""></p>
<p>可以看出其实是忽略了客户端到缓存的网络传输时间，多算了缓存到资源服务器的网络传输时间。</p>
<h3 id="再验证">再验证</h3><p>如果第一次缓存未命中的话，就会进行服务器再验证。用来判断服务器的资源是否发生改变。</p>
<h4 id="If-Modified-Since与Last-Modified（基于Date的再验证）">If-Modified-Since与Last-Modified（基于Date的再验证）</h4><p>  If-Modified-Since是请求字段，值为一个绝对时间，用于通知服务器在这个时间之前，默认资源是未被修改的（不去进行再验证），如果超过了这个时间，就会将这个时间和资源最后修改的时间进行对比，如果小于资源最后修改的时间，那么Last-Modified响应首部会返回资源最后被修改的时间，并且返回200.如果大于最后修改的时间，那么Last-Modified响应首部会返回304表示资源未被修改。</p>
<h4 id="If-None-Match和ETag（基于实体标签的再验证）">If-None-Match和ETag（基于实体标签的再验证）</h4><p>  ETag可以看作是资源的版本号，并且在强验证器下，资源发生细微的变化都会导致ETag的变化，在弱验证器下，资源发生细微的变化都不会导致ETag的变化，这个“细微”度量标准是由后台开发人员来确定的。客户端可以根据If-Modified-Since来添加你现在所拥有的ETag版本号，发送给服务器，然后服务器进行比较。如果版本号不同，那么就会返回200，并且将最新的ETag值添加到ETag响应头里面。如果相同，返回304。<br>  两者之间并没有优先级之分，如果同时存在，那么客户端和服务端应该将两者综合起来考量。</p>
</li>
</ul>
<p><strong>未经博主同意，不得转载该篇文章</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/28/《深入理解jvm》读书笔记——类加载机制/" itemprop="url">
                  《深入理解jvm》读书笔记——类加载机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-28T21:46:26+08:00" content="2016-05-28">
              2016-05-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/28/《深入理解jvm》读书笔记——类加载机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/28/《深入理解jvm》读书笔记——类加载机制/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2><p>​ 我们的java文件在编译的过程中会从.java文件转变为.class文件，.class文件是一串二进制流。而类加载过程就是将编译好的.class文件加载到虚拟机内存中，并对数据进行效验，转换解析和初始化，最终可以形成虚拟机直接使用的java类型。</p>
<h2 id="动态性">动态性</h2><p>​ Java是一门强类型，静态类型的语言。但是Java的动态类加载机制成就了Java的动态性的特点，虽然类型的加载，连接和初始化过程都是在程序运行期间完成的，会造成一定的性能消耗，但是Java的动态性带来的灵活性却是很重要的一部分。比如面向接口编程，反射等等。</p>
<h2 id="何时开始加载">何时开始加载</h2><p> <img src="/img/classloader_1.png" alt="classloader_1"></p>
<p>​ 其中 <strong>验证，准备，解析</strong> 称为连接状态。</p>
<p>​ 开始类加载的时间点分为以下几个触发点：</p>
<ol>
<li><p>虚拟机遇到<strong>new, getstatic,putstatic,invokestatic</strong></p>
<p>以上分别对应<strong>实例化一个对象， 读取或者设置一个类的静态变量（常量除外），调用类的一个静态变量</strong></p>
</li>
<li><p>进行反射（reflect）操作</p>
</li>
<li><p>当初始化一个类的时候，如果发现她的父类还没有被初始化，会先加载它的父类（这就是为什么父类的static代码块会先执行的原因）</p>
</li>
<li><p>虚拟机会首先加载程序的入口（main），安卓中即是ActivityThread的main方法是安卓程序的入口</p>
</li>
<li><p>使用Java1.7加入的MethodHandle的时候解析获得REF_getStatic, REF_putStatic, REF_invokeStatic句柄的时候<strong>关于这个我之前没有了解过，大概是1.7引进的一种类似Reflect中的Method的类，用来方便的反射调用方法的工具</strong></p>
</li>
</ol>
<p>以上的5个条件，如果满足其中的一个条件就会触发类加载。</p>
<p>但是有几种特殊的被动引用的情况不会触发类加载</p>
<ul>
<li><strong>只有直接定义这个字段的类才会被加载，所以子类中调用父类中定义的静态字段不会触发子类的类加载</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> Value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">  staic&#123;</span><br><span class="line">    System.out.println(<span class="string">"Subclass init!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(SubClass.Value + <span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">  SuperClass init!</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>初始化以某个类的实例作为数组元素的数组，不会出发这个类的类加载</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] orgs)</span></span>&#123;</span><br><span class="line">      SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果为空。</span><br></pre></td></tr></table></figure>
<p>​ 虚拟机会加载一个数组类型的类。这个类控制了这个数组的所有操作和属性（length, clone等），这样可以保证开发者在操作的过程中的安全性。比如数组越界等等。</p>
<ul>
<li><strong>调用一个类的常量不会触发这个类的类加载</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantClass</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"ConstantClass init!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] orgs)</span></span>&#123;</span><br><span class="line">      System.out.println(ConstantClass.Value + <span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">  <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>​ 这是因为常量在编译的阶段，就会将被调用类的常量存入调用类的常量池中，所以运行时调用的常量都是自己类里面常量池的常量。</p>
<h2 id="类加载过程">类加载过程</h2><h3 id="加载">加载</h3><ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流（可以是class文件，可以是jar包等等）</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表着歌类的class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>加载阶段完成了之后，二进制字节流就按照虚拟机所需求的格式存储在方法区里面，然后初始化一个class实例，并且这个实例是放在方法区而不是java堆里面，然后这个实例是用来作为方法区里面数据的访问入口的。</p>
<h3 id="验证">验证</h3><p>​ 验证加载进来的二进制字节流中包含的信息的安全性。防止加入了对系统有害的字节流而导致系统的崩溃。</p>
<p>1.<strong>文件格式验证</strong></p>
<p>验证class文件格式，并且是否能被当前的版本的虚拟机吃力</p>
<ul>
<li>检查class文件的魔数开头是否符合正确的格式（OxCAFEBABE）</li>
<li>主次版本号是否能被虚拟机处理</li>
<li>常量池里面是否有不能被支持的常量类型</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
</ul>
<p>​ 等等。。</p>
<p>经过这一步的验证之后，字节流才能被存储到内存的方法区里面，只有这一步的验证是基于字节流的检验，而后面的操作都是对方法区存储结构的检验。</p>
<p><strong>这里需要知道的是，上图中显示的执行顺序不是固定死的，也就是说开始时间是固定了的，但是不是必须加载过程完毕了之后才能开始后续的工作，而是开始了之后，连接过程和其他操作交叉进行</strong></p>
<p>2.<strong>元数据验证</strong></p>
<p>第二阶段是对直接吗描述的信息进行语义分析，以保证描述的信息符合java的语言规范</p>
<ul>
<li>这个类是否有父类（object除外）</li>
<li>这个类是否继承了被final修饰了的类</li>
<li>如果这个类继承了接口或者抽象类，是否实现了所有的抽象方法</li>
<li>类中的字段或者方法签名是否与父类矛盾</li>
</ul>
<p>3.字节码验证</p>
<p>这个阶段是通过数据流河控制流分析程序的语义，逻辑是否安全，是否不会破坏系统。</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体的类型转换有效（比如父类实例不能赋给子类引用等）</li>
</ul>
<p>4.符号引用验证</p>
<p>这段验证发生在解析操作中（将符号引用转变为直接引用），对类自身以外的信息进行匹配性验证</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>
<li>在指定的类中是否存在符合方法的字段描述以及简单名称所描述的方法和字段</li>
<li>符号引用中的类，字段，方法的访问性是否合理（private, protected..）</li>
</ul>
<hr>
<p>不过现在的IDE已经能帮助我们避免很多上面可能会出现的问题了～</p>
<h2 id="准备">准备</h2><p>在这个阶段开始正式为类变量（只包括静态变量不包括实例变量）分配内存并设置类变量初始值（0值）</p>
<h3 id="零值">零值</h3><p>0值的意思就是一个静态变量在经过准备阶段之后会被赋给0而不是原值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">2333</span>;</span><br></pre></td></tr></table></figure>
<p>在经过准备阶段之后，value的值是0而不是2333，而2333这个值会随着putstatic指令存放到类构造器（区分构造器和类构造器，后面具体说）中，然后初始化阶段才会把2333赋值给他。如果是常量的话，会直接在准备阶段赋原值。</p>
<p>以下是集中基本类型的零值：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">零值</th>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">零值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">0</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">0L</td>
<td style="text-align:center">float</td>
<td style="text-align:center">0.0f</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">(short)0</td>
<td style="text-align:center">double</td>
<td style="text-align:center">0.0d</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">‘\u0000’</td>
<td style="text-align:center">refrence</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">(byte)o</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="解析">解析</h2><p>解析就是虚拟机将符号引用转换替换成直接引用的过程。</p>
<ul>
<li>符号引用：</li>
</ul>
<p>符号引用通过一组符号来描述所引用的目标，符号引用可以是任何形式的字面量。</p>
<ul>
<li>直接引用</li>
</ul>
<p>直接指向指定目标的“指针”，相对偏移量或者一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存分布相关，所以同一个符号引用在不同的虚拟机上面翻译出来的直接引用一般都不会相同。如果直接引用已经生成了，那么对象也已经在java堆中存在了。</p>
<blockquote>
<p>一个符号引用被解析一次之后后面可能还会被多次解析，而虚拟机不会重新再解析而是通过缓存去拿出解析的数据，但是invokedynamic指令除外，它会每次被解析都会被重新解析（动态性）</p>
</blockquote>
<p>解析主要针对类，接口，字段，类方法，接口方法，方法类型，方法句柄和调用点限定符7类符号引用进行</p>
<h2 id="初始化">初始化</h2><p>前面的几个过程中，加载是通过类加载器完成，其余都是通过虚拟机主导完成，而初始化就开始真正执行Java程序代码了。可以认为初始化过程就是执行类构造器（<clinit>()）的过程.</clinit></p>
<ul>
<li>类构造器：<ul>
<li><clinit>()是由编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而成的，收集的顺序是按语句在源文件里面出现的顺序所决定的。<strong>解释了为什么静态代码块不能访问定义在自己后面的静态变量</strong></clinit></li>
<li><clinit>()方法在执行之前必须保证自己父类的类构造器方法已经执行完了。所以Object的类构造器永远是最先执行的。<strong>解释了为什么父类的静态代码块会比子类的静态代码块先执行</strong></clinit></li>
<li>一个类或者接口不是必须要有类构造器的（但是必须要有构造器），如果一个类里面没有静态代码块或者类变量，那么不会生成类构造器方法</li>
<li>接口虽然没有静态代码块，但是仍然有成员变量的定义，并且都是常量，所以如果接口定义了成员变量，就一定会生成<clinit>()方法。<strong>但是接口初始化的时候，不会要求自己的父类的类构造器也被执行，同时接口的实现类在初始化的时候也不会先要求执行接口的类构造器方法</strong></clinit></li>
<li><clinit>()是线程同步的，在多线程的情况下，虚拟机会自动的加锁，所以多线程的情况下，如果类构造器方法做了耗时很长的操作，就会造成多线程的阻塞。</clinit></li>
</ul>
</li>
</ul>
<h2 id="类加载器ClassLoader">类加载器ClassLoader</h2><p>类加载器是一个很重要的部分，他并不是一个机器，而不是一个通过类全限定名去获取描述此类的二进制字节流的代码块。这个过程放在虚拟机之外，做到功能上的解耦。目的就是希望用户可以自定义如何将二进制字节流加载进来。<strong>这也体现虚拟机开发团队对于扩展性的看重程度</strong></p>
<h3 id="类与类加载器的关系">类与类加载器的关系</h3><blockquote>
<p>类加载器决定了类的唯一性.</p>
</blockquote>
<p>比如工程里面有一个类A，运行之后系统默认的类加载器会加载一次这个类，如果我们在代码中自定义一个类加载器去再加载一次这个类，那么相当于现在工程里面有了两个类A，后面那个类A的实例化对象instanceof系统类加载器加载的类A，结果肯定会返回false。</p>
<h3 id="双亲委派模型">双亲委派模型</h3><blockquote>
<p>先看所有类加载器的父加载器能不能加载，如果不能加载才会返回给低层的类加载器去加载</p>
</blockquote>
<p>有点类似Android中的view绘制和消息传递机制，不同的是消息机制里面viewgroup先将event传递到view视图底层，如果所有的底层视图都对event不感兴趣才会返回到viewgroup的onTouchEvent和onTouch中。</p>
<p>之前说了，一个全限定名的类如果被一个类加载器加载了之后才会称为同一个类。之所以虚拟机团队要设计这样的模式，就是因为防止这种类型错误的问题。比如Object类是默认被系统的最顶层类加载器加载的，所以所有的程序里面Object都是相同类型的，不会出现Object被其他类加载器加载然后导致Object类型错误的问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/24/《深入理解jvm》读书笔记——垃圾回收以及内存分配/" itemprop="url">
                  《深入理解jvm》读书笔记——垃圾回收以及内存分配
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-24T22:34:40+08:00" content="2016-05-24">
              2016-05-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/24/《深入理解jvm》读书笔记——垃圾回收以及内存分配/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/24/《深入理解jvm》读书笔记——垃圾回收以及内存分配/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2><ul>
<li>JVM的垃圾回收主要发生在java堆，因为线程的私有内存（程序计数器， 虚拟机栈， 本地方法栈）会随着线程的销毁而释放内存，并且栈的内存大小在运行之前就已经根据类结构确定了内存的大小。java堆和方法区（常量池比较特殊）和上面的就不同了，一个接口总的多个实现类需要的内存可能不同，一个方法中的多个分支需要的内存也可能不一样，我们只能在程序运行的时候才知道要去创建哪些对象。</li>
</ul>
<h2 id="对象生命">对象生命</h2><ul>
<li>引用计数算法：给每一个对象添加一个引用计数器，每当有一个引用指向它的时候，他的引用计数器就加一，引用失效就减一。但是无法解决对象相互引用的问题。</li>
<li>可达分析算法（主流）：通过一系列称为”GC Root”的对象作为起点，从这些起点往下进行搜索，搜索走的路经叫做引用链，当一个对象到GC Root没有任何引用链相连的话，就说这个对象是不可达的对象，判定为可以回收的对象</li>
</ul>
<p>​ 可以作为Gc Root对象的种类：</p>
<p>​ 1. 虚拟机栈中引用的对象</p>
<p>​ 2. 方法区中类静态变量引用的对象</p>
<p>​ 3. 方法区中常量引用的对象</p>
<p>​ 4. 本地方法栈中JNI引用的对象</p>
<h2 id="方法区的垃圾回收">方法区的垃圾回收</h2><p>​ 方法区属于jvm中的永久代，也是存在一定的垃圾回收的，但是完全是可以不要求拥有垃圾回收的。</p>
<ul>
<li><p>回收内容：废弃常量和无用的类</p>
<p>无用类的条件：</p>
<ol>
<li>该类所有的实例都已经被回收，也就是java堆中不存在该对象的实例</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的class对象没有在任何地方被引用，没有在其他地方通过反射访问该类的信息</li>
</ol>
</li>
</ul>
<h2 id="垃圾回收算法">垃圾回收算法</h2><ol>
<li>标记清除算法：先根据对象是否已死来标记可以清楚的对象，然后清除。分为两个步骤，但是会产生大量的空间碎片（如果后面的对象需要的连续空间特别大无法满足，就会发生一次Minor gc），效率不高</li>
<li>复制算法：将java堆内存平分为二。当一个部分的对象清除了之后，将剩余的对象按顺序移动到另一块空间里面去，空间将会缩减一半，代价很高，但是不会造成空间碎片。但是现在也一半不是对半分空间，而是8.：1分为（一个Eden, 两个Survivor），Eden和一个Survivor用来收纳新的对象，剩下的一个Survivor用来收纳清除了一遍之后的对象，如果内存空间不够了会去找老年代借空间。</li>
<li>标记整理算法：先是标记，然后移动可以存活的对象顺序排列，这样再清楚可以减少空间碎片的产生。</li>
<li>分代收集算法（主流）：根据对象存活的周期分为年轻代和老年代，然后再年轻代和老年代分别采用不同的垃圾回收算法（比如年轻代用复制算法，老年代用标记整理活着标记清除算法）</li>
</ol>
<h2 id="GC的入口选择">GC的入口选择</h2><p>​ 什么时候开始gc?</p>
<ul>
<li>OopMap：jvm通过OopMap这个数据结构在gc进行时快速得到对象的内存地址</li>
<li>SafePoint：程序到了安全点才会进入垃圾回收，安全点太多，运行的负荷会更大，太少会让gc等待时间太长。所以安全点的选择都是以程序“是否具有让程序长时间执行的特征”为标准进行选定的（比如方法调用，循环跳转，异常跳转等会产生安全点）</li>
</ul>
<p>​ 有时候程序到了安全点，但是线程还在运行，并且没到安全点，一半采用主动中断的方法：给所有的安全点设置一个标志，然后线程运行的时候去不停的询问这个安全点，一旦为真线程就把自己中断。</p>
<ul>
<li>SafeRegion：如果现在有线程在程序到达安全点的时候正在sleep或者blocked状态，那么如何保证线程不会在gc结束之前不运行起来？如果线程执行到安全区域那么就不用管gc是否进行，只需要在离开安全区域的时候询问gc是否结束就可以了，如果还没有结束那么就阻塞自己一直到gc结束。</li>
</ul>
<h2 id="内存分配与回收策略">内存分配与回收策略</h2><p>​ 策略不唯一，会根据参数设置和采用的垃圾回收器组合来动态的确定。</p>
<p>​ 基本的策略：</p>
<ul>
<li><p>对象优先在Eden分配</p>
<p>大多数情况下，对象都会在新生代中分配内存，当Eden中没有足够的内存的时候jvm会发生一次Minor GC</p>
</li>
<li><p>大对象直接进入老年代</p>
<p>大对象指的是需要大量连续空间的Java对象，比如长度很长的字符串和数组。所以我们应该避免写大量“朝生夕灭”的大对象。</p>
</li>
<li><p>长期存活的对象将进入老年代</p>
</li>
</ul>
<p>​ 虚拟机给每一个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活就会被放倒Survivor里面，并且对象年龄增加1，并且每熬过一次就增加1，默认到了15之后就会被移动到老年代里面去</p>
<ul>
<li>动态对象年龄判定</li>
</ul>
<p>​ 虚拟机不会永远要求对象年龄到了最大年龄阀值才会让你进入老年代。如果在Survivor空间中相同的年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代了，这是为了节省Survivor的空间。</p>
<ul>
<li>空间分配担保</li>
</ul>
<p>​ 在年轻代发生Minor GC之前，虚拟机会先检查老年代最大的连续空间是否大于新生代里面所有对象的总和，如果成立那么刻意确保Minor GC是安全的。如果不成立就看能否允许担保失败的参数设置，如果是允许的话，就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就进行Minor GC，如果在这里担保失败的话，就会在老年代进行一次Full GC，如果小于或者不允许担保失败，那么就在老年代进行一次Full GC</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/23/关于Activity的工作原理/" itemprop="url">
                  关于Activity的工作原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-23T00:13:16+08:00" content="2016-04-23">
              2016-04-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/23/关于Activity的工作原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/23/关于Activity的工作原理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言">前言</h1><p>​ 我还记得上个学期意外看到一篇文章，是凯子哥的一篇博客，讲的是app第一个activity启动的底层过程(java)，我当时几乎没接触过这块的源码，好像看了一半就放弃。还有一次刷知乎，看到一个人回答为什么ActivityThread里面Loop不会造成ANR，但是也是一脸萌比。这个学期开始刷艺术探索，已经看完了第十章，每一章都对着源码自己又看了一遍，再加上之前对Binder,IPC的浅显的研究。今天重新再来看这篇文章[<a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287" target="_blank" rel="external">【凯子哥带你学Framework】Activity启动过程全解析</a>]，发现基本上是看小说一样的轻松看完了。。这是一种进步！！感觉挺好的。感谢大神的知识分享，下面我用自己的方式来总结一下Activity启动的过程，但是我跟凯子哥不同，他讲的那个其实就多了一点Launcher和applicaiton创建的知识。</p>
<p>​ 说一点自己的学习感受。首先：</p>
<ul>
<li>源码海洋里面不要太追求了解每一个细节，不然分分钟迷失自我。</li>
</ul>
<ul>
<li>有些知识是需要有其他知识储备才能理解的。所以看不懂的时候放一放，过一段时间再来看。比如binder设计原理那块我就留了一半。。因为后半部分有点看不太懂了，涉及到了C草。</li>
</ul>
<ul>
<li>看书上的源码远远不够，一定一定要自己去独立的看一遍，自己去把整个流程过一遍。</li>
</ul>
<ul>
<li>画草图，流程图。因为过程异常的复杂，在不同的类里面调来调用，又臭又长的调用链。</li>
</ul>
<ul>
<li>永远不要放弃，静下心来研究，一切都不是问题。</li>
</ul>
<h3 id="知识储备">知识储备</h3><ol>
<li><p><strong>Binder</strong>, <strong>IPC机制</strong>。可以看看我之前的两篇文章<a href="http://zane96.github.io/2016/03/19/Android-IPC%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">Android-IPC系列（一）</a><a href="http://zane96.github.io/2016/04/06/Android-IPC%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="external">Android-IPC系列（二）</a> 。还有几篇我觉得写的非常好的文章<a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Android Binder设计与实现 - 设计篇</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="external">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a> 。（这两篇讲的都比较深）看到艺术探索后面我终于知道为什么binder要在第二章就讲解了。因为Binder在后面几乎是无处不在！</p>
</li>
<li><p><strong>ActivityManagerService</strong>。本质就是一个Binder，并且实体在服务端。AMS在远端操作着activity的生命周期。这个进程由SystemServer进程fork出来。</p>
</li>
<li><p><strong>ActivityThread</strong>。大家都知道ActivityThread就是应用的UI线程，main方法就是整个应用的入口。ActivityThread本质并不是一个线程，他只是依附着主线程存在。ActivityThread通过和AMS进行IPC通信来共同管理Activity的生命周期。在后面我准备写一篇关于Handle的续篇，里面还会提到他，因为主线程里面的Looper就是在这里init的。</p>
</li>
<li><p><strong>ApplicationThread</strong>.。它是ActivityThread的内部类，本质上ActivityThread是通过它来进行和AMS的IPC通信的。它的本质也是一个Binder！只不过这次他的实体放在客户端，AMS通过他的代理类<strong>ApplicationThreadProxy</strong>来和ApplicationThread通信。</p>
</li>
</ol>
<ol>
<li><p><strong>Instrumentation</strong>.。这个类我在看完第一遍书的时候感觉操作调用链里面的最外层。因为最后一步Activity实例对象的生成和onCreat()方法的调用最终是来自这个类的。其实这个类是ActivityThread想要进行的操作的具体操作类。这个类是全局的，并且每个acitivity里面都拥有一个它的引用。</p>
</li>
<li><p><strong>ActivityStack（AMS中）</strong>。很好懂，一个activity栈。但是这个ActivityStack是有两种类型的，一种叫系统ActivityStack(HomeTask),这一类的ActivityStack包含着Launcher（或者有其他我不知道的），还有一种是普通应用的ActivityStack（安卓中Task这个概念的具体实现形式），其实就是一个Task（任务栈）。这个类是由AMS来管理，AMS通过这个数据结构来得知activity的状态。</p>
</li>
<li><p><strong>ActivityStackSuperisor（AMS中）</strong>。加了一个单词，就是activity栈的管理者。这个类的作用就是管理栈，并且通过ActivityStack来获得要启动的activity的信息。</p>
</li>
<li><p><strong>ActivityRecord</strong>。这个就是上面说的服务端的actiivty信息的载体类。并且也是服务端的类～这个类相当的重要，自始至终都贯穿在调用链里面，在安卓ActivityStack里面存储的并不是activity实例，其实就是这个ActivityRecord的实例。</p>
</li>
<li><p><strong>ActivityClientRecord</strong>。这个和上面区别就是这个类是客户端activity信息的载体类。</p>
</li>
<li><p><strong>TaskRecord</strong>。同样，这个类就是ActivityTask的信息记录类而已。</p>
<p>​好了，我觉得需要好好了解的几个最核心的类就是这几个了，大家若不清楚，可以自己去源码里面看，如果我有说错的也请原谅。。。其实还有很多概念我在binder那篇文章里面讲的不少了！这里算是又一次的补充吧。</p>
</li>
</ol>
<hr>
<h3 id="Activity启动的流程">Activity启动的流程</h3><p>​ 源码之旅开始。科科.</p>
<p>1.<strong>Activity.startActivity(Intent intent)</strong>这个我们天天都在写，好，去看源码！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Note we want to go through this call for compatibility with</span></span><br><span class="line">            <span class="comment">// applications that may have overridden the method.</span></span><br><span class="line">            startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>嗯，继续看startActivityForResult()；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">            ...省略代码</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>直接调用了Instrumentation去调用execStartActivity()方法。后面的调用先不管，直接去看execStartActivity()方法。<strong>需要注意的是mMainThread.getApplicationThread()就是通过ActivityThread去获得了一个ApplicaitonThread实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span><br><span class="line">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">            Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">        IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">        ...省略代码</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            intent.migrateExtraStreamToClipData();</span><br><span class="line">            intent.prepareToLeaveProcess();</span><br><span class="line">          <span class="comment">//通过AMS启动了</span></span><br><span class="line">            <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                        requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">          <span class="comment">//用来检测这个activity启动的结果，具体可以去查看源码</span></span><br><span class="line">            checkStartActivityResult(result, intent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看到这里发现它又用了个什么玩意调用了startActivity()方法，这是什么呢？这里的<strong>ActivityManagerNative.getDefault()</strong>就是我们期待了很久的ActivityManagerService的代理类！如果你很清楚Binder的实现，这个应该难不倒你吧！AMS和代理类本质上都是IActivityManager的实现类。（IAcitivtyManager,其实就是一个AIDL接口，不信自己去看源码）。我给你看看getDefault()方法的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service binder = "</span> + b);</span><br><span class="line">            &#125;</span><br><span class="line">            IActivityManager am = asInterface(b);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service = "</span> + am);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> am;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>就是这么简单！如果看到这里你看不懂了，建议你再回去看看Binder。接下来我们就可以继续看AMS中startActivity()方法的实现了：<strong>注意，从这里开始，调用链会变得很复杂</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span><br><span class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span><br><span class="line">            <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//调用了startActivityAsUser,caller是我们的ApplicaitonThread</span></span><br><span class="line">        <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, options,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续看这个startActivityAsUser()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span><br><span class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span><br><span class="line">            <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line">        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</span><br><span class="line">                <span class="keyword">false</span>, ALLOW_FULL_ONLY, <span class="string">"startActivity"</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.转换app里面的activity栈,caller是我们的ApplicaitonThread</span></span><br><span class="line">        <span class="keyword">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent,</span><br><span class="line">                resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">                profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, options, userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​ 发现调用了之前提到的ActivityStackSupervisor的startActivityMayWait()方法。这里的目的就是想去通过栈的管理者来通过传进来的数据去改变栈，并且拿到被启动activity的ActivityRecord实例。</p>
<p>​ 在<strong>startActivityMayWait()</strong>里面，主要做了ActivityStack， ActivityInfo, LaunchMode等等各种信息的初始化工作，然后就又调用了<strong>startActivityLocked()方法</strong>， 这个方法里面又做了一系列的变量初始化，初始启动的错误判断, uid检查之后，又调用了<strong>startActivityUncheckedLocked()</strong>方法。这个方法里面根据前面一系列的工作，确定了最终的LanuchMode，这个LaunchMode会在后面的函数被拿来进行判断,构建了一个新的intent，ActivityInfo,ActivityTask。反正过程都TM又臭又长，细看下去一天就耗完了。接下来我们可以看到最终调用<strong>targetStack.resumeTopActivityLocked()方法</strong>。这个targetStack就是新的activity所要放入的Task的位置。也就是说，现在又要转到ActivityTask中去看源码了，科科！</p>
<p>​ 注意的是，LaunchMode和ActivityStack的选择是个很复杂的过程。我推荐一篇文章以及安卓的官方文档链接。<a href="http://developer.android.com/intl/zh-cn/guide/components/tasks-and-back-stack.html" target="_blank" rel="external">官方文档</a>,<a href="www.dunwen.com">顿文的博客</a></p>
<hr>
<p>​ <strong>需要非常注意的是，这个函数执行的时候，被启动的activity里面被添加到栈里面去了，top，next就是指代这个要被启动的activity。pre,current就是指代当前resumed的activity。你别弄混了，虽然这个问题我TM看了一整天的源码。注意，被启动的activity虽然还没有被实例，但是它的ActivityRecord实例已经被构建出来了，并且已经被添加到stack里面去了。具体的调用过程是：</strong></p>
<p>​ Supervisor.setActivityUnchekedLocked-&gt;resumeTopActivityLocked（这里是ActivityStackSuperbisor里面的方法）-&gt;ActivityStack.startActivityLocked在这里将activity添加到stack里面。并且在之后才会调用ActivityStack的resumeTopActivityLocked方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Ensure that the top activity in the stack is resumed.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> prev The previously resumed activity, for when in the process</span><br><span class="line">     * of pausing; can be null to call from elsewhere.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> Returns true if something is being resumed, or false if</span><br><span class="line">     * nothing happened.</span><br><span class="line">     */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityLocked</span><span class="params">(ActivityRecord prev, Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inResumeTopActivity) &#123;</span><br><span class="line">            <span class="comment">// Don't even start recursing.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Protect against recursion.</span></span><br><span class="line">            inResumeTopActivity = <span class="keyword">true</span>;</span><br><span class="line">            result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            inResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>​ 不要有情绪，继续看<strong>resumeTopActivityInnerLocked(prev, options);</strong>这个方法太长了，我分析了一整天，终于所有体会吧。这个方法最终的作用是将启动者activity的生命周期变成paused，这样之后被启动的activity的实例创建了之后才能顺利的resumed。我们来看部分代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the first activity that is not finishing.</span></span><br><span class="line">        <span class="comment">//找出栈顶中第一个没有在被finish的activity,既我们要启动的actiivty</span></span><br><span class="line">        ActivityRecord next = topRunningActivityLocked(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remember how we'll process this pause/resume situation, and ensure</span></span><br><span class="line">        <span class="comment">// that the state is reset however we wind up proceeding.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> userLeaving = mStackSupervisor.mUserLeaving;</span><br><span class="line">        mStackSupervisor.mUserLeaving = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TaskRecord prevTask = prev != <span class="keyword">null</span> ? prev.task : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果整个stack里面是空的，那么直接启动launcher</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// There are no more activities!  Let's just start up the</span></span><br><span class="line">            <span class="comment">// Launcher...</span></span><br><span class="line">            ActivityOptions.abort(options);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG, <span class="string">"resumeTopActivityLocked: No more activities go home"</span>);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">            <span class="comment">// Only resume home if on home display</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> returnTaskType = prevTask == <span class="keyword">null</span> || !prevTask.isOverHomeStack() ?</span><br><span class="line">                    HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo();</span><br><span class="line">            <span class="comment">//直接resume系统ActivityStack里面的根activity(Launcher)</span></span><br><span class="line">            <span class="keyword">return</span> isOnHomeDisplay() &amp;&amp;</span><br><span class="line">                    mStackSupervisor.resumeHomeStackTask(returnTaskType, prev);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​ 在这里，next这个变量很关键。它的注释说的是第一个没有正在被销毁的activity，显然我们要被启动的activity符合这个条件。并且如果这个应用级别的stack是空的，也就是说现在应该跳转到系统级别的stack去，也就是显示系统桌面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the top activity is the resumed one, nothing to do.</span></span><br><span class="line">        <span class="comment">//如果被启动的activity就是当前处理Resumed状态的activity的话，就什么不做。（一个activity启动自己就是这种情况）</span></span><br><span class="line">        <span class="keyword">if</span> (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class="line">                    mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class="line">            <span class="comment">// Make sure we have executed any pending transitions, since there</span></span><br><span class="line">            <span class="comment">// should be nothing left to do at this point.</span></span><br><span class="line">            mWindowManager.executeAppTransition();</span><br><span class="line">            mNoAnimActivities.clear();</span><br><span class="line">            ActivityOptions.abort(options);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG, <span class="string">"resumeTopActivityLocked: Top activity resumed "</span> + next);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure to notify Keyguard as well if it is waiting for an activity to be drawn.</span></span><br><span class="line">            mStackSupervisor.notifyActivityDrawnForKeyguard();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>​ 我注释说的很清楚了，如果要启动的activity已经是resumed了，就什么都不做。因为这就是一个当前resumed的activity启动它自己。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we are sleeping, and there is no resumed activity, and the top</span></span><br><span class="line">        <span class="comment">// activity is paused, well that is the state we want.</span></span><br><span class="line">        <span class="comment">//如果系统正在休眠，并且当前最上层的activity都已经是paused状态了（top activity就是我们要启动的activity）。那就是完美的状态。</span></span><br><span class="line">        <span class="keyword">if</span> (mService.isSleepingOrShuttingDown()</span><br><span class="line">                &amp;&amp; mLastPausedActivity == next</span><br><span class="line">                &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class="line">            <span class="comment">// Make sure we have executed any pending transitions, since there</span></span><br><span class="line">            <span class="comment">// should be nothing left to do at this point.</span></span><br><span class="line">            mWindowManager.executeAppTransition();</span><br><span class="line">            mNoAnimActivities.clear();</span><br><span class="line">            ActivityOptions.abort(options);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG, <span class="string">"resumeTopActivityLocked: Going to sleep and all paused"</span>);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​ 如果系统正在休眠，并且当前最上层的activity都已经是paused状态了（top activity就是我们要启动的activity）。那就是完美的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we are currently pausing an activity, then don't do anything</span></span><br><span class="line">        <span class="comment">// until that is done.</span></span><br><span class="line">        <span class="keyword">if</span> (!mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_PAUSE || DEBUG_STATES) Slog.v(TAG,</span><br><span class="line">                                                                     /  <span class="string">"resumeTopActivityLocked: Skip resume: some activity pausing."</span>);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​ 如果我们的app里面正在暂停某个activity，那么我们什么都不要做等这个做完，因为暂停activity的过程是串行的，必须要一个一个按顺序的来。不能同时来，我认为原因就是因为客户端调用远程服务的过程的时候本地的客户端所在线程会被挂起</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/ We need to start pausing the current activity so the top one</span><br><span class="line">        <span class="comment">// can be resumed...</span></span><br><span class="line">        <span class="comment">//先把现在的当前还是resumed的activity pause了，这样新加进来的activity才能resume。基础知识</span></span><br><span class="line">        <span class="keyword">boolean</span> dontWaitForPause = (next.info.flags&amp;ActivityInfo.FLAG_RESUME_WHILE_PAUSING) != <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//开始暂定现在stack里面所有的activity</span></span><br><span class="line">        <span class="keyword">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, <span class="keyword">true</span>, dontWaitForPause);</span><br><span class="line">        <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//开始pausing当前的所有activity，并且返回一个是否暂定成功的结果回来</span></span><br><span class="line">            pausing |= startPausingLocked(userLeaving, <span class="keyword">false</span>, <span class="keyword">true</span>, dontWaitForPause);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG, <span class="string">"resumeTopActivityLocked: Pausing "</span> + mResumedActivity);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​ 这里就是在做把当前启动者activity给pause掉，即至于为什么要这么做。。不用我多说了吧。</p>
<p>​ startPausingLocked(userLeaving, false, true, dontWaitForPause);这个函数跟着看下去就是通过AMS来暂停activity的过程。这个就不多说了，大同小异。</p>
<p>最终在函数的末尾会又调用ActivityStackSupervisor的<strong>startSpecificActivityLocked(next, true, true);</strong>方法。这个方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span><br><span class="line">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">      <span class="comment">//注意了，这里的app之后会用到，因为app.thread就是获得了applicationthread实例！</span></span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        r.task.stack.setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class="number">0</span></span><br><span class="line">                        || !<span class="string">"android"</span>.equals(r.info.packageName)) &#123;</span><br><span class="line">                    <span class="comment">// Don't add this if it is a platform component that is marked</span></span><br><span class="line">                    <span class="comment">// to run in multiple processes, because this is actually</span></span><br><span class="line">                    <span class="comment">// part of the framework so doesn't make sense to track as a</span></span><br><span class="line">                    <span class="comment">// separate apk in the process.</span></span><br><span class="line">                    app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class="line">                            mService.mProcessStats);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//将app，信息完整的要启动的ActivityRecord类的实例传到另一个方法里面去</span></span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when starting activity "</span></span><br><span class="line">                        + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">            <span class="comment">// restart the application.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续跟进这个<strong>realStartActivityLocked()</strong>（真正启动activity的过程在这里）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r,</span><br><span class="line">            ProcessRecord app, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span></span><br><span class="line">            <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">        r.startFreezingScreenLocked(app, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) Slog.d(TAG, <span class="string">"realStartActivity: setting app visibility true"</span>);</span><br><span class="line">        mWindowManager.setAppVisibility(r.appToken, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// schedule launch ticks to collect information about slow apps.</span></span><br><span class="line">        r.startLaunchTickingLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Have the window manager re-evaluate the orientation of</span></span><br><span class="line">        <span class="comment">// the screen based on the new activity order.  Note that</span></span><br><span class="line">        <span class="comment">// as a result of this, it can call back into the activity</span></span><br><span class="line">        <span class="comment">// manager with a new orientation.  We don't care about that,</span></span><br><span class="line">        <span class="comment">// because the activity is not currently running so we are</span></span><br><span class="line">        <span class="comment">// just restarting it anyway.</span></span><br><span class="line">        <span class="keyword">if</span> (checkConfig) &#123;</span><br><span class="line">            Configuration config = mWindowManager.updateOrientationFromAppTokens(</span><br><span class="line">                    mService.mConfiguration,</span><br><span class="line">                    r.mayFreezeScreenLocked(app) ? r.appToken : <span class="keyword">null</span>);</span><br><span class="line">            mService.updateConfigurationLocked(config, r, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.app = app;</span><br><span class="line">        app.waitingToKill = <span class="keyword">null</span>;</span><br><span class="line">        r.launchCount++;</span><br><span class="line">        r.lastLaunchTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Launching: "</span> + r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx = app.activities.indexOf(r);</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            app.activities.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        mService.updateLruProcessLocked(app, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        mService.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ActivityStack stack = r.task.stack;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;ResultInfo&gt; results = <span class="keyword">null</span>;</span><br><span class="line">            List&lt;Intent&gt; newIntents = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                results = r.results;</span><br><span class="line">                newIntents = r.newIntents;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">...省略代码</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过applicaitonthread调用客户端binder实体的方法。</span></span><br><span class="line">            app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</span><br><span class="line">                    System.identityHashCode(r), r.info, <span class="keyword">new</span> Configuration(mService.mConfiguration),</span><br><span class="line">                    r.compat, r.task.voiceInteractor, app.repProcState, r.icicle, r.persistentState,</span><br><span class="line">                    results, newIntents, !andResume, mService.isNextTransitionForward(),</span><br><span class="line">                    profilerInfo);</span><br><span class="line"></span><br><span class="line">      ...省略代码</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​ 这里面两个很重要的参数，一个是ActivityRecord，一个是app。前者就是在ActivityStack里面转了一圈之后得出来的最终要启动的Activity的信息记录类。后者就是用来获得ApplicationThread来通知客户端拿这个ActivityRecord去管理你的activity的生命周期吧！相当于AMS给了ActivityThread一个任务，让后者去执行。同样，这也是一个IPC的过程。最终调用链绕了好大一圈终于又回到了ApplicaitonThread。</p>
<p>​ 值得一提的是，凡是schedule开头的函数都是通过handler来做线程调度的，不服来辩。我们点进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">int</span> processState,</span><br><span class="line">                <span class="keyword">boolean</span> isForward, Bundle resumeArgs)</span> </span>&#123;</span><br><span class="line">            updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">            sendMessage(H.RESUME_ACTIVITY, token, isForward ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​ 果然用handler发送了一个message。我们来看handler的处理会最终调用handlerLaunchActivity方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">            Bundle oldState = r.state;</span><br><span class="line">            handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</span><br></pre></td></tr></table></figure>
<p>​ 可以看到activity的实例是由performLaunchActivity方法生成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println("##### [" + System.currentTimeMillis() + "] ActivityThread.performLaunchActivity(" + r + ")");</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//获得一些基本信息</span></span><br><span class="line">        ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">        <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                    Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ComponentName component = r.intent.getComponent();</span><br><span class="line">        <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">            component = r.intent.resolveActivity(</span><br><span class="line">                mInitialApplication.getPackageManager());</span><br><span class="line">            r.intent.setComponent(component);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                    r.activityInfo.targetActivity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//通过Instrumentation利用类加载器来生成一个activity实例</span></span><br><span class="line">        Activity activity = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Unable to instantiate activity "</span> + component</span><br><span class="line">                    + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//尝试生成application</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">//创建contextImpl对象，并且调用activity的attach()方法来进行一些activity初始化</span></span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">                Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//设置activity的theme</span></span><br><span class="line">                <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">                <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                    activity.setTheme(theme);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">            mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> activity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​ 做了这些事情</p>
<ul>
<li>从ActivityClientRecord中获取获取组件信息</li>
<li>通过Instrumentation创建Activity对象</li>
<li>通过LoadApk的makeApplication创建application，这个方法有兴趣自己去看，就是一个单例而已。</li>
<li>创建contextImpl对象，并且调用activity的attach()方法来进行一些activity初始化</li>
<li>调用activity的onCreat()方法</li>
</ul>
<p><strong>完成整个过程调用</strong> ！！！！</p>
<h1 id="结束语">结束语</h1><p>​ 系统源码看起来确实感觉自己置身茫茫大海一样，特别是要去找一些不理解的问题的时候。比如到底是被启动的activity的ActivityRecord实例先添加进去还是在实例创建了之后才添加进去，这个问题我看源码着了一天才还没有什么结果，后来在别人的帮助和查阅老罗的资料才找到问题所在。挺不错的一次过程，确实细节不必死扣，但是有些基本问题不懂的话还是应该去探究一下。</p>
<p><strong>版权声明：本文为博主原创文章，未经博主允许不得转载。</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/06/Android-IPC系列（二）/" itemprop="url">
                  Android-IPC系列（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-06T13:48:51+08:00" content="2016-04-06">
              2016-04-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/06/Android-IPC系列（二）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/06/Android-IPC系列（二）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言">前言</h1><p>  写完IPC的第一篇我就有点后悔了。。因为binder的水太深了，老罗写binder写了十几万字。如果深入学习会大量涉及到系统层的知识，甚至SM,Binder驱动都是用c语言写的。。最近也是看了很多大牛关于binder的文章，可以说对binder的认识又提升了一步。<strong>虽然我学的很浅，但是我尽量保证自己写的都是对的！</strong> 来一波binder的最新认识总结吧！～</p>
<p><a href="http://zane96.github.io/2016/03/19/Android-IPC%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">Android_IPC系列(一)</a></p>
<p>上一篇文章主要是介绍一些简单的linux知识，通过AIDL中的生成代码来理解binder实现跨进程的原理。</p>
<p>任务：</p>
<ol>
<li>补充一些Linux知识。</li>
<li>binder实现跨进程通信的实现流程是怎样的</li>
<li>简单介绍binder机制</li>
</ol>
<hr>
<h2 id="一些补充知识">一些补充知识</h2><p>1.<strong>UserSpace, KernelSpace ,用户态，内核态</strong></p>
<p>  用户空间和内核空间。内核空间是linux系统的核心，可以访问受保护资源和所有的硬件设备的权限。内核独立于应用程序，看起来是系统内部的一个应用。kernel有自己的保护措施，告知其他应用程序他拥有什么权限。所以在逻辑上，将kernal和应用程序抽离成两块空间。</p>
<p>  当某个应用程序需要访问内核资源的时候，可以通过系统调用来接入内核。然后内核会来控制这个应用程序对资源的访问，防止这个程序破坏系统资源，保证安全。这时候就会称这个进程处于<strong>内核态</strong> 。当应用程序在跑自己的代码的时候，就称为<strong>用户态</strong>。</p>
<p>2.<strong>Binder驱动</strong></p>
<p>  Linux系统内部是支持socket，信号量等进程通信的，但是安卓系统在性能和安全两个方面设计了自己的进程通信方式：Binder。两个用户空间想要通信，必须通过内核空间来支持。所以安卓就是将binder驱动作为内核模块添加到Linux Kernel。Binder驱动运行在kernel空间，支持用户空间的通信，可以堪称一个桥梁，所有包含binder的数据包传输都会通过binder驱动来完成，无一例外！在binder驱动里面，binder的实体和引用是以节点（struct）的形式存在的，包括server的binder实体，clinet里面拥有的binder引用，内核的0号应用以及SM的binder实体（后两者后面会提到）。</p>
<p>  驱动是Binder通信的核心，系统中所有的Binder实体以及每个实体在各个进程中的引用都登记在驱动中；驱动需要记录Binder引用-&gt;实体之间多对一的关系；为引用找到对应的实体；在某个进程中为实体创建或查找到对应的引用；记录Binder的归属地（位于哪个进程中）；通过管理Binder的强/弱引用创建/销毁Binder实体等等。</p>
<p>3.<strong>ServiceManager, Binder,Clinet, Server</strong></p>
<p>  在Binder的机制中，SM, Clinet, Server以及上面提到的Binder驱动是很重要的四个部分，而binder就可以看成是这四个部件之间沟通的管道。但是binder在每个部件里面的形态，功能是完全不同的。宏观来看，binder可以看成是安卓跨进程通信的方式，工具，协议。微观的来看，binder可以看成各个部件里面重要的结构，类，binder可以看成binder驱动里面的红黑树数据结构，binder可以看成进程之间传输的数据包。binder作为胶水，将不同的进程粘合在一起，模糊了进程隔离。</p>
<p>  ServiceManager是独立于client, server的系统进程。是由zygote进程fork出来的。它在IPC通信中的作用是作为”通讯录”。所有的server里面的binder实体会先在SM里面注册自己的信息，key是binder的名字（独一无二），在AIDL的生成代码里面你会看到这个玩意:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR =<span class="string">"com.example.zane.ipc_test.IBookManager"</span>;</span><br></pre></td></tr></table></figure>
<p>value就是这个binder的引用，这样就把这个binder的信息保存下来了。也就是说client需要通过SM，以名字来去得到server的binder引用。然后通过这个引用去操作server端的binder。这里也体现了binder中面向对象的设计理念。clinet自己并不知道自己获得的这个binder引用是真的实体还是什么假的实体，它只会去拿着自己获得的引用去操作。并且server中binder实体的引用会在SM,和所有需要跟自己通信的clinet里面存在。在这里，你可以把引用看成指针，或者代理对象。</p>
<p>  client和server就是客户端和服务端。</p>
<p>  在服务端：如果你熟悉AIDL进行进程间通信的流程或者看过我上篇博客，你应该对binder的存在形式有所体会。首先是一个aidl类型的接口，定义了binder的所有功能函数。并且这些功能函数需要被编号，因为服务端是通过解析客户端传递过来的数据包中的函数编号来知道自己应该去调用什么函数。在Stub类中有这么几行代码(函数编号):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>  我们知道Stub就是Binder在Server的实体，里面实现了很多函数，onTransact()就是来分析客户端的请求类型的函数，然后调用相应的函数，并且将返回结果放在数据包中返回给客户端。</p>
<p>  在客户端：同样的，我们在客户端也需要去实现Binder，只不过这个binder是SM转发给我们的，如果客户端和服务端在同一个进程，那么就会返回binder实体，如果不在同一个进程就会返回binder的代理。由于binder代理和binder实体都是实现了AIDL接口的类。所以客户端看不出来这个binder是实体或是引用。如果你做过IPC通信，你会知道以上的过程是通过asInterface(IBiner binder)这个方法实现的。</p>
<hr>
<h2 id="实现流程">实现流程</h2><p>  直接上一张我自己画的简介图！</p>
<p><img src="/img/ipc2-1.png" alt="简介图"></p>
<p>  可以很清楚的看出，binder驱动是整个流程的核心！</p>
<p>  1.Server将自己的binder通过binder驱动在SM中进行注册。</p>
<p>  2.binder驱动会建立一个binder实体的数据节点和实体的引用。</p>
<p>  3.Binder驱动再把名字和引用打包发给SM。</p>
<p>  4.Client通过binder驱动拿着他所需要的binder名字向SM请求binder。</p>
<p>  5.SM在自己的查找表里面找到对应的引用之后再通过binder驱动返回给client。</p>
<p><strong>所有的系统服务在SystemServer进程深沉之后就会被建立并且注册在ServiceManager里面，开发者也可以开发自定义的服务并且注册在ServiceManager里面成为系统级别的服务，前提是这个包含服务的应用必须是system用户并且带了system签名（系统安全），否则是不能随意注册的！</strong></p>
<p>  好了，再来一张我在一位大牛博客里面截下来的图片，这个流程描述就更具体了：</p>
<p><img src="/img/ipc2-2.png" alt="具体图"></p>
<p>  其实就是多了binder驱动里面的一些数据结构节点和一个叫0号引用的东西。那么这个0号引用是什么呢？我们知道SM, Client, Server都是运行在三个不同的进程的。那么第一步Server要向SM注册自己binder的信息，那么这里已经涉及到了跨进程通信了。那么这个进程通信是怎么实现的呢？通过上图可以看到，所有的Client里面的0号引用都指向了SM里面的binder。也就是说SM和其他所有Server通信的过程都是SM先通过特殊的命令在biner驱动中建立了自己binder的实体节点，并且其他所有地方的0号引用都默认留给SM的binder实体引用。</p>
<hr>
<h1 id="结束语">结束语</h1><p>  上一篇文章讲的AIDL生成代码的分析，本来准备第二篇总结一下AIDL的使用。后来通过不断的学习觉得这篇文章讲的东西更值得总结！</p>
<p>  总之，binder要学习的东西还是很多。比如binder协议，binder传输数据包类型，binder在驱动里面的数据结构，缓存和线程池管理等等…<strong>Binder在安全性，效率性都优于Linux系统默认支持的IPC通信方式,拥有面向对象的设计原理。</strong></p>
<p><strong>未经博主同意，不得转载该篇文章</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me.jpg"
               alt="Zane Xu" />
          <p class="site-author-name" itemprop="name">Zane Xu</p>
          <p class="site-description motion-element" itemprop="description">Talk is Cheap, Show me the Code</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Zane96" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.weibo.com/2643215417" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/xu-zhi-75-83" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zane Xu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zane"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

  


</body>
</html>
